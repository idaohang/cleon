###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430       26/May/2013  01:02:23 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  64                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  large                                                   #
#    Source file   =  C:\Users\woosuk\Dropbox\lws\ESL\3. Research\9. Summer   #
#                     2013\2_cleon\4. Development\1.                          #
#                     Software\cleon\fs\FatFs\ff.c                            #
#    Command line  =  "C:\Users\woosuk\Dropbox\lws\ESL\3. Research\9. Summer  #
#                     2013\2_cleon\4. Development\1.                          #
#                     Software\cleon\fs\FatFs\ff.c" -lC                       #
#                     "C:\Users\woosuk\Dropbox\lws\ESL\3. Research\9. Summer  #
#                     2013\2_cleon\4. Development\1.                          #
#                     Software\cleon\Debug\List\" -la                         #
#                     "C:\Users\woosuk\Dropbox\lws\ESL\3. Research\9. Summer  #
#                     2013\2_cleon\4. Development\1.                          #
#                     Software\cleon\Debug\List\" -o                          #
#                     "C:\Users\woosuk\Dropbox\lws\ESL\3. Research\9. Summer  #
#                     2013\2_cleon\4. Development\1.                          #
#                     Software\cleon\Debug\Obj\" --no_cse --no_unroll         #
#                     --no_inline --no_code_motion --no_tbaa --debug          #
#                     -D__MSP430F5338__ -e --double=64 --dlib_config          #
#                     "C:\Program Files (x86)\IAR Systems\Embedded Workbench  #
#                     6.5\430\LIB\DLIB\dl430xldn.h" -I                        #
#                     "C:\Users\woosuk\Dropbox\lws\ESL\3. Research\9. Summer  #
#                     2013\2_cleon\4. Development\1. Software\cleon\intro\"   #
#                     -I "C:\Users\woosuk\Dropbox\lws\ESL\3. Research\9.      #
#                     Summer 2013\2_cleon\4. Development\1.                   #
#                     Software\cleon\sys\" -I "C:\Users\woosuk\Dropbox\lws\ES #
#                     L\3. Research\9. Summer 2013\2_cleon\4. Development\1.  #
#                     Software\cleon\hal\" -I "C:\Users\woosuk\Dropbox\lws\ES #
#                     L\3. Research\9. Summer 2013\2_cleon\4. Development\1.  #
#                     Software\cleon\hal\rtclib\" -I                          #
#                     "C:\Users\woosuk\Dropbox\lws\ESL\3. Research\9. Summer  #
#                     2013\2_cleon\4. Development\1.                          #
#                     Software\cleon\platform\" -I                            #
#                     "C:\Users\woosuk\Dropbox\lws\ESL\3. Research\9. Summer  #
#                     2013\2_cleon\4. Development\1. Software\cleon\fs\" -I   #
#                     "C:\Users\woosuk\Dropbox\lws\ESL\3. Research\9. Summer  #
#                     2013\2_cleon\4. Development\1.                          #
#                     Software\cleon\fs\FatFs\" -I                            #
#                     "C:\Users\woosuk\Dropbox\lws\ESL\3. Research\9. Summer  #
#                     2013\2_cleon\4. Development\1. Software\cleon\app\" -I  #
#                     "C:\Users\woosuk\Dropbox\lws\ESL\3. Research\9. Summer  #
#                     2013\2_cleon\4. Development\1. Software\cleon\"         #
#                     --core=430X --data_model=large -On --multiplier=32      #
#                     --multiplier_location=4C0 --hw_workaround=CPU40         #
#    List file     =  C:\Users\woosuk\Dropbox\lws\ESL\3. Research\9. Summer   #
#                     2013\2_cleon\4. Development\1.                          #
#                     Software\cleon\Debug\List\ff.lst                        #
#    Object file   =  C:\Users\woosuk\Dropbox\lws\ESL\3. Research\9. Summer   #
#                     2013\2_cleon\4. Development\1.                          #
#                     Software\cleon\Debug\Obj\ff.r43                         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\woosuk\Dropbox\lws\ESL\3. Research\9. Summer 2013\2_cleon\4. Development\1. Software\cleon\fs\FatFs\ff.c
      1          /*----------------------------------------------------------------------------/
      2          /  FatFs - FAT file system module  R0.09a                 (C)ChaN, 2012
      3          /-----------------------------------------------------------------------------/
      4          / FatFs module is a generic FAT file system module for small embedded systems.
      5          / This is a free software that opened for education, research and commercial
      6          / developments under license policy of following terms.
      7          /
      8          /  Copyright (C) 2012, ChaN, all right reserved.
      9          /
     10          / * The FatFs module is a free software and there is NO WARRANTY.
     11          / * No restriction on use. You can use, modify and redistribute it for
     12          /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
     13          / * Redistributions of source code must retain the above copyright notice.
     14          /
     15          /-----------------------------------------------------------------------------/
     16          / Feb 26,'06 R0.00  Prototype.
     17          /
     18          / Apr 29,'06 R0.01  First stable version.
     19          /
     20          / Jun 01,'06 R0.02  Added FAT12 support.
     21          /                   Removed unbuffered mode.
     22          /                   Fixed a problem on small (<32M) partition.
     23          / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
     24          /
     25          / Sep 22,'06 R0.03  Added f_rename().
     26          /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
     27          / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
     28          /                   Fixed f_mkdir() creates incorrect directory on FAT32.
     29          /
     30          / Feb 04,'07 R0.04  Supported multiple drive system.
     31          /                   Changed some interfaces for multiple drive system.
     32          /                   Changed f_mountdrv() to f_mount().
     33          /                   Added f_mkfs().
     34          / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
     35          /                   Added a capability of extending file size to f_lseek().
     36          /                   Added minimization level 3.
     37          /                   Fixed an endian sensitive code in f_mkfs().
     38          / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
     39          /                   Added FSInfo support.
     40          /                   Fixed DBCS name can result FR_INVALID_NAME.
     41          /                   Fixed short seek (<= csize) collapses the file object.
     42          /
     43          / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
     44          /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
     45          /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
     46          / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
     47          /                   Fixed off by one error at FAT sub-type determination.
     48          /                   Fixed btr in f_read() can be mistruncated.
     49          /                   Fixed cached sector is not flushed when create and close without write.
     50          /
     51          / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
     52          /                   Improved performance of f_lseek() on moving to the same or following cluster.
     53          /
     54          / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
     55          /                   Added long file name feature.
     56          /                   Added multiple code page feature.
     57          /                   Added re-entrancy for multitask operation.
     58          /                   Added auto cluster size selection to f_mkfs().
     59          /                   Added rewind option to f_readdir().
     60          /                   Changed result code of critical errors.
     61          /                   Renamed string functions to avoid name collision.
     62          / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
     63          /                   Added multiple sector size feature.
     64          / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
     65          /                   Fixed wrong cache control in f_lseek().
     66          /                   Added relative path feature.
     67          /                   Added f_chdir() and f_chdrive().
     68          /                   Added proper case conversion to extended char.
     69          / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
     70          /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
     71          /                   Fixed name matching error on the 13 char boundary.
     72          /                   Added a configuration option, _LFN_UNICODE.
     73          /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
     74          /
     75          / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
     76          /                   Added file lock feature. (_FS_SHARE)
     77          /                   Added fast seek feature. (_USE_FASTSEEK)
     78          /                   Changed some types on the API, XCHAR->TCHAR.
     79          /                   Changed fname member in the FILINFO structure on Unicode cfg.
     80          /                   String functions support UTF-8 encoding files on Unicode cfg.
     81          / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
     82          /                   Added sector erase feature. (_USE_ERASE)
     83          /                   Moved file lock semaphore table from fs object to the bss.
     84          /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
     85          /                   Fixed f_mkfs() creates wrong FAT32 volume.
     86          / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
     87          /                   f_lseek() reports required table size on creating CLMP.
     88          /                   Extended format syntax of f_printf function.
     89          /                   Ignores duplicated directory separators in given path name.
     90          /
     91          / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
     92          /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
     93          / Aug 27,'12 R0.09a Fixed assertion failure due to OS/2 EA on FAT12/16 volume.
     94          /                   Changed f_open() and f_opendir reject null object pointer to avoid crash.
     95          /                   Changed option name _FS_SHARE to _FS_LOCK.
     96          /---------------------------------------------------------------------------*/
     97          
     98          #include "fs_define.h"
     99          #include "hal_define.h"
    100          
    101          /*--------------------------------------------------------------------------
    102          
    103             Module Private Definitions
    104          
    105          ---------------------------------------------------------------------------*/
    106          
    107          #if _FATFS != 4004	/* Revision ID */
    108          #error Wrong include file (ff.h).
    109          #endif
    110          
    111          
    112          /* Definitions on sector size */
    113          #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
    114          #error Wrong sector size.
    115          #endif
    116          #if _MAX_SS != 512
    117          #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
    118          #else
    119          #define	SS(fs)	512U			/* Fixed sector size */
    120          #endif
    121          
    122          
    123          /* Reentrancy related */
    124          #if _FS_REENTRANT
    125          #if _USE_LFN == 1
    126          #error Static LFN work area must not be used in re-entrant configuration.
    127          #endif
    128          #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
    129          #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
    130          #else
    131          #define	ENTER_FF(fs)
    132          #define LEAVE_FF(fs, res)	return res
    133          #endif
    134          
    135          #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
    136          
    137          
    138          /* File access control feature */
    139          #if _FS_LOCK
    140          #if _FS_READONLY
    141          #error _FS_LOCK must be 0 on read-only cfg.
    142          #endif
    143          typedef struct {
    144          	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
    145          	DWORD clu;				/* File ID 2, directory */
    146          	WORD idx;				/* File ID 3, directory index */
    147          	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
    148          } FILESEM;
    149          #endif
    150          
    151          
    152          
    153          /* DBCS code ranges and SBCS extend char conversion table */
    154          
    155          #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
    156          #define _DF1S	0x81	/* DBC 1st byte range 1 start */
    157          #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
    158          #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
    159          #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
    160          #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
    161          #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
    162          #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
    163          #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
    164          
    165          #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
    166          #define _DF1S	0x81
    167          #define _DF1E	0xFE
    168          #define _DS1S	0x40
    169          #define _DS1E	0x7E
    170          #define _DS2S	0x80
    171          #define _DS2E	0xFE
    172          
    173          #elif _CODE_PAGE == 949	/* Korean */
    174          #define _DF1S	0x81
    175          #define _DF1E	0xFE
    176          #define _DS1S	0x41
    177          #define _DS1E	0x5A
    178          #define _DS2S	0x61
    179          #define _DS2E	0x7A
    180          #define _DS3S	0x81
    181          #define _DS3E	0xFE
    182          
    183          #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
    184          #define _DF1S	0x81
    185          #define _DF1E	0xFE
    186          #define _DS1S	0x40
    187          #define _DS1E	0x7E
    188          #define _DS2S	0xA1
    189          #define _DS2E	0xFE
    190          
    191          #elif _CODE_PAGE == 437	/* U.S. (OEM) */
    192          #define _DF1S	0
    193          #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    194          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    195          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    196          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    197          
    198          #elif _CODE_PAGE == 720	/* Arabic (OEM) */
    199          #define _DF1S	0
    200          #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    201          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    202          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    203          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    204          
    205          #elif _CODE_PAGE == 737	/* Greek (OEM) */
    206          #define _DF1S	0
    207          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
    208          				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    209          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    210          				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    211          
    212          #elif _CODE_PAGE == 775	/* Baltic (OEM) */
    213          #define _DF1S	0
    214          #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    215          				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    216          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    217          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    218          
    219          #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
    220          #define _DF1S	0
    221          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    222          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    223          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    224          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    225          
    226          #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
    227          #define _DF1S	0
    228          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
    229          				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
    230          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    231          				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
    232          
    233          #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
    234          #define _DF1S	0
    235          #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
    236          				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
    237          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
    238          				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
    239          
    240          #elif _CODE_PAGE == 857	/* Turkish (OEM) */
    241          #define _DF1S	0
    242          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
    243          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    244          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    245          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    246          
    247          #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
    248          #define _DF1S	0
    249          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    250          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    251          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    252          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    253          
    254          #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
    255          #define _DF1S	0
    256          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    257          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    258          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    259          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    260          
    261          #elif _CODE_PAGE == 866	/* Russian (OEM) */
    262          #define _DF1S	0
    263          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    264          				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    265          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    266          				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    267          
    268          #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
    269          #define _DF1S	0
    270          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    271          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    272          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    273          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    274          
    275          #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
    276          #define _DF1S	0
    277          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    278          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
    279          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    280          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    281          
    282          #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
    283          #define _DF1S	0
    284          #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    285          				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
    286          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    287          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
    288          
    289          #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
    290          #define _DF1S	0
    291          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
    292          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    293          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    294          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    295          
    296          #elif _CODE_PAGE == 1253 /* Greek (Windows) */
    297          #define _DF1S	0
    298          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    299          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    300          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
    301          				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
    302          
    303          #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
    304          #define _DF1S	0
    305          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    306          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    307          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    308          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    309          
    310          #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
    311          #define _DF1S	0
    312          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    313          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    314          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    315          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    316          
    317          #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
    318          #define _DF1S	0
    319          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    320          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    321          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    322          				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
    323          
    324          #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
    325          #define _DF1S	0
    326          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    327          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
    328          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    329          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    330          
    331          #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
    332          #define _DF1S	0
    333          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
    334          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    335          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    336          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
    337          
    338          #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
    339          #if _USE_LFN
    340          #error Cannot use LFN feature without valid code page.
    341          #endif
    342          #define _DF1S	0
    343          
    344          #else
    345          #error Unknown code page
    346          
    347          #endif
    348          
    349          
    350          /* Character code support macros */
    351          #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
    352          #define IsLower(c)	(((c)>='a')&&((c)<='z'))
    353          #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
    354          
    355          #if _DF1S		/* Code page is DBCS */
    356          
    357          #ifdef _DF2S	/* Two 1st byte areas */
    358          #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
    359          #else			/* One 1st byte area */
    360          #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
    361          #endif
    362          
    363          #ifdef _DS3S	/* Three 2nd byte areas */
    364          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
    365          #else			/* Two 2nd byte areas */
    366          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
    367          #endif
    368          
    369          #else			/* Code page is SBCS */
    370          
    371          #define IsDBCS1(c)	0
    372          #define IsDBCS2(c)	0
    373          
    374          #endif /* _DF1S */
    375          
    376          
    377          /* Name status flags */
    378          #define NS			11		/* Index of name status byte in fn[] */
    379          #define NS_LOSS		0x01	/* Out of 8.3 format */
    380          #define NS_LFN		0x02	/* Force to create LFN entry */
    381          #define NS_LAST		0x04	/* Last segment */
    382          #define NS_BODY		0x08	/* Lower case flag (body) */
    383          #define NS_EXT		0x10	/* Lower case flag (ext) */
    384          #define NS_DOT		0x20	/* Dot entry */
    385          
    386          
    387          /* FAT sub-type boundaries */
    388          /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
    389          #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
    390          #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
    391          
    392          
    393          /* FatFs refers the members in the FAT structures as byte array instead of
    394          / structure member because the structure is not binary compatible between
    395          / different platforms */
    396          
    397          #define BS_jmpBoot			0	/* Jump instruction (3) */
    398          #define BS_OEMName			3	/* OEM name (8) */
    399          #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
    400          #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
    401          #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
    402          #define BPB_NumFATs			16	/* Number of FAT copies (1) */
    403          #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
    404          #define BPB_TotSec16		19	/* Volume size [sector] (2) */
    405          #define BPB_Media			21	/* Media descriptor (1) */
    406          #define BPB_FATSz16			22	/* FAT size [sector] (2) */
    407          #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
    408          #define BPB_NumHeads		26	/* Number of heads (2) */
    409          #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
    410          #define BPB_TotSec32		32	/* Volume size [sector] (4) */
    411          #define BS_DrvNum			36	/* Physical drive number (2) */
    412          #define BS_BootSig			38	/* Extended boot signature (1) */
    413          #define BS_VolID			39	/* Volume serial number (4) */
    414          #define BS_VolLab			43	/* Volume label (8) */
    415          #define BS_FilSysType		54	/* File system type (1) */
    416          #define BPB_FATSz32			36	/* FAT size [sector] (4) */
    417          #define BPB_ExtFlags		40	/* Extended flags (2) */
    418          #define BPB_FSVer			42	/* File system version (2) */
    419          #define BPB_RootClus		44	/* Root dir first cluster (4) */
    420          #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
    421          #define BPB_BkBootSec		50	/* Offset of backup boot sector (2) */
    422          #define BS_DrvNum32			64	/* Physical drive number (2) */
    423          #define BS_BootSig32		66	/* Extended boot signature (1) */
    424          #define BS_VolID32			67	/* Volume serial number (4) */
    425          #define BS_VolLab32			71	/* Volume label (8) */
    426          #define BS_FilSysType32		82	/* File system type (1) */
    427          #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
    428          #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
    429          #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
    430          #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
    431          #define MBR_Table			446	/* MBR: Partition table offset (2) */
    432          #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
    433          #define BS_55AA				510	/* Boot sector signature (2) */
    434          
    435          #define	DIR_Name			0	/* Short file name (11) */
    436          #define	DIR_Attr			11	/* Attribute (1) */
    437          #define	DIR_NTres			12	/* NT flag (1) */
    438          #define DIR_CrtTimeTenth	13	/* Created time sub-second (1) */
    439          #define	DIR_CrtTime			14	/* Created time (2) */
    440          #define	DIR_CrtDate			16	/* Created date (2) */
    441          #define DIR_LstAccDate		18	/* Last accessed date (2) */
    442          #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
    443          #define	DIR_WrtTime			22	/* Modified time (2) */
    444          #define	DIR_WrtDate			24	/* Modified date (2) */
    445          #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
    446          #define	DIR_FileSize		28	/* File size (4) */
    447          #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
    448          #define	LDIR_Attr			11	/* LFN attribute (1) */
    449          #define	LDIR_Type			12	/* LFN type (1) */
    450          #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
    451          #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
    452          #define	SZ_DIR				32		/* Size of a directory entry */
    453          #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
    454          #define	DDE					0xE5	/* Deleted directory entry mark in DIR_Name[0] */
    455          #define	NDDE				0x05	/* Replacement of the character collides with DDE */
    456          
    457          
    458          /*------------------------------------------------------------*/
    459          /* Module private work area                                   */
    460          /*------------------------------------------------------------*/
    461          /* Note that uninitialized variables with static duration are
    462          /  zeroed/nulled at start-up. If not, the compiler or start-up
    463          /  routine is out of ANSI-C standard.
    464          */
    465          
    466          #if _VOLUMES
    467          static

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
    468          FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
   \                     FatFs:
   \   000000                DS8 4
    469          #else
    470          #error Number of volumes must not be 0.
    471          #endif
    472          
    473          static

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
    474          WORD Fsid;				/* File system mount ID */
   \                     Fsid:
   \   000000                DS8 2
    475          
    476          #if _FS_RPATH
    477          static

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
    478          BYTE CurrVol;			/* Current drive */
   \                     CurrVol:
   \   000000                DS8 1
    479          #endif
    480          
    481          #if _FS_LOCK
    482          static
    483          FILESEM	Files[_FS_LOCK];	/* File lock semaphores */
    484          #endif
    485          
    486          #if _USE_LFN == 0			/* No LFN feature */
    487          #define	DEF_NAMEBUF			BYTE sfn[12]
    488          #define INIT_BUF(dobj)		(dobj).fn = sfn
    489          #define	FREE_BUF()
    490          
    491          #elif _USE_LFN == 1			/* LFN feature with static working buffer */
    492          static WCHAR LfnBuf[_MAX_LFN+1];
    493          #define	DEF_NAMEBUF			BYTE sfn[12]
    494          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
    495          #define	FREE_BUF()
    496          
    497          #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
    498          #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
    499          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
    500          #define	FREE_BUF()
    501          
    502          #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
    503          #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
    504          #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
    505          							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
    506          							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
    507          #define	FREE_BUF()			ff_memfree(lfn)
    508          
    509          #else
    510          #error Wrong LFN configuration.
    511          #endif
    512          
    513          
    514          
    515          
    516          /*--------------------------------------------------------------------------
    517          
    518             Module Private Functions
    519          
    520          ---------------------------------------------------------------------------*/
    521          
    522          
    523          /*-----------------------------------------------------------------------*/
    524          /* String functions                                                      */
    525          /*-----------------------------------------------------------------------*/
    526          
    527          /* Copy memory to memory */

   \                                 In  segment CODE, align 2
    528          static
    529          void mem_cpy (void* dst, const void* src, UINT cnt) {
   \                     mem_cpy:
   \   000000   1B14         PUSHM.A #0x2, R11
    530          	BYTE *d = (BYTE*)dst;
   \   000002   CA0C         MOVA    R12, R10
    531          	const BYTE *s = (const BYTE*)src;
   \   000004   CB0D         MOVA    R13, R11
    532          
    533          #if _WORD_ACCESS == 1
    534          	while (cnt >= sizeof (int)) {
    535          		*(int*)d = *(int*)s;
    536          		d += sizeof (int); s += sizeof (int);
    537          		cnt -= sizeof (int);
    538          	}
    539          #endif
    540          	while (cnt--)
   \                     ??mem_cpy_0:
   \   000006   0F4E         MOV.W   R14, R15
   \   000008   0E4F         MOV.W   R15, R14
   \   00000A   3E53         ADD.W   #0xffff, R14
   \   00000C   0F93         CMP.W   #0x0, R15
   \   00000E   0724         JEQ     ??mem_cpy_1
    541          		*d++ = *s++;
   \   000010   EA4B0000     MOV.B   @R11, 0(R10)
   \   000014   AB000100     ADDA    #0x1, R11
   \   000018   AA000100     ADDA    #0x1, R10
   \   00001C   F43F         JMP     ??mem_cpy_0
    542          }
   \                     ??mem_cpy_1:
   \   00001E   1A16         POPM.A  #0x2, R11
   \   000020   1001         RETA
    543          
    544          /* Fill memory */

   \                                 In  segment CODE, align 2
    545          static
    546          void mem_set (void* dst, int val, UINT cnt) {
   \                     mem_set:
   \   000000   0A14         PUSHM.A #0x1, R10
    547          	BYTE *d = (BYTE*)dst;
   \   000002   CA0C         MOVA    R12, R10
    548          
    549          	while (cnt--)
   \                     ??mem_set_0:
   \   000004   0F4E         MOV.W   R14, R15
   \   000006   0E4F         MOV.W   R15, R14
   \   000008   3E53         ADD.W   #0xffff, R14
   \   00000A   0F93         CMP.W   #0x0, R15
   \   00000C   0524         JEQ     ??mem_set_1
    550          		*d++ = (BYTE)val;
   \   00000E   CA4D0000     MOV.B   R13, 0(R10)
   \   000012   AA000100     ADDA    #0x1, R10
   \   000016   F63F         JMP     ??mem_set_0
    551          }
   \                     ??mem_set_1:
   \   000018   0A16         POPM.A  #0x1, R10
   \   00001A   1001         RETA
    552          
    553          /* Compare memory to memory */

   \                                 In  segment CODE, align 2
    554          static
    555          int mem_cmp (const void* dst, const void* src, UINT cnt) {
   \                     mem_cmp:
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   CA0C         MOVA    R12, R10
    556          	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
   \   000004   CB0A         MOVA    R10, R11
   \   000006   C80D         MOVA    R13, R8
    557          	int r = 0;
   \   000008   0C43         MOV.W   #0x0, R12
    558          
    559          	while (cnt-- && (r = *d++ - *s++) == 0) ;
   \                     ??mem_cmp_0:
   \   00000A   0F4E         MOV.W   R14, R15
   \   00000C   0E4F         MOV.W   R15, R14
   \   00000E   3E53         ADD.W   #0xffff, R14
   \   000010   0F93         CMP.W   #0x0, R15
   \   000012   0B24         JEQ     ??mem_cmp_1
   \   000014   6C4B         MOV.B   @R11, R12
   \   000016   4C4C         MOV.B   R12, R12
   \   000018   6F48         MOV.B   @R8, R15
   \   00001A   4F4F         MOV.B   R15, R15
   \   00001C   0C8F         SUB.W   R15, R12
   \   00001E   A8000100     ADDA    #0x1, R8
   \   000022   AB000100     ADDA    #0x1, R11
   \   000026   0C93         CMP.W   #0x0, R12
   \   000028   F027         JEQ     ??mem_cmp_0
    560          	return r;
   \                     ??mem_cmp_1:
   \   00002A   3816         POPM.A  #0x4, R11
   \   00002C   1001         RETA
    561          }
    562          
    563          /* Check if chr is contained in the string */

   \                                 In  segment CODE, align 2
    564          static
    565          int chk_chr (const char* str, int chr) {
   \                     chk_chr:
   \                     ??chk_chr_0:
    566          	while (*str && *str != chr) str++;
   \   000000   CC930000     CMP.B   #0x0, 0(R12)
   \   000004   0724         JEQ     ??chk_chr_1
   \   000006   6F4C         MOV.B   @R12, R15
   \   000008   4F4F         MOV.B   R15, R15
   \   00000A   0F9D         CMP.W   R13, R15
   \   00000C   0324         JEQ     ??chk_chr_1
   \   00000E   AC000100     ADDA    #0x1, R12
   \   000012   F63F         JMP     ??chk_chr_0
    567          	return *str;
   \                     ??chk_chr_1:
   \   000014   6C4C         MOV.B   @R12, R12
   \   000016   4C4C         MOV.B   R12, R12
   \   000018   1001         RETA
    568          }
    569          
    570          
    571          
    572          /*-----------------------------------------------------------------------*/
    573          /* Request/Release grant to access the volume                            */
    574          /*-----------------------------------------------------------------------*/
    575          #if _FS_REENTRANT
    576          
    577          static
    578          int lock_fs (
    579          	FATFS *fs		/* File system object */
    580          )
    581          {
    582          	return ff_req_grant(fs->sobj);
    583          }
    584          
    585          
    586          static
    587          void unlock_fs (
    588          	FATFS *fs,		/* File system object */
    589          	FRESULT res		/* Result code to be returned */
    590          )
    591          {
    592          	if (fs &&
    593          		res != FR_NOT_ENABLED &&
    594          		res != FR_INVALID_DRIVE &&
    595          		res != FR_INVALID_OBJECT &&
    596          		res != FR_TIMEOUT) {
    597          		ff_rel_grant(fs->sobj);
    598          	}
    599          }
    600          #endif
    601          
    602          
    603          
    604          /*-----------------------------------------------------------------------*/
    605          /* File lock control functions                                           */
    606          /*-----------------------------------------------------------------------*/
    607          #if _FS_LOCK
    608          
    609          static
    610          FRESULT chk_lock (	/* Check if the file can be accessed */
    611          	DIR* dj,		/* Directory object pointing the file to be checked */
    612          	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
    613          )
    614          {
    615          	UINT i, be;
    616          
    617          	/* Search file semaphore table */
    618          	for (i = be = 0; i < _FS_LOCK; i++) {
    619          		if (Files[i].fs) {	/* Existing entry */
    620          			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
    621          				Files[i].clu == dj->sclust &&
    622          				Files[i].idx == dj->index) break;
    623          		} else {			/* Blank entry */
    624          			be++;
    625          		}
    626          	}
    627          	if (i == _FS_LOCK)	/* The file is not opened */
    628          		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
    629          
    630          	/* The file has been opened. Reject any open against writing file and all write mode open */
    631          	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
    632          }
    633          
    634          
    635          static
    636          int enq_lock (void)	/* Check if an entry is available for a new file */
    637          {
    638          	UINT i;
    639          
    640          	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
    641          	return (i == _FS_LOCK) ? 0 : 1;
    642          }
    643          
    644          
    645          static
    646          UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
    647          	DIR* dj,	/* Directory object pointing the file to register or increment */
    648          	int acc		/* Desired access mode (0:Read, !0:Write) */
    649          )
    650          {
    651          	UINT i;
    652          
    653          
    654          	for (i = 0; i < _FS_LOCK; i++) {	/* Find the file */
    655          		if (Files[i].fs == dj->fs &&
    656          			Files[i].clu == dj->sclust &&
    657          			Files[i].idx == dj->index) break;
    658          	}
    659          
    660          	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
    661          		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
    662          		if (i == _FS_LOCK) return 0;	/* No space to register (int err) */
    663          		Files[i].fs = dj->fs;
    664          		Files[i].clu = dj->sclust;
    665          		Files[i].idx = dj->index;
    666          		Files[i].ctr = 0;
    667          	}
    668          
    669          	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
    670          
    671          	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
    672          
    673          	return i + 1;
    674          }
    675          
    676          
    677          static
    678          FRESULT dec_lock (	/* Decrement file open counter */
    679          	UINT i			/* Semaphore index */
    680          )
    681          {
    682          	WORD n;
    683          	FRESULT res;
    684          
    685          
    686          	if (--i < _FS_LOCK) {
    687          		n = Files[i].ctr;
    688          		if (n == 0x100) n = 0;
    689          		if (n) n--;
    690          		Files[i].ctr = n;
    691          		if (!n) Files[i].fs = 0;
    692          		res = FR_OK;
    693          	} else {
    694          		res = FR_INT_ERR;
    695          	}
    696          	return res;
    697          }
    698          
    699          
    700          static
    701          void clear_lock (	/* Clear lock entries of the volume */
    702          	FATFS *fs
    703          )
    704          {
    705          	UINT i;
    706          
    707          	for (i = 0; i < _FS_LOCK; i++) {
    708          		if (Files[i].fs == fs) Files[i].fs = 0;
    709          	}
    710          }
    711          #endif
    712          
    713          
    714          
    715          /*-----------------------------------------------------------------------*/
    716          /* Change window offset                                                  */
    717          /*-----------------------------------------------------------------------*/
    718          

   \                                 In  segment CODE, align 2
    719          static
    720          FRESULT move_window (
   \                     move_window:
    721          	FATFS *fs,		/* File system object */
    722          	DWORD sector	/* Sector number to make appearance in the fs->win[] */
    723          )					/* Move to zero only writes back dirty window */
    724          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   C60C         MOVA    R12, R6
   \   000004   084E         MOV.W   R14, R8
   \   000006   094F         MOV.W   R15, R9
    725          	DWORD wsect;
    726          
    727          
    728          	wsect = fs->winsect;
   \   000008   1A462E00     MOV.W   0x2e(R6), R10
   \   00000C   1B463000     MOV.W   0x30(R6), R11
    729          	if (wsect != sector) {	/* Changed current window */
   \   000010   0A98         CMP.W   R8, R10
   \   000012   0220         JNE     ??move_window_1
   \   000014   0B99         CMP.W   R9, R11
   \   000016   4D24         JEQ     ??move_window_2
    730          #if !_FS_READONLY
    731          		if (fs->wflag) {	/* Write back dirty window if needed */
   \                     ??move_window_1:
   \   000018   C6930400     CMP.B   #0x0, 0x4(R6)
   \   00001C   3324         JEQ     ??move_window_3
    732          			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
   \   00001E   5312         PUSH.B  #0x1
   \   000020   0E4A         MOV.W   R10, R14
   \   000022   0F4B         MOV.W   R11, R15
   \   000024   CD06         MOVA    R6, R13
   \   000026   AD003200     ADDA    #0x32, R13
   \   00002A   5C460100     MOV.B   0x1(R6), R12
   \   00002E   ........     CALLA   #disk_write
   \   000032   2153         ADD.W   #0x2, SP
   \   000034   4C93         CMP.B   #0x0, R12
   \   000036   0224         JEQ     ??move_window_4
    733          				return FR_DISK_ERR;
   \   000038   5C43         MOV.B   #0x1, R12
   \   00003A   3C3C         JMP     ??move_window_5
    734          			fs->wflag = 0;
   \                     ??move_window_4:
   \   00003C   C6430400     MOV.B   #0x0, 0x4(R6)
    735          			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
   \   000040   1E462200     MOV.W   0x22(R6), R14
   \   000044   1F462400     MOV.W   0x24(R6), R15
   \   000048   1E561E00     ADD.W   0x1e(R6), R14
   \   00004C   1F662000     ADDC.W  0x20(R6), R15
   \   000050   0B9F         CMP.W   R15, R11
   \   000052   0328         JNC     ??move_window_6
   \   000054   1720         JNE     ??move_window_3
   \   000056   0A9E         CMP.W   R14, R10
   \   000058   152C         JC      ??move_window_3
    736          				BYTE nf;
    737          				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
   \                     ??move_window_6:
   \   00005A   57460300     MOV.B   0x3(R6), R7
   \                     ??move_window_0:
   \   00005E   6793         CMP.B   #0x2, R7
   \   000060   1128         JNC     ??move_window_3
    738          					wsect += fs->fsize;
   \   000062   1A561E00     ADD.W   0x1e(R6), R10
   \   000066   1B662000     ADDC.W  0x20(R6), R11
    739          					disk_write(fs->drv, fs->win, wsect, 1);
   \   00006A   5312         PUSH.B  #0x1
   \   00006C   0E4A         MOV.W   R10, R14
   \   00006E   0F4B         MOV.W   R11, R15
   \   000070   CD06         MOVA    R6, R13
   \   000072   AD003200     ADDA    #0x32, R13
   \   000076   5C460100     MOV.B   0x1(R6), R12
   \   00007A   ........     CALLA   #disk_write
    740          				}
   \   00007E   7753         ADD.B   #0xff, R7
   \   000080   2153         ADD.W   #0x2, SP
   \   000082   ED3F         JMP     ??move_window_0
    741          			}
    742          		}
    743          #endif
    744          		if (sector) {
   \                     ??move_window_3:
   \   000084   0F48         MOV.W   R8, R15
   \   000086   0FD9         BIS.W   R9, R15
   \   000088   0F93         CMP.W   #0x0, R15
   \   00008A   1324         JEQ     ??move_window_2
    745          			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
   \   00008C   5312         PUSH.B  #0x1
   \   00008E   0E48         MOV.W   R8, R14
   \   000090   0F49         MOV.W   R9, R15
   \   000092   CD06         MOVA    R6, R13
   \   000094   AD003200     ADDA    #0x32, R13
   \   000098   5C460100     MOV.B   0x1(R6), R12
   \   00009C   ........     CALLA   #disk_read
   \   0000A0   2153         ADD.W   #0x2, SP
   \   0000A2   4C93         CMP.B   #0x0, R12
   \   0000A4   0224         JEQ     ??move_window_7
    746          				return FR_DISK_ERR;
   \   0000A6   5C43         MOV.B   #0x1, R12
   \   0000A8   053C         JMP     ??move_window_5
    747          			fs->winsect = sector;
   \                     ??move_window_7:
   \   0000AA   86482E00     MOV.W   R8, 0x2e(R6)
   \   0000AE   86493000     MOV.W   R9, 0x30(R6)
    748          		}
    749          	}
    750          
    751          	return FR_OK;
   \                     ??move_window_2:
   \   0000B2   4C43         MOV.B   #0x0, R12
   \                     ??move_window_5:
   \   0000B4   5616         POPM.A  #0x6, R11
   \   0000B6   1001         RETA
    752          }
    753          
    754          
    755          
    756          
    757          /*-----------------------------------------------------------------------*/
    758          /* Clean-up cached data                                                  */
    759          /*-----------------------------------------------------------------------*/
    760          #if !_FS_READONLY

   \                                 In  segment CODE, align 2
    761          static
    762          FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
   \                     sync:
    763          	FATFS *fs	/* File system object */
    764          )
    765          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   CA0C         MOVA    R12, R10
    766          	FRESULT res;
    767          
    768          
    769          	res = move_window(fs, 0);
   \   000004   0E43         MOV.W   #0x0, R14
   \   000006   0F43         MOV.W   #0x0, R15
   \   000008   CC0A         MOVA    R10, R12
   \   00000A   ........     CALLA   #move_window
   \   00000E   4B4C         MOV.B   R12, R11
    770          	if (res == FR_OK) {
   \   000010   4B93         CMP.B   #0x0, R11
   \   000012   6F20         JNE     ??sync_0
    771          		/* Update FSInfo sector if needed */
    772          		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
   \   000014   FA9003000000 CMP.B   #0x3, 0(R10)
   \   00001A   6220         JNE     ??sync_1
   \   00001C   CA930500     CMP.B   #0x0, 0x5(R10)
   \   000020   5F24         JEQ     ??sync_1
    773          			fs->winsect = 0;
   \   000022   8A432E00     MOV.W   #0x0, 0x2e(R10)
   \   000026   8A433000     MOV.W   #0x0, 0x30(R10)
    774          			/* Create FSInfo structure */
    775          			mem_set(fs->win, 0, 512);
   \   00002A   3E400002     MOV.W   #0x200, R14
   \   00002E   0D43         MOV.W   #0x0, R13
   \   000030   CC0A         MOVA    R10, R12
   \   000032   AC003200     ADDA    #0x32, R12
   \   000036   ........     CALLA   #mem_set
    776          			ST_WORD(fs->win+BS_55AA, 0xAA55);
   \   00003A   FA4055003002 MOV.B   #0x55, 0x230(R10)
   \   000040   FA40AA003102 MOV.B   #0xaa, 0x231(R10)
    777          			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
   \   000046   FA4052003200 MOV.B   #0x52, 0x32(R10)
   \   00004C   FA4052003300 MOV.B   #0x52, 0x33(R10)
   \   000052   FA4061003400 MOV.B   #0x61, 0x34(R10)
   \   000058   FA4041003500 MOV.B   #0x41, 0x35(R10)
    778          			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
   \   00005E   FA4072001602 MOV.B   #0x72, 0x216(R10)
   \   000064   FA4072001702 MOV.B   #0x72, 0x217(R10)
   \   00006A   FA4041001802 MOV.B   #0x41, 0x218(R10)
   \   000070   FA4061001902 MOV.B   #0x61, 0x219(R10)
    779          			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
   \   000076   DA4A0E001A02 MOV.B   0xe(R10), 0x21a(R10)
   \   00007C   DA4A0F001B02 MOV.B   0xf(R10), 0x21b(R10)
   \   000082   1E4A1000     MOV.W   0x10(R10), R14
   \   000086   CA4E1C02     MOV.B   R14, 0x21c(R10)
   \   00008A   1E4A0E00     MOV.W   0xe(R10), R14
   \   00008E   1F4A1000     MOV.W   0x10(R10), R15
   \   000092   8F10         SWPB    R15
   \   000094   4E4F         MOV.B   R15, R14
   \   000096   0F43         MOV.W   #0x0, R15
   \   000098   CA4E1D02     MOV.B   R14, 0x21d(R10)
    780          			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
   \   00009C   DA4A0A001E02 MOV.B   0xa(R10), 0x21e(R10)
   \   0000A2   DA4A0B001F02 MOV.B   0xb(R10), 0x21f(R10)
   \   0000A8   1E4A0C00     MOV.W   0xc(R10), R14
   \   0000AC   CA4E2002     MOV.B   R14, 0x220(R10)
   \   0000B0   1E4A0A00     MOV.W   0xa(R10), R14
   \   0000B4   1F4A0C00     MOV.W   0xc(R10), R15
   \   0000B8   8F10         SWPB    R15
   \   0000BA   4E4F         MOV.B   R15, R14
   \   0000BC   0F43         MOV.W   #0x0, R15
   \   0000BE   CA4E2102     MOV.B   R14, 0x221(R10)
    781          			/* Write it into the FSInfo sector */
    782          			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
   \   0000C2   5312         PUSH.B  #0x1
   \   0000C4   1E4A1200     MOV.W   0x12(R10), R14
   \   0000C8   1F4A1400     MOV.W   0x14(R10), R15
   \   0000CC   CD0A         MOVA    R10, R13
   \   0000CE   AD003200     ADDA    #0x32, R13
   \   0000D2   5C4A0100     MOV.B   0x1(R10), R12
   \   0000D6   ........     CALLA   #disk_write
    783          			fs->fsi_flag = 0;
   \   0000DA   CA430500     MOV.B   #0x0, 0x5(R10)
   \   0000DE   2153         ADD.W   #0x2, SP
    784          		}
    785          		/* Make sure that no pending write process in the physical drive */
    786          		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
   \                     ??sync_1:
   \   0000E0   4E43         MOVA    #0x0, R14
   \   0000E2   4D43         MOV.B   #0x0, R13
   \   0000E4   5C4A0100     MOV.B   0x1(R10), R12
   \   0000E8   ........     CALLA   #disk_ioctl
   \   0000EC   4C93         CMP.B   #0x0, R12
   \   0000EE   0124         JEQ     ??sync_0
    787          			res = FR_DISK_ERR;
   \   0000F0   5B43         MOV.B   #0x1, R11
    788          	}
    789          
    790          	return res;
   \                     ??sync_0:
   \   0000F2   4C4B         MOV.B   R11, R12
   \   0000F4   1A16         POPM.A  #0x2, R11
   \   0000F6   1001         RETA
    791          }
    792          #endif
    793          
    794          
    795          
    796          
    797          /*-----------------------------------------------------------------------*/
    798          /* Get sector# from cluster#                                             */
    799          /*-----------------------------------------------------------------------*/
    800          
    801          

   \                                 In  segment CODE, align 2
    802          DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
   \                     clust2sect:
    803          	FATFS *fs,		/* File system object */
    804          	DWORD clst		/* Cluster# to be converted */
    805          )
    806          {
   \   000000   0A14         PUSHM.A #0x1, R10
   \   000002   CA0C         MOVA    R12, R10
    807          	clst -= 2;
   \   000004   3E50FEFF     ADD.W   #0xfffe, R14
   \   000008   3F63         ADDC.W  #0xffff, R15
    808          	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
   \   00000A   1C4A1A00     MOV.W   0x1a(R10), R12
   \   00000E   1D4A1C00     MOV.W   0x1c(R10), R13
   \   000012   3C50FEFF     ADD.W   #0xfffe, R12
   \   000016   3D63         ADDC.W  #0xffff, R13
   \   000018   0F9D         CMP.W   R13, R15
   \   00001A   0628         JNC     ??clust2sect_0
   \   00001C   0220         JNE     ??clust2sect_1
   \   00001E   0E9C         CMP.W   R12, R14
   \   000020   0328         JNC     ??clust2sect_0
   \                     ??clust2sect_1:
   \   000022   0C43         MOV.W   #0x0, R12
   \   000024   0D43         MOV.W   #0x0, R13
   \   000026   0C3C         JMP     ??clust2sect_2
    809          	return clst * fs->csize + fs->database;
   \                     ??clust2sect_0:
   \   000028   0C4E         MOV.W   R14, R12
   \   00002A   0D4F         MOV.W   R15, R13
   \   00002C   5E4A0200     MOV.B   0x2(R10), R14
   \   000030   4E4E         MOV.B   R14, R14
   \   000032   0F43         MOV.W   #0x0, R15
   \   000034   ........     CALLA   #?Mul32
   \   000038   1C5A2A00     ADD.W   0x2a(R10), R12
   \   00003C   1D6A2C00     ADDC.W  0x2c(R10), R13
   \                     ??clust2sect_2:
   \   000040   0A16         POPM.A  #0x1, R10
   \   000042   1001         RETA
    810          }
    811          
    812          
    813          
    814          
    815          /*-----------------------------------------------------------------------*/
    816          /* FAT access - Read value of a FAT entry                                */
    817          /*-----------------------------------------------------------------------*/
    818          
    819          

   \                                 In  segment CODE, align 2
    820          DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
   \                     get_fat:
    821          	FATFS *fs,	/* File system object */
    822          	DWORD clst	/* Cluster# to get the link information */
    823          )
    824          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   CA0C         MOVA    R12, R10
   \   000004   084E         MOV.W   R14, R8
   \   000006   094F         MOV.W   R15, R9
    825          	UINT wc, bc;
    826          	BYTE *p;
    827          
    828          
    829          	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
   \   000008   0993         CMP.W   #0x0, R9
   \   00000A   0A28         JNC     ??get_fat_0
   \   00000C   0220         JNE     ??get_fat_6
   \   00000E   2893         CMP.W   #0x2, R8
   \   000010   0728         JNC     ??get_fat_0
   \                     ??get_fat_6:
   \   000012   199A1C00     CMP.W   0x1c(R10), R9
   \   000016   0728         JNC     ??get_fat_7
   \   000018   0320         JNE     ??get_fat_0
   \   00001A   189A1A00     CMP.W   0x1a(R10), R8
   \   00001E   0328         JNC     ??get_fat_7
    830          		return 1;
   \                     ??get_fat_0:
   \   000020   1C43         MOV.W   #0x1, R12
   \   000022   0D43         MOV.W   #0x0, R13
   \   000024   BD3C         JMP     ??get_fat_8
    831          
    832          	switch (fs->fs_type) {
   \                     ??get_fat_7:
   \   000026   6E4A         MOV.B   @R10, R14
   \   000028   5E83         SUB.B   #0x1, R14
   \   00002A   0524         JEQ     ??get_fat_9
   \   00002C   5E83         SUB.B   #0x1, R14
   \   00002E   4824         JEQ     ??get_fat_10
   \   000030   5E83         SUB.B   #0x1, R14
   \   000032   7424         JEQ     ??get_fat_11
   \   000034   B33C         JMP     ??get_fat_2
    833          	case FS_FAT12 :
    834          		bc = (UINT)clst; bc += bc / 2;
   \                     ??get_fat_9:
   \   000036   0B48         MOV.W   R8, R11
   \   000038   0F4B         MOV.W   R11, R15
   \   00003A   5F03         RRUM.W  #0x1, R15
   \   00003C   0B5F         ADD.W   R15, R11
    835          		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   \   00003E   0E4B         MOV.W   R11, R14
   \   000040   8E10         SWPB    R14
   \   000042   3EF0FF00     AND.W   #0xff, R14
   \   000046   0E11         RRA.W   R14
   \   000048   0F43         MOV.W   #0x0, R15
   \   00004A   1E5A2200     ADD.W   0x22(R10), R14
   \   00004E   1F6A2400     ADDC.W  0x24(R10), R15
   \   000052   CC0A         MOVA    R10, R12
   \   000054   ........     CALLA   #move_window
   \   000058   4C93         CMP.B   #0x0, R12
   \   00005A   A020         JNE     ??get_fat_2
    836          		wc = fs->win[bc % SS(fs)]; bc++;
   \   00005C   0C4B         MOV.W   R11, R12
   \   00005E   3E400002     MOV.W   #0x200, R14
   \   000062   ........     CALLA   #?DivMod16u
   \   000066   CF0A         MOVA    R10, R15
   \   000068   EF0E         ADDA    R14, R15
   \   00006A   5F4F3200     MOV.B   0x32(R15), R15
   \   00006E   4F4F         MOV.B   R15, R15
   \   000070   074F         MOV.W   R15, R7
   \   000072   1B53         ADD.W   #0x1, R11
    837          		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   \   000074   0E4B         MOV.W   R11, R14
   \   000076   8E10         SWPB    R14
   \   000078   3EF0FF00     AND.W   #0xff, R14
   \   00007C   0E11         RRA.W   R14
   \   00007E   0F43         MOV.W   #0x0, R15
   \   000080   1E5A2200     ADD.W   0x22(R10), R14
   \   000084   1F6A2400     ADDC.W  0x24(R10), R15
   \   000088   CC0A         MOVA    R10, R12
   \   00008A   ........     CALLA   #move_window
   \   00008E   4C93         CMP.B   #0x0, R12
   \   000090   8520         JNE     ??get_fat_2
    838          		wc |= fs->win[bc % SS(fs)] << 8;
   \   000092   0C4B         MOV.W   R11, R12
   \   000094   3E400002     MOV.W   #0x200, R14
   \   000098   ........     CALLA   #?DivMod16u
   \   00009C   CF0A         MOVA    R10, R15
   \   00009E   EF0E         ADDA    R14, R15
   \   0000A0   5F4F3200     MOV.B   0x32(R15), R15
   \   0000A4   4F4F         MOV.B   R15, R15
   \   0000A6   3FF0FF00     AND.W   #0xff, R15
   \   0000AA   8F10         SWPB    R15
   \   0000AC   07DF         BIS.W   R15, R7
    839          		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
   \   0000AE   18B3         BIT.W   #0x1, R8
   \   0000B0   0228         JNC     ??get_fat_12
   \   0000B2   570F         RRUM.W  #0x4, R7
   \   0000B4   023C         JMP     ??get_fat_13
   \                     ??get_fat_12:
   \   0000B6   37F0FF0F     AND.W   #0xfff, R7
   \                     ??get_fat_13:
   \   0000BA   0C47         MOV.W   R7, R12
   \   0000BC   0D43         MOV.W   #0x0, R13
   \   0000BE   703C         JMP     ??get_fat_8
    840          
    841          	case FS_FAT16 :
    842          		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
   \                     ??get_fat_10:
   \   0000C0   0E48         MOV.W   R8, R14
   \   0000C2   0F49         MOV.W   R9, R15
   \   0000C4   8E10         SWPB    R14
   \   0000C6   8F10         SWPB    R15
   \   0000C8   4EEF         XOR.B   R15, R14
   \   0000CA   0EEF         XOR.W   R15, R14
   \   0000CC   3FF0FF00     AND.W   #0xff, R15
   \   0000D0   1E5A2200     ADD.W   0x22(R10), R14
   \   0000D4   1F6A2400     ADDC.W  0x24(R10), R15
   \   0000D8   CC0A         MOVA    R10, R12
   \   0000DA   ........     CALLA   #move_window
   \   0000DE   4C93         CMP.B   #0x0, R12
   \   0000E0   5D20         JNE     ??get_fat_2
    843          		p = &fs->win[clst * 2 % SS(fs)];
   \   0000E2   0C48         MOV.W   R8, R12
   \   0000E4   0D49         MOV.W   R9, R13
   \   0000E6   2E43         MOV.W   #0x2, R14
   \   0000E8   0F43         MOV.W   #0x0, R15
   \   0000EA   ........     CALLA   #?Mul32
   \   0000EE   3E400002     MOV.W   #0x200, R14
   \   0000F2   0F43         MOV.W   #0x0, R15
   \   0000F4   ........     CALLA   #?DivMod32u
   \   0000F8   1F15         PUSHM.W #0x2, R15
   \   0000FA   0F16         POPM.A  #0x1, R15
   \   0000FC   CE0A         MOVA    R10, R14
   \   0000FE   EE0F         ADDA    R15, R14
   \   000100   AE003200     ADDA    #0x32, R14
   \   000104   C60E         MOVA    R14, R6
    844          		return LD_WORD(p);
   \   000106   6F46         MOV.B   @R6, R15
   \   000108   4F4F         MOV.B   R15, R15
   \   00010A   5C460100     MOV.B   0x1(R6), R12
   \   00010E   4C4C         MOV.B   R12, R12
   \   000110   3CF0FF00     AND.W   #0xff, R12
   \   000114   8C10         SWPB    R12
   \   000116   0CDF         BIS.W   R15, R12
   \   000118   0D43         MOV.W   #0x0, R13
   \   00011A   423C         JMP     ??get_fat_8
    845          
    846          	case FS_FAT32 :
    847          		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
   \                     ??get_fat_11:
   \   00011C   0C48         MOV.W   R8, R12
   \   00011E   0D49         MOV.W   R9, R13
   \   000120   ........     CALLA   #?ShiftRight32u_7
   \   000124   0E4C         MOV.W   R12, R14
   \   000126   0F4D         MOV.W   R13, R15
   \   000128   1E5A2200     ADD.W   0x22(R10), R14
   \   00012C   1F6A2400     ADDC.W  0x24(R10), R15
   \   000130   CC0A         MOVA    R10, R12
   \   000132   ........     CALLA   #move_window
   \   000136   4C93         CMP.B   #0x0, R12
   \   000138   3120         JNE     ??get_fat_2
    848          		p = &fs->win[clst * 4 % SS(fs)];
   \   00013A   0C48         MOV.W   R8, R12
   \   00013C   0D49         MOV.W   R9, R13
   \   00013E   2E42         MOV.W   #0x4, R14
   \   000140   0F43         MOV.W   #0x0, R15
   \   000142   ........     CALLA   #?Mul32
   \   000146   3E400002     MOV.W   #0x200, R14
   \   00014A   0F43         MOV.W   #0x0, R15
   \   00014C   ........     CALLA   #?DivMod32u
   \   000150   1F15         PUSHM.W #0x2, R15
   \   000152   0F16         POPM.A  #0x1, R15
   \   000154   CE0A         MOVA    R10, R14
   \   000156   EE0F         ADDA    R15, R14
   \   000158   AE003200     ADDA    #0x32, R14
   \   00015C   C60E         MOVA    R14, R6
    849          		return LD_DWORD(p) & 0x0FFFFFFF;
   \   00015E   6546         MOV.B   @R6, R5
   \   000160   4545         MOV.B   R5, R5
   \   000162   54460100     MOV.B   0x1(R6), R4
   \   000166   4444         MOV.B   R4, R4
   \   000168   34F0FF00     AND.W   #0xff, R4
   \   00016C   8410         SWPB    R4
   \   00016E   5E460200     MOV.B   0x2(R6), R14
   \   000172   4E4E         MOV.B   R14, R14
   \   000174   0F43         MOV.W   #0x0, R15
   \   000176   0F4E         MOV.W   R14, R15
   \   000178   0E43         MOV.W   #0x0, R14
   \   00017A   5C460300     MOV.B   0x3(R6), R12
   \   00017E   4C4C         MOV.B   R12, R12
   \   000180   0D43         MOV.W   #0x0, R13
   \   000182   3CF0FF00     AND.W   #0xff, R12
   \   000186   8C10         SWPB    R12
   \   000188   0D4C         MOV.W   R12, R13
   \   00018A   0C43         MOV.W   #0x0, R12
   \   00018C   0CDE         BIS.W   R14, R12
   \   00018E   0DDF         BIS.W   R15, R13
   \   000190   0CD4         BIS.W   R4, R12
   \   000192   0CD5         BIS.W   R5, R12
   \   000194   3CF3         AND.W   #0xffff, R12
   \   000196   3DF0FF0F     AND.W   #0xfff, R13
   \   00019A   023C         JMP     ??get_fat_8
    850          	}
    851          
    852          	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
   \                     ??get_fat_2:
   \   00019C   3C43         MOV.W   #0xffff, R12
   \   00019E   3D43         MOV.W   #0xffff, R13
   \                     ??get_fat_8:
   \   0001A0   7416         POPM.A  #0x8, R11
   \   0001A2   1001         RETA
    853          }
    854          
    855          
    856          
    857          
    858          /*-----------------------------------------------------------------------*/
    859          /* FAT access - Change value of a FAT entry                              */
    860          /*-----------------------------------------------------------------------*/
    861          #if !_FS_READONLY
    862          

   \                                 In  segment CODE, align 2
    863          FRESULT put_fat (
   \                     put_fat:
    864          	FATFS *fs,	/* File system object */
    865          	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
    866          	DWORD val	/* New value to mark the cluster */
    867          )
    868          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   CA0C         MOVA    R12, R10
   \   000004   084E         MOV.W   R14, R8
   \   000006   094F         MOV.W   R15, R9
   \   000008   14412400     MOV.W   0x24(SP), R4
   \   00000C   15412600     MOV.W   0x26(SP), R5
    869          	UINT bc;
    870          	BYTE *p;
    871          	FRESULT res;
    872          
    873          
    874          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   000010   0993         CMP.W   #0x0, R9
   \   000012   0A28         JNC     ??put_fat_0
   \   000014   0220         JNE     ??put_fat_6
   \   000016   2893         CMP.W   #0x2, R8
   \   000018   0728         JNC     ??put_fat_0
   \                     ??put_fat_6:
   \   00001A   199A1C00     CMP.W   0x1c(R10), R9
   \   00001E   0628         JNC     ??put_fat_7
   \   000020   0320         JNE     ??put_fat_0
   \   000022   189A1A00     CMP.W   0x1a(R10), R8
   \   000026   0228         JNC     ??put_fat_7
    875          		res = FR_INT_ERR;
   \                     ??put_fat_0:
   \   000028   6743         MOV.B   #0x2, R7
   \   00002A   DE3C         JMP     ??put_fat_8
    876          
    877          	} else {
    878          		switch (fs->fs_type) {
   \                     ??put_fat_7:
   \   00002C   6E4A         MOV.B   @R10, R14
   \   00002E   5E83         SUB.B   #0x1, R14
   \   000030   0524         JEQ     ??put_fat_9
   \   000032   5E83         SUB.B   #0x1, R14
   \   000034   6724         JEQ     ??put_fat_10
   \   000036   5E83         SUB.B   #0x1, R14
   \   000038   9224         JEQ     ??put_fat_11
   \   00003A   D33C         JMP     ??put_fat_12
    879          		case FS_FAT12 :
    880          			bc = (UINT)clst; bc += bc / 2;
   \                     ??put_fat_9:
   \   00003C   0648         MOV.W   R8, R6
   \   00003E   0F46         MOV.W   R6, R15
   \   000040   5F03         RRUM.W  #0x1, R15
   \   000042   065F         ADD.W   R15, R6
    881          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   000044   0E46         MOV.W   R6, R14
   \   000046   8E10         SWPB    R14
   \   000048   3EF0FF00     AND.W   #0xff, R14
   \   00004C   0E11         RRA.W   R14
   \   00004E   0F43         MOV.W   #0x0, R15
   \   000050   1E5A2200     ADD.W   0x22(R10), R14
   \   000054   1F6A2400     ADDC.W  0x24(R10), R15
   \   000058   CC0A         MOVA    R10, R12
   \   00005A   ........     CALLA   #move_window
   \   00005E   474C         MOV.B   R12, R7
    882          			if (res != FR_OK) break;
   \   000060   4793         CMP.B   #0x0, R7
   \   000062   C020         JNE     ??put_fat_2
    883          			p = &fs->win[bc % SS(fs)];
   \   000064   0C46         MOV.W   R6, R12
   \   000066   3E400002     MOV.W   #0x200, R14
   \   00006A   ........     CALLA   #?DivMod16u
   \   00006E   CF0A         MOVA    R10, R15
   \   000070   EF0E         ADDA    R14, R15
   \   000072   AF003200     ADDA    #0x32, R15
   \   000076   CB0F         MOVA    R15, R11
    884          			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   \   000078   18B3         BIT.W   #0x1, R8
   \   00007A   0B28         JNC     ??put_fat_13
   \   00007C   0E12         PUSH.W  R14
   \   00007E   C1440000     MOV.B   R4, 0(SP)
   \   000082   3E41         POP.W   R14
   \   000084                RPT     #0x4
   \   000084   43184E5E     RLAX.B  R14
   \   000088   7F400F00     MOV.B   #0xf, R15
   \   00008C   6FFB         AND.B   @R11, R15
   \   00008E   4FDE         BIS.B   R14, R15
   \   000090   043C         JMP     ??put_fat_14
   \                     ??put_fat_13:
   \   000092   0F12         PUSH.W  R15
   \   000094   C1440000     MOV.B   R4, 0(SP)
   \   000098   3F41         POP.W   R15
   \                     ??put_fat_14:
   \   00009A   CB4F0000     MOV.B   R15, 0(R11)
    885          			bc++;
   \   00009E   1653         ADD.W   #0x1, R6
    886          			fs->wflag = 1;
   \   0000A0   DA430400     MOV.B   #0x1, 0x4(R10)
    887          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   0000A4   0E46         MOV.W   R6, R14
   \   0000A6   8E10         SWPB    R14
   \   0000A8   3EF0FF00     AND.W   #0xff, R14
   \   0000AC   0E11         RRA.W   R14
   \   0000AE   0F43         MOV.W   #0x0, R15
   \   0000B0   1E5A2200     ADD.W   0x22(R10), R14
   \   0000B4   1F6A2400     ADDC.W  0x24(R10), R15
   \   0000B8   CC0A         MOVA    R10, R12
   \   0000BA   ........     CALLA   #move_window
   \   0000BE   474C         MOV.B   R12, R7
    888          			if (res != FR_OK) break;
   \   0000C0   4793         CMP.B   #0x0, R7
   \   0000C2   9020         JNE     ??put_fat_2
    889          			p = &fs->win[bc % SS(fs)];
   \   0000C4   0C46         MOV.W   R6, R12
   \   0000C6   3E400002     MOV.W   #0x200, R14
   \   0000CA   ........     CALLA   #?DivMod16u
   \   0000CE   CF0A         MOVA    R10, R15
   \   0000D0   EF0E         ADDA    R14, R15
   \   0000D2   AF003200     ADDA    #0x32, R15
   \   0000D6   CB0F         MOVA    R15, R11
    890          			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   \   0000D8   18B3         BIT.W   #0x1, R8
   \   0000DA   0728         JNC     ??put_fat_15
   \   0000DC   0F44         MOV.W   R4, R15
   \   0000DE   5F0F         RRUM.W  #0x4, R15
   \   0000E0   0E12         PUSH.W  R14
   \   0000E2   C14F0000     MOV.B   R15, 0(SP)
   \   0000E6   3E41         POP.W   R14
   \   0000E8   0A3C         JMP     ??put_fat_16
   \                     ??put_fat_15:
   \   0000EA   0F44         MOV.W   R4, R15
   \   0000EC   8F10         SWPB    R15
   \   0000EE   3FF0FF00     AND.W   #0xff, R15
   \   0000F2   7FF00F00     AND.B   #0xf, R15
   \   0000F6   7E40F000     MOV.B   #0xf0, R14
   \   0000FA   6EFB         AND.B   @R11, R14
   \   0000FC   4EDF         BIS.B   R15, R14
   \                     ??put_fat_16:
   \   0000FE   CB4E0000     MOV.B   R14, 0(R11)
    891          			break;
   \   000102   703C         JMP     ??put_fat_2
    892          
    893          		case FS_FAT16 :
    894          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   \                     ??put_fat_10:
   \   000104   0E48         MOV.W   R8, R14
   \   000106   0F49         MOV.W   R9, R15
   \   000108   8E10         SWPB    R14
   \   00010A   8F10         SWPB    R15
   \   00010C   4EEF         XOR.B   R15, R14
   \   00010E   0EEF         XOR.W   R15, R14
   \   000110   3FF0FF00     AND.W   #0xff, R15
   \   000114   1E5A2200     ADD.W   0x22(R10), R14
   \   000118   1F6A2400     ADDC.W  0x24(R10), R15
   \   00011C   CC0A         MOVA    R10, R12
   \   00011E   ........     CALLA   #move_window
   \   000122   474C         MOV.B   R12, R7
    895          			if (res != FR_OK) break;
   \   000124   4793         CMP.B   #0x0, R7
   \   000126   5E20         JNE     ??put_fat_2
    896          			p = &fs->win[clst * 2 % SS(fs)];
   \   000128   0C48         MOV.W   R8, R12
   \   00012A   0D49         MOV.W   R9, R13
   \   00012C   2E43         MOV.W   #0x2, R14
   \   00012E   0F43         MOV.W   #0x0, R15
   \   000130   ........     CALLA   #?Mul32
   \   000134   3E400002     MOV.W   #0x200, R14
   \   000138   0F43         MOV.W   #0x0, R15
   \   00013A   ........     CALLA   #?DivMod32u
   \   00013E   1F15         PUSHM.W #0x2, R15
   \   000140   0F16         POPM.A  #0x1, R15
   \   000142   CE0A         MOVA    R10, R14
   \   000144   EE0F         ADDA    R15, R14
   \   000146   AE003200     ADDA    #0x32, R14
   \   00014A   CB0E         MOVA    R14, R11
    897          			ST_WORD(p, (WORD)val);
   \   00014C   CB440000     MOV.B   R4, 0(R11)
   \   000150   0F44         MOV.W   R4, R15
   \   000152   8F10         SWPB    R15
   \   000154   3FF0FF00     AND.W   #0xff, R15
   \   000158   CB4F0100     MOV.B   R15, 0x1(R11)
    898          			break;
   \   00015C   433C         JMP     ??put_fat_2
    899          
    900          		case FS_FAT32 :
    901          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   \                     ??put_fat_11:
   \   00015E   0C48         MOV.W   R8, R12
   \   000160   0D49         MOV.W   R9, R13
   \   000162   ........     CALLA   #?ShiftRight32u_7
   \   000166   0E4C         MOV.W   R12, R14
   \   000168   0F4D         MOV.W   R13, R15
   \   00016A   1E5A2200     ADD.W   0x22(R10), R14
   \   00016E   1F6A2400     ADDC.W  0x24(R10), R15
   \   000172   CC0A         MOVA    R10, R12
   \   000174   ........     CALLA   #move_window
   \   000178   474C         MOV.B   R12, R7
    902          			if (res != FR_OK) break;
   \   00017A   4793         CMP.B   #0x0, R7
   \   00017C   3320         JNE     ??put_fat_2
    903          			p = &fs->win[clst * 4 % SS(fs)];
   \   00017E   0C48         MOV.W   R8, R12
   \   000180   0D49         MOV.W   R9, R13
   \   000182   2E42         MOV.W   #0x4, R14
   \   000184   0F43         MOV.W   #0x0, R15
   \   000186   ........     CALLA   #?Mul32
   \   00018A   3E400002     MOV.W   #0x200, R14
   \   00018E   0F43         MOV.W   #0x0, R15
   \   000190   ........     CALLA   #?DivMod32u
   \   000194   1F15         PUSHM.W #0x2, R15
   \   000196   0F16         POPM.A  #0x1, R15
   \   000198   CE0A         MOVA    R10, R14
   \   00019A   EE0F         ADDA    R15, R14
   \   00019C   AE003200     ADDA    #0x32, R14
   \   0001A0   CB0E         MOVA    R14, R11
    904          			val |= LD_DWORD(p) & 0xF0000000;
   \   0001A2   5E4B0300     MOV.B   0x3(R11), R14
   \   0001A6   4E4E         MOV.B   R14, R14
   \   0001A8   0F43         MOV.W   #0x0, R15
   \   0001AA   3EF0FF00     AND.W   #0xff, R14
   \   0001AE   8E10         SWPB    R14
   \   0001B0   0F4E         MOV.W   R14, R15
   \   0001B2   0E43         MOV.W   #0x0, R14
   \   0001B4   0EF3         AND.W   #0x0, R14
   \   0001B6   3FF000F0     AND.W   #0xf000, R15
   \   0001BA   04DE         BIS.W   R14, R4
   \   0001BC   05DF         BIS.W   R15, R5
    905          			ST_DWORD(p, val);
   \   0001BE   CB440000     MOV.B   R4, 0(R11)
   \   0001C2   0F44         MOV.W   R4, R15
   \   0001C4   8F10         SWPB    R15
   \   0001C6   3FF0FF00     AND.W   #0xff, R15
   \   0001CA   CB4F0100     MOV.B   R15, 0x1(R11)
   \   0001CE   CB450200     MOV.B   R5, 0x2(R11)
   \   0001D2   0E44         MOV.W   R4, R14
   \   0001D4   0F45         MOV.W   R5, R15
   \   0001D6   8F10         SWPB    R15
   \   0001D8   4E4F         MOV.B   R15, R14
   \   0001DA   0F43         MOV.W   #0x0, R15
   \   0001DC   CB4E0300     MOV.B   R14, 0x3(R11)
    906          			break;
   \   0001E0   013C         JMP     ??put_fat_2
    907          
    908          		default :
    909          			res = FR_INT_ERR;
   \                     ??put_fat_12:
   \   0001E2   6743         MOV.B   #0x2, R7
    910          		}
    911          		fs->wflag = 1;
   \                     ??put_fat_2:
   \   0001E4   DA430400     MOV.B   #0x1, 0x4(R10)
    912          	}
    913          
    914          	return res;
   \                     ??put_fat_8:
   \   0001E8   4C47         MOV.B   R7, R12
   \   0001EA   7416         POPM.A  #0x8, R11
   \   0001EC   1001         RETA
    915          }
    916          #endif /* !_FS_READONLY */
    917          
    918          
    919          
    920          
    921          /*-----------------------------------------------------------------------*/
    922          /* FAT handling - Remove a cluster chain                                 */
    923          /*-----------------------------------------------------------------------*/
    924          #if !_FS_READONLY

   \                                 In  segment CODE, align 2
    925          static
    926          FRESULT remove_chain (
   \                     remove_chain:
    927          	FATFS *fs,			/* File system object */
    928          	DWORD clst			/* Cluster# to remove a chain from */
    929          )
    930          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   C80C         MOVA    R12, R8
   \   000004   0A4E         MOV.W   R14, R10
   \   000006   0B4F         MOV.W   R15, R11
    931          	FRESULT res;
    932          	DWORD nxt;
    933          #if _USE_ERASE
    934          	DWORD scl = clst, ecl = clst, rt[2];
    935          #endif
    936          
    937          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   000008   0B93         CMP.W   #0x0, R11
   \   00000A   0A28         JNC     ??remove_chain_1
   \   00000C   0220         JNE     ??remove_chain_5
   \   00000E   2A93         CMP.W   #0x2, R10
   \   000010   0728         JNC     ??remove_chain_1
   \                     ??remove_chain_5:
   \   000012   1B981C00     CMP.W   0x1c(R8), R11
   \   000016   0628         JNC     ??remove_chain_6
   \   000018   0320         JNE     ??remove_chain_1
   \   00001A   1A981A00     CMP.W   0x1a(R8), R10
   \   00001E   0228         JNC     ??remove_chain_6
    938          		res = FR_INT_ERR;
   \                     ??remove_chain_1:
   \   000020   6943         MOV.B   #0x2, R9
   \   000022   393C         JMP     ??remove_chain_3
    939          
    940          	} else {
    941          		res = FR_OK;
   \                     ??remove_chain_6:
   \   000024   4943         MOV.B   #0x0, R9
    942          		while (clst < fs->n_fatent) {			/* Not a last link? */
   \                     ??remove_chain_0:
   \   000026   1B981C00     CMP.W   0x1c(R8), R11
   \   00002A   0428         JNC     ??remove_chain_7
   \   00002C   3420         JNE     ??remove_chain_3
   \   00002E   1A981A00     CMP.W   0x1a(R8), R10
   \   000032   312C         JC      ??remove_chain_3
    943          			nxt = get_fat(fs, clst);			/* Get cluster status */
   \                     ??remove_chain_7:
   \   000034   0E4A         MOV.W   R10, R14
   \   000036   0F4B         MOV.W   R11, R15
   \   000038   CC08         MOVA    R8, R12
   \   00003A   ........     CALLA   #get_fat
   \   00003E   064C         MOV.W   R12, R6
   \   000040   074D         MOV.W   R13, R7
    944          			if (nxt == 0) break;				/* Empty cluster? */
   \   000042   0F46         MOV.W   R6, R15
   \   000044   0FD7         BIS.W   R7, R15
   \   000046   0F93         CMP.W   #0x0, R15
   \   000048   2624         JEQ     ??remove_chain_3
    945          			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
   \   00004A   1693         CMP.W   #0x1, R6
   \   00004C   0420         JNE     ??remove_chain_8
   \   00004E   0793         CMP.W   #0x0, R7
   \   000050   0220         JNE     ??remove_chain_8
   \   000052   6943         MOV.B   #0x2, R9
   \   000054   203C         JMP     ??remove_chain_3
    946          			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
   \                     ??remove_chain_8:
   \   000056   3693         CMP.W   #0xffff, R6
   \   000058   0420         JNE     ??remove_chain_9
   \   00005A   3793         CMP.W   #0xffff, R7
   \   00005C   0220         JNE     ??remove_chain_9
   \   00005E   5943         MOV.B   #0x1, R9
   \   000060   1A3C         JMP     ??remove_chain_3
    947          			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
   \                     ??remove_chain_9:
   \   000062   0312         PUSH.W  #0x0
   \   000064   0312         PUSH.W  #0x0
   \   000066   0E4A         MOV.W   R10, R14
   \   000068   0F4B         MOV.W   R11, R15
   \   00006A   CC08         MOVA    R8, R12
   \   00006C   ........     CALLA   #put_fat
   \   000070   494C         MOV.B   R12, R9
    948          			if (res != FR_OK) break;
   \   000072   2152         ADD.W   #0x4, SP
   \   000074   4993         CMP.B   #0x0, R9
   \   000076   0F20         JNE     ??remove_chain_3
    949          			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
   \   000078   B8930E00     CMP.W   #0xffff, 0xe(R8)
   \   00007C   0320         JNE     ??remove_chain_10
   \   00007E   B8931000     CMP.W   #0xffff, 0x10(R8)
   \   000082   0624         JEQ     ??remove_chain_11
    950          				fs->free_clust++;
   \                     ??remove_chain_10:
   \   000084   98530E00     ADD.W   #0x1, 0xe(R8)
   \   000088   88631000     ADDC.W  #0x0, 0x10(R8)
    951          				fs->fsi_flag = 1;
   \   00008C   D8430500     MOV.B   #0x1, 0x5(R8)
    952          			}
    953          #if _USE_ERASE
    954          			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
    955          				ecl = nxt;
    956          			} else {				/* End of contiguous clusters */ 
    957          				rt[0] = clust2sect(fs, scl);					/* Start sector */
    958          				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
    959          				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, rt);		/* Erase the block */
    960          				scl = ecl = nxt;
    961          			}
    962          #endif
    963          			clst = nxt;	/* Next cluster */
   \                     ??remove_chain_11:
   \   000090   0A46         MOV.W   R6, R10
   \   000092   0B47         MOV.W   R7, R11
   \   000094   C83F         JMP     ??remove_chain_0
    964          		}
    965          	}
    966          
    967          	return res;
   \                     ??remove_chain_3:
   \   000096   4C49         MOV.B   R9, R12
   \   000098   5616         POPM.A  #0x6, R11
   \   00009A   1001         RETA
    968          }
    969          #endif
    970          
    971          
    972          
    973          
    974          /*-----------------------------------------------------------------------*/
    975          /* FAT handling - Stretch or Create a cluster chain                      */
    976          /*-----------------------------------------------------------------------*/
    977          #if !_FS_READONLY

   \                                 In  segment CODE, align 2
    978          static
    979          DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
   \                     create_chain:
    980          	FATFS *fs,			/* File system object */
    981          	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
    982          )
    983          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   0F12         PUSH.W  R15
   \   000004   0E12         PUSH.W  R14
   \   000006   C80C         MOVA    R12, R8
    984          	DWORD cs, ncl, scl;
    985          	FRESULT res;
    986          
    987          
    988          	if (clst == 0) {		/* Create a new chain */
   \   000008   2F41         MOV.W   @SP, R15
   \   00000A   1FD10200     BIS.W   0x2(SP), R15
   \   00000E   0F93         CMP.W   #0x0, R15
   \   000010   1220         JNE     ??create_chain_3
    989          		scl = fs->last_clust;			/* Get suggested start point */
   \   000012   14480A00     MOV.W   0xa(R8), R4
   \   000016   15480C00     MOV.W   0xc(R8), R5
    990          		if (!scl || scl >= fs->n_fatent) scl = 1;
   \   00001A   0F44         MOV.W   R4, R15
   \   00001C   0FD5         BIS.W   R5, R15
   \   00001E   0F93         CMP.W   #0x0, R15
   \   000020   0724         JEQ     ??create_chain_1
   \   000022   15981C00     CMP.W   0x1c(R8), R5
   \   000026   2428         JNC     ??create_chain_4
   \   000028   0320         JNE     ??create_chain_1
   \   00002A   14981A00     CMP.W   0x1a(R8), R4
   \   00002E   2028         JNC     ??create_chain_4
   \                     ??create_chain_1:
   \   000030   1443         MOV.W   #0x1, R4
   \   000032   0543         MOV.W   #0x0, R5
   \   000034   1D3C         JMP     ??create_chain_4
    991          	}
    992          	else {					/* Stretch the current chain */
    993          		cs = get_fat(fs, clst);			/* Check the cluster status */
   \                     ??create_chain_3:
   \   000036   2E41         MOV.W   @SP, R14
   \   000038   1F410200     MOV.W   0x2(SP), R15
   \   00003C   CC08         MOVA    R8, R12
   \   00003E   ........     CALLA   #get_fat
   \   000042   064C         MOV.W   R12, R6
   \   000044   074D         MOV.W   R13, R7
    994          		if (cs < 2) return 1;			/* It is an invalid cluster */
   \   000046   0793         CMP.W   #0x0, R7
   \   000048   0328         JNC     ??create_chain_5
   \   00004A   0520         JNE     ??create_chain_6
   \   00004C   2693         CMP.W   #0x2, R6
   \   00004E   032C         JC      ??create_chain_6
   \                     ??create_chain_5:
   \   000050   1C43         MOV.W   #0x1, R12
   \   000052   0D43         MOV.W   #0x0, R13
   \   000054   783C         JMP     ??create_chain_7
    995          		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
   \                     ??create_chain_6:
   \   000056   17981C00     CMP.W   0x1c(R8), R7
   \   00005A   0428         JNC     ??create_chain_8
   \   00005C   0620         JNE     ??create_chain_9
   \   00005E   16981A00     CMP.W   0x1a(R8), R6
   \   000062   032C         JC      ??create_chain_9
   \                     ??create_chain_8:
   \   000064   0C46         MOV.W   R6, R12
   \   000066   0D47         MOV.W   R7, R13
   \   000068   6E3C         JMP     ??create_chain_7
    996          		scl = clst;
   \                     ??create_chain_9:
   \   00006A   2441         MOV.W   @SP, R4
   \   00006C   15410200     MOV.W   0x2(SP), R5
    997          	}
    998          
    999          	ncl = scl;				/* Start cluster */
   \                     ??create_chain_4:
   \   000070   0A44         MOV.W   R4, R10
   \   000072   0B45         MOV.W   R5, R11
   1000          	for (;;) {
   1001          		ncl++;							/* Next cluster */
   \                     ??create_chain_0:
   \   000074   1A53         ADD.W   #0x1, R10
   \   000076   0B63         ADDC.W  #0x0, R11
   1002          		if (ncl >= fs->n_fatent) {		/* Wrap around */
   \   000078   1B981C00     CMP.W   0x1c(R8), R11
   \   00007C   0E28         JNC     ??create_chain_10
   \   00007E   0320         JNE     ??create_chain_11
   \   000080   1A981A00     CMP.W   0x1a(R8), R10
   \   000084   0A28         JNC     ??create_chain_10
   1003          			ncl = 2;
   \                     ??create_chain_11:
   \   000086   2A43         MOV.W   #0x2, R10
   \   000088   0B43         MOV.W   #0x0, R11
   1004          			if (ncl > scl) return 0;	/* No free cluster */
   \   00008A   059B         CMP.W   R11, R5
   \   00008C   0328         JNC     ??create_chain_12
   \   00008E   0520         JNE     ??create_chain_10
   \   000090   049A         CMP.W   R10, R4
   \   000092   032C         JC      ??create_chain_10
   \                     ??create_chain_12:
   \   000094   0C43         MOV.W   #0x0, R12
   \   000096   0D43         MOV.W   #0x0, R13
   \   000098   563C         JMP     ??create_chain_7
   1005          		}
   1006          		cs = get_fat(fs, ncl);			/* Get the cluster status */
   \                     ??create_chain_10:
   \   00009A   0E4A         MOV.W   R10, R14
   \   00009C   0F4B         MOV.W   R11, R15
   \   00009E   CC08         MOVA    R8, R12
   \   0000A0   ........     CALLA   #get_fat
   \   0000A4   064C         MOV.W   R12, R6
   \   0000A6   074D         MOV.W   R13, R7
   1007          		if (cs == 0) break;				/* Found a free cluster */
   \   0000A8   0F46         MOV.W   R6, R15
   \   0000AA   0FD7         BIS.W   R7, R15
   \   0000AC   0F93         CMP.W   #0x0, R15
   \   0000AE   0D20         JNE     ??create_chain_13
   1008          		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
   1009          			return cs;
   1010          		if (ncl == scl) return 0;		/* No free cluster */
   1011          	}
   1012          
   1013          	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
   \   0000B0   3012FF0F     PUSH.W  #0xfff
   \   0000B4   3312         PUSH.W  #0xffff
   \   0000B6   0E4A         MOV.W   R10, R14
   \   0000B8   0F4B         MOV.W   R11, R15
   \   0000BA   CC08         MOVA    R8, R12
   \   0000BC   ........     CALLA   #put_fat
   \   0000C0   494C         MOV.B   R12, R9
   1014          	if (res == FR_OK && clst != 0) {
   \   0000C2   2152         ADD.W   #0x4, SP
   \   0000C4   4993         CMP.B   #0x0, R9
   \   0000C6   2320         JNE     ??create_chain_14
   \   0000C8   123C         JMP     ??create_chain_15
   \                     ??create_chain_13:
   \   0000CA   3693         CMP.W   #0xffff, R6
   \   0000CC   0220         JNE     ??create_chain_16
   \   0000CE   3793         CMP.W   #0xffff, R7
   \   0000D0   0424         JEQ     ??create_chain_2
   \                     ??create_chain_16:
   \   0000D2   1693         CMP.W   #0x1, R6
   \   0000D4   0520         JNE     ??create_chain_17
   \   0000D6   0793         CMP.W   #0x0, R7
   \   0000D8   0320         JNE     ??create_chain_17
   \                     ??create_chain_2:
   \   0000DA   0C46         MOV.W   R6, R12
   \   0000DC   0D47         MOV.W   R7, R13
   \   0000DE   333C         JMP     ??create_chain_7
   \                     ??create_chain_17:
   \   0000E0   0A94         CMP.W   R4, R10
   \   0000E2   C823         JNE     ??create_chain_0
   \   0000E4   0B95         CMP.W   R5, R11
   \   0000E6   C623         JNE     ??create_chain_0
   \   0000E8   0C43         MOV.W   #0x0, R12
   \   0000EA   0D43         MOV.W   #0x0, R13
   \   0000EC   2C3C         JMP     ??create_chain_7
   \                     ??create_chain_15:
   \   0000EE   2F41         MOV.W   @SP, R15
   \   0000F0   1FD10200     BIS.W   0x2(SP), R15
   \   0000F4   0F93         CMP.W   #0x0, R15
   \   0000F6   0B24         JEQ     ??create_chain_14
   1015          		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
   \   0000F8   0B12         PUSH.W  R11
   \   0000FA   0A12         PUSH.W  R10
   \   0000FC   1E410400     MOV.W   0x4(SP), R14
   \   000100   1F410600     MOV.W   0x6(SP), R15
   \   000104   CC08         MOVA    R8, R12
   \   000106   ........     CALLA   #put_fat
   \   00010A   494C         MOV.B   R12, R9
   \   00010C   2152         ADD.W   #0x4, SP
   1016          	}
   1017          	if (res == FR_OK) {
   \                     ??create_chain_14:
   \   00010E   4993         CMP.B   #0x0, R9
   \   000110   1120         JNE     ??create_chain_18
   1018          		fs->last_clust = ncl;			/* Update FSINFO */
   \   000112   884A0A00     MOV.W   R10, 0xa(R8)
   \   000116   884B0C00     MOV.W   R11, 0xc(R8)
   1019          		if (fs->free_clust != 0xFFFFFFFF) {
   \   00011A   B8930E00     CMP.W   #0xffff, 0xe(R8)
   \   00011E   0320         JNE     ??create_chain_19
   \   000120   B8931000     CMP.W   #0xffff, 0x10(R8)
   \   000124   0E24         JEQ     ??create_chain_20
   1020          			fs->free_clust--;
   \                     ??create_chain_19:
   \   000126   B8530E00     ADD.W   #0xffff, 0xe(R8)
   \   00012A   B8631000     ADDC.W  #0xffff, 0x10(R8)
   1021          			fs->fsi_flag = 1;
   \   00012E   D8430500     MOV.B   #0x1, 0x5(R8)
   \   000132   073C         JMP     ??create_chain_20
   1022          		}
   1023          	} else {
   1024          		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   \                     ??create_chain_18:
   \   000134   5993         CMP.B   #0x1, R9
   \   000136   0320         JNE     ??create_chain_21
   \   000138   3A43         MOV.W   #0xffff, R10
   \   00013A   3B43         MOV.W   #0xffff, R11
   \   00013C   023C         JMP     ??create_chain_20
   \                     ??create_chain_21:
   \   00013E   1A43         MOV.W   #0x1, R10
   \   000140   0B43         MOV.W   #0x0, R11
   1025          	}
   1026          
   1027          	return ncl;		/* Return new cluster number or error code */
   \                     ??create_chain_20:
   \   000142   0C4A         MOV.W   R10, R12
   \   000144   0D4B         MOV.W   R11, R13
   \                     ??create_chain_7:
   \   000146   2152         ADD.W   #0x4, SP
   \   000148   7416         POPM.A  #0x8, R11
   \   00014A   1001         RETA
   1028          }
   1029          #endif /* !_FS_READONLY */
   1030          
   1031          
   1032          
   1033          /*-----------------------------------------------------------------------*/
   1034          /* FAT handling - Convert offset into cluster with link map table        */
   1035          /*-----------------------------------------------------------------------*/
   1036          
   1037          #if _USE_FASTSEEK

   \                                 In  segment CODE, align 2
   1038          static
   1039          DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
   \                     clmt_clust:
   1040          	FIL* fp,		/* Pointer to the file object */
   1041          	DWORD ofs		/* File offset to be converted to cluster# */
   1042          )
   1043          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   C40C         MOVA    R12, R4
   \   000004   0A4E         MOV.W   R14, R10
   \   000006   0B4F         MOV.W   R15, R11
   1044          	DWORD cl, ncl, *tbl;
   1045          
   1046          
   1047          	tbl = fp->cltbl + 1;	/* Top of CLMT */
   \   000008   3F042400     MOVA    0x24(R4), R15
   \   00000C   AF000400     ADDA    #0x4, R15
   \   000010   C50F         MOVA    R15, R5
   1048          	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
   \   000012   0C4A         MOV.W   R10, R12
   \   000014   0D4B         MOV.W   R11, R13
   \   000016   ........     CALLA   #?ShiftRight32u_9
   \   00001A   0F04         MOVA    @R4, R15
   \   00001C   5E4F0200     MOV.B   0x2(R15), R14
   \   000020   4E4E         MOV.B   R14, R14
   \   000022   0F43         MOV.W   #0x0, R15
   \   000024   ........     CALLA   #?DivMod32u
   \   000028   084C         MOV.W   R12, R8
   \   00002A   094D         MOV.W   R13, R9
   1049          	for (;;) {
   1050          		ncl = *tbl++;			/* Number of cluters in the fragment */
   \                     ??clmt_clust_0:
   \   00002C   2645         MOV.W   @R5, R6
   \   00002E   17450200     MOV.W   0x2(R5), R7
   \   000032   A5000400     ADDA    #0x4, R5
   1051          		if (!ncl) return 0;		/* End of table? (error) */
   \   000036   0F46         MOV.W   R6, R15
   \   000038   0FD7         BIS.W   R7, R15
   \   00003A   0F93         CMP.W   #0x0, R15
   \   00003C   0320         JNE     ??clmt_clust_1
   \   00003E   0C43         MOV.W   #0x0, R12
   \   000040   0D43         MOV.W   #0x0, R13
   \   000042   0F3C         JMP     ??clmt_clust_2
   1052          		if (cl < ncl) break;	/* In this fragment? */
   \                     ??clmt_clust_1:
   \   000044   0997         CMP.W   R7, R9
   \   000046   0328         JNC     ??clmt_clust_3
   \   000048   0720         JNE     ??clmt_clust_4
   \   00004A   0896         CMP.W   R6, R8
   \   00004C   052C         JC      ??clmt_clust_4
   1053          		cl -= ncl; tbl++;		/* Next fragment */
   1054          	}
   1055          	return cl + *tbl;	/* Return the cluster number */
   \                     ??clmt_clust_3:
   \   00004E   3855         ADD.W   @R5+, R8
   \   000050   3965         ADDC.W  @R5+, R9
   \   000052   0C48         MOV.W   R8, R12
   \   000054   0D49         MOV.W   R9, R13
   \   000056   053C         JMP     ??clmt_clust_2
   \                     ??clmt_clust_4:
   \   000058   0886         SUB.W   R6, R8
   \   00005A   0977         SUBC.W  R7, R9
   \   00005C   A5000400     ADDA    #0x4, R5
   \   000060   E53F         JMP     ??clmt_clust_0
   \                     ??clmt_clust_2:
   \   000062   7416         POPM.A  #0x8, R11
   \   000064   1001         RETA
   1056          }
   1057          #endif	/* _USE_FASTSEEK */
   1058          
   1059          
   1060          
   1061          /*-----------------------------------------------------------------------*/
   1062          /* Directory handling - Set directory index                              */
   1063          /*-----------------------------------------------------------------------*/
   1064          

   \                                 In  segment CODE, align 2
   1065          static
   1066          FRESULT dir_sdi (
   \                     dir_sdi:
   1067          	DIR *dj,		/* Pointer to directory object */
   1068          	WORD idx		/* Index of directory table */
   1069          )
   1070          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   C80C         MOVA    R12, R8
   \   000004   094D         MOV.W   R13, R9
   1071          	DWORD clst;
   1072          	WORD ic;
   1073          
   1074          
   1075          	dj->index = idx;
   \   000006   88490600     MOV.W   R9, 0x6(R8)
   1076          	clst = dj->sclust;
   \   00000A   1A480800     MOV.W   0x8(R8), R10
   \   00000E   1B480A00     MOV.W   0xa(R8), R11
   1077          	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
   \   000012   1A93         CMP.W   #0x1, R10
   \   000014   0220         JNE     ??dir_sdi_3
   \   000016   0B93         CMP.W   #0x0, R11
   \   000018   0824         JEQ     ??dir_sdi_1
   \                     ??dir_sdi_3:
   \   00001A   0F08         MOVA    @R8, R15
   \   00001C   1B9F1C00     CMP.W   0x1c(R15), R11
   \   000020   0628         JNC     ??dir_sdi_4
   \   000022   0320         JNE     ??dir_sdi_1
   \   000024   1A9F1A00     CMP.W   0x1a(R15), R10
   \   000028   0228         JNC     ??dir_sdi_4
   1078          		return FR_INT_ERR;
   \                     ??dir_sdi_1:
   \   00002A   6C43         MOV.B   #0x2, R12
   \   00002C   6F3C         JMP     ??dir_sdi_5
   1079          	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
   \                     ??dir_sdi_4:
   \   00002E   0F4A         MOV.W   R10, R15
   \   000030   0FDB         BIS.W   R11, R15
   \   000032   0F93         CMP.W   #0x0, R15
   \   000034   0A20         JNE     ??dir_sdi_6
   \   000036   0F08         MOVA    @R8, R15
   \   000038   FF9003000000 CMP.B   #0x3, 0(R15)
   \   00003E   0520         JNE     ??dir_sdi_6
   1080          		clst = dj->fs->dirbase;
   \   000040   0F08         MOVA    @R8, R15
   \   000042   1A4F2600     MOV.W   0x26(R15), R10
   \   000046   1B4F2800     MOV.W   0x28(R15), R11
   1081          
   1082          	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
   \                     ??dir_sdi_6:
   \   00004A   0F4A         MOV.W   R10, R15
   \   00004C   0FDB         BIS.W   R11, R15
   \   00004E   0F93         CMP.W   #0x0, R15
   \   000050   1720         JNE     ??dir_sdi_7
   1083          		dj->clust = clst;
   \   000052   884A0C00     MOV.W   R10, 0xc(R8)
   \   000056   884B0E00     MOV.W   R11, 0xe(R8)
   1084          		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
   \   00005A   0F08         MOVA    @R8, R15
   \   00005C   199F0800     CMP.W   0x8(R15), R9
   \   000060   0228         JNC     ??dir_sdi_8
   1085          			return FR_INT_ERR;
   \   000062   6C43         MOV.B   #0x2, R12
   \   000064   533C         JMP     ??dir_sdi_5
   1086          		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   \                     ??dir_sdi_8:
   \   000066   0D08         MOVA    @R8, R13
   \   000068   0E49         MOV.W   R9, R14
   \   00006A   5E0F         RRUM.W  #0x4, R14
   \   00006C   0F43         MOV.W   #0x0, R15
   \   00006E   1E5D2600     ADD.W   0x26(R13), R14
   \   000072   1F6D2800     ADDC.W  0x28(R13), R15
   \   000076   884E1000     MOV.W   R14, 0x10(R8)
   \   00007A   884F1200     MOV.W   R15, 0x12(R8)
   \   00007E   383C         JMP     ??dir_sdi_9
   1087          	}
   1088          	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
   1089          		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
   \                     ??dir_sdi_7:
   \   000080   0F08         MOVA    @R8, R15
   \   000082   5F4F0200     MOV.B   0x2(R15), R15
   \   000086   4F4F         MOV.B   R15, R15
   \   000088   5F0E         RLAM.W  #0x4, R15
   \   00008A   064F         MOV.W   R15, R6
   1090          		while (idx >= ic) {	/* Follow cluster chain */
   \                     ??dir_sdi_0:
   \   00008C   0996         CMP.W   R6, R9
   \   00008E   1E28         JNC     ??dir_sdi_10
   1091          			clst = get_fat(dj->fs, clst);				/* Get next cluster */
   \   000090   0E4A         MOV.W   R10, R14
   \   000092   0F4B         MOV.W   R11, R15
   \   000094   0C08         MOVA    @R8, R12
   \   000096   ........     CALLA   #get_fat
   \   00009A   0A4C         MOV.W   R12, R10
   \   00009C   0B4D         MOV.W   R13, R11
   1092          			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   \   00009E   3A93         CMP.W   #0xffff, R10
   \   0000A0   0420         JNE     ??dir_sdi_11
   \   0000A2   3B93         CMP.W   #0xffff, R11
   \   0000A4   0220         JNE     ??dir_sdi_11
   \   0000A6   5C43         MOV.B   #0x1, R12
   \   0000A8   313C         JMP     ??dir_sdi_5
   1093          			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
   \                     ??dir_sdi_11:
   \   0000AA   0B93         CMP.W   #0x0, R11
   \   0000AC   0B28         JNC     ??dir_sdi_2
   \   0000AE   0220         JNE     ??dir_sdi_12
   \   0000B0   2A93         CMP.W   #0x2, R10
   \   0000B2   0828         JNC     ??dir_sdi_2
   \                     ??dir_sdi_12:
   \   0000B4   0F08         MOVA    @R8, R15
   \   0000B6   1B9F1C00     CMP.W   0x1c(R15), R11
   \   0000BA   0628         JNC     ??dir_sdi_13
   \   0000BC   0320         JNE     ??dir_sdi_2
   \   0000BE   1A9F1A00     CMP.W   0x1a(R15), R10
   \   0000C2   0228         JNC     ??dir_sdi_13
   1094          				return FR_INT_ERR;
   \                     ??dir_sdi_2:
   \   0000C4   6C43         MOV.B   #0x2, R12
   \   0000C6   223C         JMP     ??dir_sdi_5
   1095          			idx -= ic;
   \                     ??dir_sdi_13:
   \   0000C8   0986         SUB.W   R6, R9
   \   0000CA   E03F         JMP     ??dir_sdi_0
   1096          		}
   1097          		dj->clust = clst;
   \                     ??dir_sdi_10:
   \   0000CC   884A0C00     MOV.W   R10, 0xc(R8)
   \   0000D0   884B0E00     MOV.W   R11, 0xe(R8)
   1098          		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   \   0000D4   0E4A         MOV.W   R10, R14
   \   0000D6   0F4B         MOV.W   R11, R15
   \   0000D8   0C08         MOVA    @R8, R12
   \   0000DA   ........     CALLA   #clust2sect
   \   0000DE   0E49         MOV.W   R9, R14
   \   0000E0   5E0F         RRUM.W  #0x4, R14
   \   0000E2   0F43         MOV.W   #0x0, R15
   \   0000E4   0C5E         ADD.W   R14, R12
   \   0000E6   0D6F         ADDC.W  R15, R13
   \   0000E8   884C1000     MOV.W   R12, 0x10(R8)
   \   0000EC   884D1200     MOV.W   R13, 0x12(R8)
   1099          	}
   1100          
   1101          	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
   \                     ??dir_sdi_9:
   \   0000F0   0708         MOVA    @R8, R7
   \   0000F2   0C49         MOV.W   R9, R12
   \   0000F4   3E401000     MOV.W   #0x10, R14
   \   0000F8   ........     CALLA   #?DivMod16u
   \   0000FC                RPT     #0x5
   \   0000FC   44180E5E     RLAX.W  R14
   \   000100   E70E         ADDA    R14, R7
   \   000102   A7003200     ADDA    #0x32, R7
   \   000106   78071400     MOVA    R7, 0x14(R8)
   1102          
   1103          	return FR_OK;	/* Seek succeeded */
   \   00010A   4C43         MOV.B   #0x0, R12
   \                     ??dir_sdi_5:
   \   00010C   5616         POPM.A  #0x6, R11
   \   00010E   1001         RETA
   1104          }
   1105          
   1106          
   1107          
   1108          
   1109          /*-----------------------------------------------------------------------*/
   1110          /* Directory handling - Move directory table index next                  */
   1111          /*-----------------------------------------------------------------------*/
   1112          

   \                                 In  segment CODE, align 2
   1113          static
   1114          FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
   \                     dir_next:
   1115          	DIR *dj,		/* Pointer to directory object */
   1116          	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
   1117          )
   1118          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   CA0C         MOVA    R12, R10
   \   000004   074D         MOV.W   R13, R7
   1119          	DWORD clst;
   1120          	WORD i;
   1121          
   1122          
   1123          	stretch = stretch;		/* To suppress warning on read-only cfg. */
   1124          	i = dj->index + 1;
   \   000006   1F4A0600     MOV.W   0x6(R10), R15
   \   00000A   1F53         ADD.W   #0x1, R15
   \   00000C   0B4F         MOV.W   R15, R11
   1125          	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
   \   00000E   0B93         CMP.W   #0x0, R11
   \   000010   0624         JEQ     ??dir_next_1
   \   000012   1F4A1000     MOV.W   0x10(R10), R15
   \   000016   1FDA1200     BIS.W   0x12(R10), R15
   \   00001A   0F93         CMP.W   #0x0, R15
   \   00001C   0220         JNE     ??dir_next_2
   1126          		return FR_NO_FILE;
   \                     ??dir_next_1:
   \   00001E   6C42         MOV.B   #0x4, R12
   \   000020   B63C         JMP     ??dir_next_3
   1127          
   1128          	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
   \                     ??dir_next_2:
   \   000022   0C4B         MOV.W   R11, R12
   \   000024   3E401000     MOV.W   #0x10, R14
   \   000028   ........     CALLA   #?DivMod16u
   \   00002C   0E93         CMP.W   #0x0, R14
   \   00002E   9F20         JNE     ??dir_next_4
   1129          		dj->sect++;					/* Next sector */
   \   000030   9A531000     ADD.W   #0x1, 0x10(R10)
   \   000034   8A631200     ADDC.W  #0x0, 0x12(R10)
   1130          
   1131          		if (dj->clust == 0) {	/* Static table */
   \   000038   1F4A0C00     MOV.W   0xc(R10), R15
   \   00003C   1FDA0E00     BIS.W   0xe(R10), R15
   \   000040   0F93         CMP.W   #0x0, R15
   \   000042   0620         JNE     ??dir_next_5
   1132          			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
   \   000044   0F0A         MOVA    @R10, R15
   \   000046   1B9F0800     CMP.W   0x8(R15), R11
   \   00004A   9128         JNC     ??dir_next_4
   1133          				return FR_NO_FILE;
   \   00004C   6C42         MOV.B   #0x4, R12
   \   00004E   9F3C         JMP     ??dir_next_3
   1134          		}
   1135          		else {					/* Dynamic table */
   1136          			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
   \                     ??dir_next_5:
   \   000050   0E4B         MOV.W   R11, R14
   \   000052   5E0F         RRUM.W  #0x4, R14
   \   000054   0F0A         MOVA    @R10, R15
   \   000056   5F4F0200     MOV.B   0x2(R15), R15
   \   00005A   4F4F         MOV.B   R15, R15
   \   00005C   3F53         ADD.W   #0xffff, R15
   \   00005E   0EBF         BIT.W   R15, R14
   \   000060   8620         JNE     ??dir_next_4
   1137          				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
   \   000062   1E4A0C00     MOV.W   0xc(R10), R14
   \   000066   1F4A0E00     MOV.W   0xe(R10), R15
   \   00006A   0C0A         MOVA    @R10, R12
   \   00006C   ........     CALLA   #get_fat
   \   000070   084C         MOV.W   R12, R8
   \   000072   094D         MOV.W   R13, R9
   1138          				if (clst <= 1) return FR_INT_ERR;
   \   000074   0993         CMP.W   #0x0, R9
   \   000076   0328         JNC     ??dir_next_6
   \   000078   0420         JNE     ??dir_next_7
   \   00007A   2893         CMP.W   #0x2, R8
   \   00007C   022C         JC      ??dir_next_7
   \                     ??dir_next_6:
   \   00007E   6C43         MOV.B   #0x2, R12
   \   000080   863C         JMP     ??dir_next_3
   1139          				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_7:
   \   000082   3893         CMP.W   #0xffff, R8
   \   000084   0420         JNE     ??dir_next_8
   \   000086   3993         CMP.W   #0xffff, R9
   \   000088   0220         JNE     ??dir_next_8
   \   00008A   5C43         MOV.B   #0x1, R12
   \   00008C   803C         JMP     ??dir_next_3
   1140          				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
   \                     ??dir_next_8:
   \   00008E   0F0A         MOVA    @R10, R15
   \   000090   199F1C00     CMP.W   0x1c(R15), R9
   \   000094   5F28         JNC     ??dir_next_9
   \   000096   0320         JNE     ??dir_next_10
   \   000098   189F1A00     CMP.W   0x1a(R15), R8
   \   00009C   5B28         JNC     ??dir_next_9
   1141          #if !_FS_READONLY
   1142          					BYTE c;
   1143          					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
   \                     ??dir_next_10:
   \   00009E   0793         CMP.W   #0x0, R7
   \   0000A0   0220         JNE     ??dir_next_11
   \   0000A2   6C42         MOV.B   #0x4, R12
   \   0000A4   743C         JMP     ??dir_next_3
   1144          					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
   \                     ??dir_next_11:
   \   0000A6   1E4A0C00     MOV.W   0xc(R10), R14
   \   0000AA   1F4A0E00     MOV.W   0xe(R10), R15
   \   0000AE   0C0A         MOVA    @R10, R12
   \   0000B0   ........     CALLA   #create_chain
   \   0000B4   084C         MOV.W   R12, R8
   \   0000B6   094D         MOV.W   R13, R9
   1145          					if (clst == 0) return FR_DENIED;			/* No free cluster */
   \   0000B8   0F48         MOV.W   R8, R15
   \   0000BA   0FD9         BIS.W   R9, R15
   \   0000BC   0F93         CMP.W   #0x0, R15
   \   0000BE   0320         JNE     ??dir_next_12
   \   0000C0   7C400700     MOV.B   #0x7, R12
   \   0000C4   643C         JMP     ??dir_next_3
   1146          					if (clst == 1) return FR_INT_ERR;
   \                     ??dir_next_12:
   \   0000C6   1893         CMP.W   #0x1, R8
   \   0000C8   0420         JNE     ??dir_next_13
   \   0000CA   0993         CMP.W   #0x0, R9
   \   0000CC   0220         JNE     ??dir_next_13
   \   0000CE   6C43         MOV.B   #0x2, R12
   \   0000D0   5E3C         JMP     ??dir_next_3
   1147          					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_13:
   \   0000D2   3893         CMP.W   #0xffff, R8
   \   0000D4   0420         JNE     ??dir_next_14
   \   0000D6   3993         CMP.W   #0xffff, R9
   \   0000D8   0220         JNE     ??dir_next_14
   \   0000DA   5C43         MOV.B   #0x1, R12
   \   0000DC   583C         JMP     ??dir_next_3
   1148          					/* Clean-up stretched table */
   1149          					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
   \                     ??dir_next_14:
   \   0000DE   0E43         MOV.W   #0x0, R14
   \   0000E0   0F43         MOV.W   #0x0, R15
   \   0000E2   0C0A         MOVA    @R10, R12
   \   0000E4   ........     CALLA   #move_window
   \   0000E8   4C93         CMP.B   #0x0, R12
   \   0000EA   0224         JEQ     ??dir_next_15
   \   0000EC   5C43         MOV.B   #0x1, R12
   \   0000EE   4F3C         JMP     ??dir_next_3
   1150          					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
   \                     ??dir_next_15:
   \   0000F0   3E400002     MOV.W   #0x200, R14
   \   0000F4   0D43         MOV.W   #0x0, R13
   \   0000F6   0C0A         MOVA    @R10, R12
   \   0000F8   AC003200     ADDA    #0x32, R12
   \   0000FC   ........     CALLA   #mem_set
   1151          					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
   \   000100   0E48         MOV.W   R8, R14
   \   000102   0F49         MOV.W   R9, R15
   \   000104   0C0A         MOVA    @R10, R12
   \   000106   ........     CALLA   #clust2sect
   \   00010A   0F0A         MOVA    @R10, R15
   \   00010C   8F4C2E00     MOV.W   R12, 0x2e(R15)
   \   000110   8F4D3000     MOV.W   R13, 0x30(R15)
   1152          					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
   \   000114   4643         MOV.B   #0x0, R6
   \                     ??dir_next_0:
   \   000116   0F0A         MOVA    @R10, R15
   \   000118   569F0200     CMP.B   0x2(R15), R6
   \   00011C   132C         JC      ??dir_next_16
   1153          						dj->fs->wflag = 1;
   \   00011E   0F0A         MOVA    @R10, R15
   \   000120   DF430400     MOV.B   #0x1, 0x4(R15)
   1154          						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
   \   000124   0E43         MOV.W   #0x0, R14
   \   000126   0F43         MOV.W   #0x0, R15
   \   000128   0C0A         MOVA    @R10, R12
   \   00012A   ........     CALLA   #move_window
   \   00012E   4C93         CMP.B   #0x0, R12
   \   000130   0224         JEQ     ??dir_next_17
   \   000132   5C43         MOV.B   #0x1, R12
   \   000134   2C3C         JMP     ??dir_next_3
   1155          						dj->fs->winsect++;
   \                     ??dir_next_17:
   \   000136   0F0A         MOVA    @R10, R15
   \   000138   9F532E00     ADD.W   #0x1, 0x2e(R15)
   \   00013C   8F633000     ADDC.W  #0x0, 0x30(R15)
   1156          					}
   \   000140   5653         ADD.B   #0x1, R6
   \   000142   E93F         JMP     ??dir_next_0
   1157          					dj->fs->winsect -= c;						/* Rewind window address */
   \                     ??dir_next_16:
   \   000144   0D0A         MOVA    @R10, R13
   \   000146   4646         MOV.B   R6, R6
   \   000148   0E46         MOV.W   R6, R14
   \   00014A   0F43         MOV.W   #0x0, R15
   \   00014C   8D8E2E00     SUB.W   R14, 0x2e(R13)
   \   000150   8D7F3000     SUBC.W  R15, 0x30(R13)
   1158          #else
   1159          					return FR_NO_FILE;			/* Report EOT */
   1160          #endif
   1161          				}
   1162          				dj->clust = clst;				/* Initialize data for new cluster */
   \                     ??dir_next_9:
   \   000154   8A480C00     MOV.W   R8, 0xc(R10)
   \   000158   8A490E00     MOV.W   R9, 0xe(R10)
   1163          				dj->sect = clust2sect(dj->fs, clst);
   \   00015C   0E48         MOV.W   R8, R14
   \   00015E   0F49         MOV.W   R9, R15
   \   000160   0C0A         MOVA    @R10, R12
   \   000162   ........     CALLA   #clust2sect
   \   000166   8A4C1000     MOV.W   R12, 0x10(R10)
   \   00016A   8A4D1200     MOV.W   R13, 0x12(R10)
   1164          			}
   1165          		}
   1166          	}
   1167          
   1168          	dj->index = i;
   \                     ??dir_next_4:
   \   00016E   8A4B0600     MOV.W   R11, 0x6(R10)
   1169          	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
   \   000172   060A         MOVA    @R10, R6
   \   000174   0C4B         MOV.W   R11, R12
   \   000176   3E401000     MOV.W   #0x10, R14
   \   00017A   ........     CALLA   #?DivMod16u
   \   00017E                RPT     #0x5
   \   00017E   44180E5E     RLAX.W  R14
   \   000182   E60E         ADDA    R14, R6
   \   000184   A6003200     ADDA    #0x32, R6
   \   000188   7A061400     MOVA    R6, 0x14(R10)
   1170          
   1171          	return FR_OK;
   \   00018C   4C43         MOV.B   #0x0, R12
   \                     ??dir_next_3:
   \   00018E   5616         POPM.A  #0x6, R11
   \   000190   1001         RETA
   1172          }
   1173          
   1174          
   1175          
   1176          
   1177          /*-----------------------------------------------------------------------*/
   1178          /* Directory handling - Load/Store start cluster number                  */
   1179          /*-----------------------------------------------------------------------*/
   1180          

   \                                 In  segment CODE, align 2
   1181          static
   1182          DWORD ld_clust (
   \                     ld_clust:
   1183          	FATFS *fs,	/* Pointer to the fs object */
   1184          	BYTE *dir	/* Pointer to the directory entry */
   1185          )
   1186          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   CF0C         MOVA    R12, R15
   \   000004   CE0D         MOVA    R13, R14
   1187          	DWORD cl;
   1188          
   1189          	cl = LD_WORD(dir+DIR_FstClusLO);
   \   000006   5B4E1A00     MOV.B   0x1a(R14), R11
   \   00000A   4B4B         MOV.B   R11, R11
   \   00000C   5A4E1B00     MOV.B   0x1b(R14), R10
   \   000010   4A4A         MOV.B   R10, R10
   \   000012   3AF0FF00     AND.W   #0xff, R10
   \   000016   8A10         SWPB    R10
   \   000018   0ADB         BIS.W   R11, R10
   \   00001A   0B43         MOV.W   #0x0, R11
   \   00001C   0C4A         MOV.W   R10, R12
   \   00001E   0D4B         MOV.W   R11, R13
   1190          	if (fs->fs_type == FS_FAT32)
   \   000020   FF9003000000 CMP.B   #0x3, 0(R15)
   \   000026   0F20         JNE     ??ld_clust_0
   1191          		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
   \   000028   5B4E1400     MOV.B   0x14(R14), R11
   \   00002C   4B4B         MOV.B   R11, R11
   \   00002E   5A4E1500     MOV.B   0x15(R14), R10
   \   000032   4A4A         MOV.B   R10, R10
   \   000034   3AF0FF00     AND.W   #0xff, R10
   \   000038   8A10         SWPB    R10
   \   00003A   0ADB         BIS.W   R11, R10
   \   00003C   0B43         MOV.W   #0x0, R11
   \   00003E   0B4A         MOV.W   R10, R11
   \   000040   0A43         MOV.W   #0x0, R10
   \   000042   0CDA         BIS.W   R10, R12
   \   000044   0DDB         BIS.W   R11, R13
   1192          
   1193          	return cl;
   \                     ??ld_clust_0:
   \   000046   1A16         POPM.A  #0x2, R11
   \   000048   1001         RETA
   1194          }
   1195          
   1196          
   1197          #if !_FS_READONLY

   \                                 In  segment CODE, align 2
   1198          static
   1199          void st_clust (
   \                     st_clust:
   1200          	BYTE *dir,	/* Pointer to the directory entry */
   1201          	DWORD cl	/* Value to be set */
   1202          )
   1203          {
   1204          	ST_WORD(dir+DIR_FstClusLO, cl);
   \   000000   CC4E1A00     MOV.B   R14, 0x1a(R12)
   \   000004   0D4E         MOV.W   R14, R13
   \   000006   8D10         SWPB    R13
   \   000008   3DF0FF00     AND.W   #0xff, R13
   \   00000C   CC4D1B00     MOV.B   R13, 0x1b(R12)
   1205          	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   \   000010   CC4F1400     MOV.B   R15, 0x14(R12)
   \   000014   0D4F         MOV.W   R15, R13
   \   000016   8D10         SWPB    R13
   \   000018   3DF0FF00     AND.W   #0xff, R13
   \   00001C   CC4D1500     MOV.B   R13, 0x15(R12)
   1206          }
   \   000020   1001         RETA
   1207          #endif
   1208          
   1209          
   1210          
   1211          /*-----------------------------------------------------------------------*/
   1212          /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
   1213          /*-----------------------------------------------------------------------*/
   1214          #if _USE_LFN
   1215          static

   \                                 In  segment DATA20_C, align 1, align-sorted
   1216          const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
   \                     LfnOfs:
   \   000000   01030507090E DC8 1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30
   \            10121416181C
   \            1E          
   1217          
   1218          

   \                                 In  segment CODE, align 2
   1219          static
   1220          int cmp_lfn (			/* 1:Matched, 0:Not matched */
   \                     cmp_lfn:
   1221          	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
   1222          	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
   1223          )
   1224          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   CB0C         MOVA    R12, R11
   \   000004   C80D         MOVA    R13, R8
   1225          	UINT i, s;
   1226          	WCHAR wc, uc;
   1227          
   1228          
   1229          	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
   \   000006   6F48         MOV.B   @R8, R15
   \   000008   4F4F         MOV.B   R15, R15
   \   00000A   3FF0BFFF     AND.W   #0xffbf, R15
   \   00000E   3F53         ADD.W   #0xffff, R15
   \   000010   0E4F         MOV.W   R15, R14
   \   000012   5F06         RLAM.W  #0x2, R15
   \   000014   0E5F         ADD.W   R15, R14
   \   000016   0F5F         RLA.W   R15
   \   000018   0F5E         ADD.W   R14, R15
   \   00001A   0A4F         MOV.W   R15, R10
   1230          	s = 0; wc = 1;
   \   00001C   0943         MOV.W   #0x0, R9
   \   00001E   1643         MOV.W   #0x1, R6
   1231          	do {
   1232          		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
   \                     ??cmp_lfn_0:
   \   000020   ....5F49.... MOVX.B  LfnOfs(R9), R15
   \   000026   4F4F         MOV.B   R15, R15
   \   000028   EF08         ADDA    R8, R15
   \   00002A   6E4F         MOV.B   @R15, R14
   \   00002C   4E4E         MOV.B   R14, R14
   \   00002E   ....5F49.... MOVX.B  LfnOfs(R9), R15
   \   000034   4F4F         MOV.B   R15, R15
   \   000036   CD08         MOVA    R8, R13
   \   000038   ED0F         ADDA    R15, R13
   \   00003A   5F4D0100     MOV.B   0x1(R13), R15
   \   00003E   4F4F         MOV.B   R15, R15
   \   000040   3FF0FF00     AND.W   #0xff, R15
   \   000044   8F10         SWPB    R15
   \   000046   0FDE         BIS.W   R14, R15
   \   000048   074F         MOV.W   R15, R7
   1233          		if (wc) {	/* Last char has not been processed */
   \   00004A   0693         CMP.W   #0x0, R6
   \   00004C   1224         JEQ     ??cmp_lfn_1
   1234          			wc = ff_wtoupper(uc);		/* Convert it to upper case */
   \   00004E   0C47         MOV.W   R7, R12
   \   000050   ........     CALLA   #ff_wtoupper
   \   000054   064C         MOV.W   R12, R6
   1235          			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
   \   000056   3A906400     CMP.W   #0x64, R10
   \   00005A   092C         JC      ??cmp_lfn_2
   \   00005C   0F4A         MOV.W   R10, R15
   \   00005E   EF0F         ADDA    R15, R15
   \   000060   EF0B         ADDA    R11, R15
   \   000062   2C4F         MOV.W   @R15, R12
   \   000064   ........     CALLA   #ff_wtoupper
   \   000068   1A53         ADD.W   #0x1, R10
   \   00006A   069C         CMP.W   R12, R6
   \   00006C   0624         JEQ     ??cmp_lfn_3
   1236          				return 0;				/* Not matched */
   \                     ??cmp_lfn_2:
   \   00006E   0C43         MOV.W   #0x0, R12
   \   000070   173C         JMP     ??cmp_lfn_4
   1237          		} else {
   1238          			if (uc != 0xFFFF) return 0;	/* Check filler */
   \                     ??cmp_lfn_1:
   \   000072   3793         CMP.W   #0xffff, R7
   \   000074   0224         JEQ     ??cmp_lfn_3
   \   000076   0C43         MOV.W   #0x0, R12
   \   000078   133C         JMP     ??cmp_lfn_4
   1239          		}
   1240          	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
   \                     ??cmp_lfn_3:
   \   00007A   1953         ADD.W   #0x1, R9
   \   00007C   39900D00     CMP.W   #0xd, R9
   \   000080   CF2B         JNC     ??cmp_lfn_0
   1241          
   1242          	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
   \   000082   F8B040000000 BIT.B   #0x40, 0(R8)
   \   000088   0A28         JNC     ??cmp_lfn_5
   \   00008A   0693         CMP.W   #0x0, R6
   \   00008C   0824         JEQ     ??cmp_lfn_5
   \   00008E   0F4A         MOV.W   R10, R15
   \   000090   EF0F         ADDA    R15, R15
   \   000092   EF0B         ADDA    R11, R15
   \   000094   8F930000     CMP.W   #0x0, 0(R15)
   \   000098   0224         JEQ     ??cmp_lfn_5
   1243          		return 0;
   \   00009A   0C43         MOV.W   #0x0, R12
   \   00009C   013C         JMP     ??cmp_lfn_4
   1244          
   1245          	return 1;						/* The part of LFN matched */
   \                     ??cmp_lfn_5:
   \   00009E   1C43         MOV.W   #0x1, R12
   \                     ??cmp_lfn_4:
   \   0000A0   5616         POPM.A  #0x6, R11
   \   0000A2   1001         RETA
   1246          }
   1247          
   1248          
   1249          

   \                                 In  segment CODE, align 2
   1250          static
   1251          int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
   \                     pick_lfn:
   1252          	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
   1253          	BYTE *dir			/* Pointer to the directory entry */
   1254          )
   1255          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   CB0C         MOVA    R12, R11
   1256          	UINT i, s;
   1257          	WCHAR wc, uc;
   1258          
   1259          
   1260          	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   \   000004   6F4D         MOV.B   @R13, R15
   \   000006   4F4F         MOV.B   R15, R15
   \   000008   3FF03F00     AND.W   #0x3f, R15
   \   00000C   3F53         ADD.W   #0xffff, R15
   \   00000E   0C4F         MOV.W   R15, R12
   \   000010   5F06         RLAM.W  #0x2, R15
   \   000012   0C5F         ADD.W   R15, R12
   \   000014   0F5F         RLA.W   R15
   \   000016   0F5C         ADD.W   R12, R15
   \   000018   0A4F         MOV.W   R15, R10
   1261          
   1262          	s = 0; wc = 1;
   \   00001A   0E43         MOV.W   #0x0, R14
   \   00001C   1843         MOV.W   #0x1, R8
   1263          	do {
   1264          		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
   \                     ??pick_lfn_0:
   \   00001E   ....5F4E.... MOVX.B  LfnOfs(R14), R15
   \   000024   4F4F         MOV.B   R15, R15
   \   000026   EF0D         ADDA    R13, R15
   \   000028   6C4F         MOV.B   @R15, R12
   \   00002A   4C4C         MOV.B   R12, R12
   \   00002C   ....5F4E.... MOVX.B  LfnOfs(R14), R15
   \   000032   4F4F         MOV.B   R15, R15
   \   000034   C60D         MOVA    R13, R6
   \   000036   E60F         ADDA    R15, R6
   \   000038   5F460100     MOV.B   0x1(R6), R15
   \   00003C   4F4F         MOV.B   R15, R15
   \   00003E   3FF0FF00     AND.W   #0xff, R15
   \   000042   8F10         SWPB    R15
   \   000044   0FDC         BIS.W   R12, R15
   \   000046   094F         MOV.W   R15, R9
   1265          		if (wc) {	/* Last char has not been processed */
   \   000048   0893         CMP.W   #0x0, R8
   \   00004A   0D24         JEQ     ??pick_lfn_1
   1266          			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
   \   00004C   3A906400     CMP.W   #0x64, R10
   \   000050   0228         JNC     ??pick_lfn_2
   \   000052   0C43         MOV.W   #0x0, R12
   \   000054   1F3C         JMP     ??pick_lfn_3
   1267          			lfnbuf[i++] = wc = uc;			/* Store it */
   \                     ??pick_lfn_2:
   \   000056   0849         MOV.W   R9, R8
   \   000058   0F4A         MOV.W   R10, R15
   \   00005A   EF0F         ADDA    R15, R15
   \   00005C   EF0B         ADDA    R11, R15
   \   00005E   8F490000     MOV.W   R9, 0(R15)
   \   000062   1A53         ADD.W   #0x1, R10
   \   000064   043C         JMP     ??pick_lfn_4
   1268          		} else {
   1269          			if (uc != 0xFFFF) return 0;		/* Check filler */
   \                     ??pick_lfn_1:
   \   000066   3993         CMP.W   #0xffff, R9
   \   000068   0224         JEQ     ??pick_lfn_4
   \   00006A   0C43         MOV.W   #0x0, R12
   \   00006C   133C         JMP     ??pick_lfn_3
   1270          		}
   1271          	} while (++s < 13);						/* Read all character in the entry */
   \                     ??pick_lfn_4:
   \   00006E   1E53         ADD.W   #0x1, R14
   \   000070   3E900D00     CMP.W   #0xd, R14
   \   000074   D42B         JNC     ??pick_lfn_0
   1272          
   1273          	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
   \   000076   FDB040000000 BIT.B   #0x40, 0(R13)
   \   00007C   0A28         JNC     ??pick_lfn_5
   1274          		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
   \   00007E   3A906400     CMP.W   #0x64, R10
   \   000082   0228         JNC     ??pick_lfn_6
   \   000084   0C43         MOV.W   #0x0, R12
   \   000086   063C         JMP     ??pick_lfn_3
   1275          		lfnbuf[i] = 0;
   \                     ??pick_lfn_6:
   \   000088   0F4A         MOV.W   R10, R15
   \   00008A   EF0F         ADDA    R15, R15
   \   00008C   EF0B         ADDA    R11, R15
   \   00008E   8F430000     MOV.W   #0x0, 0(R15)
   1276          	}
   1277          
   1278          	return 1;
   \                     ??pick_lfn_5:
   \   000092   1C43         MOV.W   #0x1, R12
   \                     ??pick_lfn_3:
   \   000094   5616         POPM.A  #0x6, R11
   \   000096   1001         RETA
   1279          }
   1280          
   1281          
   1282          #if !_FS_READONLY

   \                                 In  segment CODE, align 2
   1283          static
   1284          void fit_lfn (
   \                     fit_lfn:
   1285          	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
   1286          	BYTE *dir,				/* Pointer to the directory entry */
   1287          	BYTE ord,				/* LFN order (1-20) */
   1288          	BYTE sum				/* SFN sum */
   1289          )
   1290          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   CA0C         MOVA    R12, R10
   \   000004   CC0D         MOVA    R13, R12
   \   000006   4D4E         MOV.B   R14, R13
   \   000008   484F         MOV.B   R15, R8
   1291          	UINT i, s;
   1292          	WCHAR wc;
   1293          
   1294          
   1295          	dir[LDIR_Chksum] = sum;			/* Set check sum */
   \   00000A   CC480D00     MOV.B   R8, 0xd(R12)
   1296          	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
   \   00000E   FC400F000B00 MOV.B   #0xf, 0xb(R12)
   1297          	dir[LDIR_Type] = 0;
   \   000014   CC430C00     MOV.B   #0x0, 0xc(R12)
   1298          	ST_WORD(dir+LDIR_FstClusLO, 0);
   \   000018   CC431A00     MOV.B   #0x0, 0x1a(R12)
   \   00001C   CC431B00     MOV.B   #0x0, 0x1b(R12)
   1299          
   1300          	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
   \   000020   4F4D         MOV.B   R13, R15
   \   000022   3F53         ADD.W   #0xffff, R15
   \   000024   064F         MOV.W   R15, R6
   \   000026   5F06         RLAM.W  #0x2, R15
   \   000028   065F         ADD.W   R15, R6
   \   00002A   0F5F         RLA.W   R15
   \   00002C   0F56         ADD.W   R6, R15
   \   00002E   0B4F         MOV.W   R15, R11
   1301          	s = wc = 0;
   \   000030   0F43         MOV.W   #0x0, R15
   \   000032   094F         MOV.W   R15, R9
   \   000034   0E4F         MOV.W   R15, R14
   1302          	do {
   1303          		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
   \                     ??fit_lfn_0:
   \   000036   3993         CMP.W   #0xffff, R9
   \   000038   0524         JEQ     ??fit_lfn_1
   \   00003A   0F4B         MOV.W   R11, R15
   \   00003C   EF0F         ADDA    R15, R15
   \   00003E   EF0A         ADDA    R10, R15
   \   000040   294F         MOV.W   @R15, R9
   \   000042   1B53         ADD.W   #0x1, R11
   1304          		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
   \                     ??fit_lfn_1:
   \   000044   ....5F4E.... MOVX.B  LfnOfs(R14), R15
   \   00004A   4F4F         MOV.B   R15, R15
   \   00004C   EF0C         ADDA    R12, R15
   \   00004E   CF490000     MOV.B   R9, 0(R15)
   \   000052   0F49         MOV.W   R9, R15
   \   000054   8F10         SWPB    R15
   \   000056   3FF0FF00     AND.W   #0xff, R15
   \   00005A   0612         PUSH.W  R6
   \   00005C   C14F0000     MOV.B   R15, 0(SP)
   \   000060   3641         POP.W   R6
   \   000062   ....5F4E.... MOVX.B  LfnOfs(R14), R15
   \   000068   4F4F         MOV.B   R15, R15
   \   00006A   C70C         MOVA    R12, R7
   \   00006C   E70F         ADDA    R15, R7
   \   00006E   C7460100     MOV.B   R6, 0x1(R7)
   1305          		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
   \   000072   0993         CMP.W   #0x0, R9
   \   000074   0120         JNE     ??fit_lfn_2
   \   000076   3943         MOV.W   #0xffff, R9
   1306          	} while (++s < 13);
   \                     ??fit_lfn_2:
   \   000078   1E53         ADD.W   #0x1, R14
   \   00007A   3E900D00     CMP.W   #0xd, R14
   \   00007E   DB2B         JNC     ??fit_lfn_0
   1307          	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
   \   000080   3993         CMP.W   #0xffff, R9
   \   000082   0624         JEQ     ??fit_lfn_3
   \   000084   0F4B         MOV.W   R11, R15
   \   000086   EF0F         ADDA    R15, R15
   \   000088   EF0A         ADDA    R10, R15
   \   00008A   8F930000     CMP.W   #0x0, 0(R15)
   \   00008E   0220         JNE     ??fit_lfn_4
   \                     ??fit_lfn_3:
   \   000090   7DD04000     BIS.B   #0x40, R13
   1308          	dir[LDIR_Ord] = ord;			/* Set the LFN order */
   \                     ??fit_lfn_4:
   \   000094   CC4D0000     MOV.B   R13, 0(R12)
   1309          }
   \   000098   5616         POPM.A  #0x6, R11
   \   00009A   1001         RETA
   1310          
   1311          #endif
   1312          #endif
   1313          
   1314          
   1315          
   1316          /*-----------------------------------------------------------------------*/
   1317          /* Create numbered name                                                  */
   1318          /*-----------------------------------------------------------------------*/
   1319          #if _USE_LFN

   \                                 In  segment CODE, align 2
   1320          void gen_numname (
   \                     gen_numname:
   1321          	BYTE *dst,			/* Pointer to generated SFN */
   1322          	const BYTE *src,	/* Pointer to source SFN to be modified */
   1323          	const WCHAR *lfn,	/* Pointer to LFN */
   1324          	WORD seq			/* Sequence number */
   1325          )
   1326          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   C70C         MOVA    R12, R7
   \   000006   C40D         MOVA    R13, R4
   \   000008   CA0E         MOVA    R14, R10
   \   00000A   0B4F         MOV.W   R15, R11
   1327          	BYTE ns[8], c;
   1328          	UINT i, j;
   1329          
   1330          
   1331          	mem_cpy(dst, src, 11);
   \   00000C   3E400B00     MOV.W   #0xb, R14
   \   000010   CD04         MOVA    R4, R13
   \   000012   CC07         MOVA    R7, R12
   \   000014   ........     CALLA   #mem_cpy
   1332          
   1333          	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
   \   000018   3B900600     CMP.W   #0x6, R11
   \   00001C   0C28         JNC     ??gen_numname_4
   1334          		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
   \                     ??gen_numname_0:
   \   00001E   0F4B         MOV.W   R11, R15
   \   000020   5F03         RRUM.W  #0x1, R15
   \   000022   0B11         RRA.W   R11
   \   000024   0B43         MOV.W   #0x0, R11
   \   000026   0B10         RRC.W   R11
   \   000028   0F5B         ADD.W   R11, R15
   \   00002A   0B4F         MOV.W   R15, R11
   \   00002C   2B5A         ADD.W   @R10, R11
   \   00002E   EA03         ADDA    #0x2, R10
   \   000030   8A930000     CMP.W   #0x0, 0(R10)
   \   000034   F423         JNE     ??gen_numname_0
   1335          	}
   1336          
   1337          	/* itoa (hexdecimal) */
   1338          	i = 7;
   \                     ??gen_numname_4:
   \   000036   38400700     MOV.W   #0x7, R8
   1339          	do {
   1340          		c = (seq % 16) + '0';
   \                     ??gen_numname_1:
   \   00003A   0C4B         MOV.W   R11, R12
   \   00003C   3E401000     MOV.W   #0x10, R14
   \   000040   ........     CALLA   #?DivMod16u
   \   000044   7E503000     ADD.B   #0x30, R14
   \   000048   464E         MOV.B   R14, R6
   1341          		if (c > '9') c += 7;
   \   00004A   76903A00     CMP.B   #0x3a, R6
   \   00004E   0228         JNC     ??gen_numname_5
   \   000050   76500700     ADD.B   #0x7, R6
   1342          		ns[i--] = c;
   \                     ??gen_numname_5:
   \   000054   0F48         MOV.W   R8, R15
   \   000056   0F51         ADD.W   SP, R15
   \   000058   CF460000     MOV.B   R6, 0(R15)
   \   00005C   3853         ADD.W   #0xffff, R8
   1343          		seq /= 16;
   \   00005E   5B0F         RRUM.W  #0x4, R11
   1344          	} while (seq);
   \   000060   0B93         CMP.W   #0x0, R11
   \   000062   EB23         JNE     ??gen_numname_1
   1345          	ns[i] = '~';
   \   000064   0F48         MOV.W   R8, R15
   \   000066   0F51         ADD.W   SP, R15
   \   000068   FF407E000000 MOV.B   #0x7e, 0(R15)
   1346          
   1347          	/* Append the number */
   1348          	for (j = 0; j < i && dst[j] != ' '; j++) {
   \   00006E   0943         MOV.W   #0x0, R9
   \                     ??gen_numname_2:
   \   000070   0998         CMP.W   R8, R9
   \   000072   082C         JC      ??gen_numname_3
   \   000074   CF07         MOVA    R7, R15
   \   000076   EF09         ADDA    R9, R15
   \   000078   FF9020000000 CMP.B   #0x20, 0(R15)
   \   00007E   0224         JEQ     ??gen_numname_3
   1349          		if (IsDBCS1(dst[j])) {
   \   000080   1953         ADD.W   #0x1, R9
   \   000082   F63F         JMP     ??gen_numname_2
   1350          			if (j == i - 1) break;
   1351          			j++;
   1352          		}
   1353          	}
   1354          	do {
   1355          		dst[j++] = (i < 8) ? ns[i++] : ' ';
   \                     ??gen_numname_3:
   \   000084   0F49         MOV.W   R9, R15
   \   000086   094F         MOV.W   R15, R9
   \   000088   1953         ADD.W   #0x1, R9
   \   00008A   3892         CMP.W   #0x8, R8
   \   00008C   052C         JC      ??gen_numname_6
   \   00008E   0E48         MOV.W   R8, R14
   \   000090   0E51         ADD.W   SP, R14
   \   000092   6D4E         MOV.B   @R14, R13
   \   000094   1853         ADD.W   #0x1, R8
   \   000096   023C         JMP     ??gen_numname_7
   \                     ??gen_numname_6:
   \   000098   7D402000     MOV.B   #0x20, R13
   \                     ??gen_numname_7:
   \   00009C   CE07         MOVA    R7, R14
   \   00009E   EE0F         ADDA    R15, R14
   \   0000A0   CE4D0000     MOV.B   R13, 0(R14)
   1356          	} while (j < 8);
   \   0000A4   3992         CMP.W   #0x8, R9
   \   0000A6   EE2B         JNC     ??gen_numname_3
   1357          }
   \   0000A8   3152         ADD.W   #0x8, SP
   \   0000AA   7416         POPM.A  #0x8, R11
   \   0000AC   1001         RETA
   1358          #endif
   1359          
   1360          
   1361          
   1362          
   1363          /*-----------------------------------------------------------------------*/
   1364          /* Calculate sum of an SFN                                               */
   1365          /*-----------------------------------------------------------------------*/
   1366          #if _USE_LFN

   \                                 In  segment CODE, align 2
   1367          static
   1368          BYTE sum_sfn (
   \                     sum_sfn:
   1369          	const BYTE *dir		/* Ptr to directory entry */
   1370          )
   1371          {
   \   000000   CF0C         MOVA    R12, R15
   1372          	BYTE sum = 0;
   \   000002   4C43         MOV.B   #0x0, R12
   1373          	UINT n = 11;
   \   000004   3E400B00     MOV.W   #0xb, R14
   1374          
   1375          	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
   \                     ??sum_sfn_0:
   \   000008   4D4C         MOV.B   R12, R13
   \   00000A   40194D10     RRUX.B  R13
   \   00000E   4C11         RRA.B   R12
   \   000010   4C43         MOV.B   #0x0, R12
   \   000012   4C10         RRC.B   R12
   \   000014   4D5C         ADD.B   R12, R13
   \   000016   4C4D         MOV.B   R13, R12
   \   000018   6C5F         ADD.B   @R15, R12
   \   00001A   AF000100     ADDA    #0x1, R15
   \   00001E   3E53         ADD.W   #0xffff, R14
   \   000020   0E93         CMP.W   #0x0, R14
   \   000022   F223         JNE     ??sum_sfn_0
   1376          	return sum;
   \   000024   1001         RETA
   1377          }
   1378          #endif
   1379          
   1380          
   1381          
   1382          
   1383          /*-----------------------------------------------------------------------*/
   1384          /* Directory handling - Find an object in the directory                  */
   1385          /*-----------------------------------------------------------------------*/
   1386          

   \                                 In  segment CODE, align 2
   1387          static
   1388          FRESULT dir_find (
   \                     dir_find:
   1389          	DIR *dj			/* Pointer to the directory object linked to the file name */
   1390          )
   1391          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   CA0C         MOVA    R12, R10
   1392          	FRESULT res;
   1393          	BYTE c, *dir;
   1394          #if _USE_LFN
   1395          	BYTE a, ord, sum;
   1396          #endif
   1397          
   1398          	res = dir_sdi(dj, 0);			/* Rewind directory object */
   \   000004   0D43         MOV.W   #0x0, R13
   \   000006   CC0A         MOVA    R10, R12
   \   000008   ........     CALLA   #dir_sdi
   \   00000C   494C         MOV.B   R12, R9
   1399          	if (res != FR_OK) return res;
   \   00000E   4993         CMP.B   #0x0, R9
   \   000010   0224         JEQ     ??dir_find_6
   \   000012   4C49         MOV.B   R9, R12
   \   000014   653C         JMP     ??dir_find_7
   1400          
   1401          #if _USE_LFN
   1402          	ord = sum = 0xFF;
   \                     ??dir_find_6:
   \   000016   7E43         MOV.B   #0xff, R14
   \   000018   474E         MOV.B   R14, R7
   \   00001A   484E         MOV.B   R14, R8
   1403          #endif
   1404          	do {
   1405          		res = move_window(dj->fs, dj->sect);
   \                     ??dir_find_0:
   \   00001C   1E4A1000     MOV.W   0x10(R10), R14
   \   000020   1F4A1200     MOV.W   0x12(R10), R15
   \   000024   0C0A         MOVA    @R10, R12
   \   000026   ........     CALLA   #move_window
   \   00002A   494C         MOV.B   R12, R9
   1406          		if (res != FR_OK) break;
   \   00002C   4993         CMP.B   #0x0, R9
   \   00002E   5720         JNE     ??dir_find_2
   1407          		dir = dj->dir;					/* Ptr to the directory entry of current index */
   \   000030   3B0A1400     MOVA    0x14(R10), R11
   1408          		c = dir[DIR_Name];
   \   000034   664B         MOV.B   @R11, R6
   1409          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   000036   4693         CMP.B   #0x0, R6
   \   000038   0220         JNE     ??dir_find_8
   \   00003A   6942         MOV.B   #0x4, R9
   \   00003C   503C         JMP     ??dir_find_2
   1410          #if _USE_LFN	/* LFN configuration */
   1411          		a = dir[DIR_Attr] & AM_MASK;
   \                     ??dir_find_8:
   \   00003E   5E4B0B00     MOV.B   0xb(R11), R14
   \   000042   7EF03F00     AND.B   #0x3f, R14
   \   000046   444E         MOV.B   R14, R4
   1412          		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   \   000048   7690E500     CMP.B   #0xe5, R6
   \   00004C   0524         JEQ     ??dir_find_9
   \   00004E   74B2         BIT.B   #0x8, R4
   \   000050   0528         JNC     ??dir_find_10
   \   000052   74900F00     CMP.B   #0xf, R4
   \   000056   0224         JEQ     ??dir_find_10
   1413          			ord = 0xFF;
   \                     ??dir_find_9:
   \   000058   7843         MOV.B   #0xff, R8
   \   00005A   3A3C         JMP     ??dir_find_4
   1414          		} else {
   1415          			if (a == AM_LFN) {			/* An LFN entry is found */
   \                     ??dir_find_10:
   \   00005C   74900F00     CMP.B   #0xf, R4
   \   000060   1F20         JNE     ??dir_find_11
   1416          				if (dj->lfn) {
   \   000062   3F0A1C00     MOVA    0x1c(R10), R15
   \   000066   DF03         CMPA    #0x0, R15
   \   000068   3324         JEQ     ??dir_find_4
   1417          					if (c & LLE) {		/* Is it start of LFN sequence? */
   \   00006A   76B04000     BIT.B   #0x40, R6
   \   00006E   0828         JNC     ??dir_find_12
   1418          						sum = dir[LDIR_Chksum];
   \   000070   574B0D00     MOV.B   0xd(R11), R7
   1419          						c &= ~LLE; ord = c;	/* LFN start order */
   \   000074   76C04000     BIC.B   #0x40, R6
   \   000078   4846         MOV.B   R6, R8
   1420          						dj->lfn_idx = dj->index;
   \   00007A   9A4A06002000 MOV.W   0x6(R10), 0x20(R10)
   1421          					}
   1422          					/* Check validity of the LFN entry and compare it with given name */
   1423          					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   \                     ??dir_find_12:
   \   000080   4698         CMP.B   R8, R6
   \   000082   0C20         JNE     ??dir_find_13
   \   000084   579B0D00     CMP.B   0xd(R11), R7
   \   000088   0920         JNE     ??dir_find_13
   \   00008A   CD0B         MOVA    R11, R13
   \   00008C   3C0A1C00     MOVA    0x1c(R10), R12
   \   000090   ........     CALLA   #cmp_lfn
   \   000094   0C93         CMP.W   #0x0, R12
   \   000096   0224         JEQ     ??dir_find_13
   \   000098   7853         ADD.B   #0xff, R8
   \   00009A   1A3C         JMP     ??dir_find_4
   \                     ??dir_find_13:
   \   00009C   7843         MOV.B   #0xff, R8
   \   00009E   183C         JMP     ??dir_find_4
   1424          				}
   1425          			} else {					/* An SFN entry is found */
   1426          				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
   \                     ??dir_find_11:
   \   0000A0   4893         CMP.B   #0x0, R8
   \   0000A2   0520         JNE     ??dir_find_5
   \   0000A4   CC0B         MOVA    R11, R12
   \   0000A6   ........     CALLA   #sum_sfn
   \   0000AA   479C         CMP.B   R12, R7
   \   0000AC   1824         JEQ     ??dir_find_2
   1427          				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   \                     ??dir_find_5:
   \   0000AE   7843         MOV.B   #0xff, R8
   \   0000B0   BA432000     MOV.W   #0xffff, 0x20(R10)
   1428          				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
   \   0000B4   3F0A1800     MOVA    0x18(R10), R15
   \   0000B8   DFB30B00     BIT.B   #0x1, 0xb(R15)
   \   0000BC   092C         JC      ??dir_find_4
   \   0000BE   3E400B00     MOV.W   #0xb, R14
   \   0000C2   3D0A1800     MOVA    0x18(R10), R13
   \   0000C6   CC0B         MOVA    R11, R12
   \   0000C8   ........     CALLA   #mem_cmp
   \   0000CC   0C93         CMP.W   #0x0, R12
   \   0000CE   0724         JEQ     ??dir_find_2
   1429          			}
   1430          		}
   1431          #else		/* Non LFN configuration */
   1432          		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
   1433          			break;
   1434          #endif
   1435          		res = dir_next(dj, 0);		/* Next entry */
   \                     ??dir_find_4:
   \   0000D0   0D43         MOV.W   #0x0, R13
   \   0000D2   CC0A         MOVA    R10, R12
   \   0000D4   ........     CALLA   #dir_next
   \   0000D8   494C         MOV.B   R12, R9
   1436          	} while (res == FR_OK);
   \   0000DA   4993         CMP.B   #0x0, R9
   \   0000DC   9F27         JEQ     ??dir_find_0
   1437          
   1438          	return res;
   \                     ??dir_find_2:
   \   0000DE   4C49         MOV.B   R9, R12
   \                     ??dir_find_7:
   \   0000E0   7416         POPM.A  #0x8, R11
   \   0000E2   1001         RETA
   1439          }
   1440          
   1441          
   1442          
   1443          
   1444          /*-----------------------------------------------------------------------*/
   1445          /* Read an object from the directory                                     */
   1446          /*-----------------------------------------------------------------------*/
   1447          #if _FS_MINIMIZE <= 1

   \                                 In  segment CODE, align 2
   1448          static
   1449          FRESULT dir_read (
   \                     dir_read:
   1450          	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
   1451          )
   1452          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   CA0C         MOVA    R12, R10
   1453          	FRESULT res;
   1454          	BYTE c, *dir;
   1455          #if _USE_LFN
   1456          	BYTE a, ord = 0xFF, sum = 0xFF;
   \   000004   7843         MOV.B   #0xff, R8
   \   000006   7743         MOV.B   #0xff, R7
   1457          #endif
   1458          
   1459          	res = FR_NO_FILE;
   \   000008   6942         MOV.B   #0x4, R9
   1460          	while (dj->sect) {
   \                     ??dir_read_0:
   \   00000A   1F4A1000     MOV.W   0x10(R10), R15
   \   00000E   1FDA1200     BIS.W   0x12(R10), R15
   \   000012   0F93         CMP.W   #0x0, R15
   \   000014   4F24         JEQ     ??dir_read_2
   1461          		res = move_window(dj->fs, dj->sect);
   \   000016   1E4A1000     MOV.W   0x10(R10), R14
   \   00001A   1F4A1200     MOV.W   0x12(R10), R15
   \   00001E   0C0A         MOVA    @R10, R12
   \   000020   ........     CALLA   #move_window
   \   000024   494C         MOV.B   R12, R9
   1462          		if (res != FR_OK) break;
   \   000026   4993         CMP.B   #0x0, R9
   \   000028   4520         JNE     ??dir_read_2
   1463          		dir = dj->dir;					/* Ptr to the directory entry of current index */
   \   00002A   3B0A1400     MOVA    0x14(R10), R11
   1464          		c = dir[DIR_Name];
   \   00002E   664B         MOV.B   @R11, R6
   1465          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   000030   4693         CMP.B   #0x0, R6
   \   000032   0220         JNE     ??dir_read_6
   \   000034   6942         MOV.B   #0x4, R9
   \   000036   3E3C         JMP     ??dir_read_2
   1466          #if _USE_LFN	/* LFN configuration */
   1467          		a = dir[DIR_Attr] & AM_MASK;
   \                     ??dir_read_6:
   \   000038   5E4B0B00     MOV.B   0xb(R11), R14
   \   00003C   7EF03F00     AND.B   #0x3f, R14
   \   000040   444E         MOV.B   R14, R4
   1468          		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   \   000042   7690E500     CMP.B   #0xe5, R6
   \   000046   0524         JEQ     ??dir_read_7
   \   000048   74B2         BIT.B   #0x8, R4
   \   00004A   0528         JNC     ??dir_read_8
   \   00004C   74900F00     CMP.B   #0xf, R4
   \   000050   0224         JEQ     ??dir_read_8
   1469          			ord = 0xFF;
   \                     ??dir_read_7:
   \   000052   7843         MOV.B   #0xff, R8
   \   000054   283C         JMP     ??dir_read_4
   1470          		} else {
   1471          			if (a == AM_LFN) {			/* An LFN entry is found */
   \                     ??dir_read_8:
   \   000056   74900F00     CMP.B   #0xf, R4
   \   00005A   1B20         JNE     ??dir_read_9
   1472          				if (c & LLE) {			/* Is it start of LFN sequence? */
   \   00005C   76B04000     BIT.B   #0x40, R6
   \   000060   0828         JNC     ??dir_read_10
   1473          					sum = dir[LDIR_Chksum];
   \   000062   574B0D00     MOV.B   0xd(R11), R7
   1474          					c &= ~LLE; ord = c;
   \   000066   76C04000     BIC.B   #0x40, R6
   \   00006A   4846         MOV.B   R6, R8
   1475          					dj->lfn_idx = dj->index;
   \   00006C   9A4A06002000 MOV.W   0x6(R10), 0x20(R10)
   1476          				}
   1477          				/* Check LFN validity and capture it */
   1478          				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   \                     ??dir_read_10:
   \   000072   4698         CMP.B   R8, R6
   \   000074   0C20         JNE     ??dir_read_11
   \   000076   579B0D00     CMP.B   0xd(R11), R7
   \   00007A   0920         JNE     ??dir_read_11
   \   00007C   CD0B         MOVA    R11, R13
   \   00007E   3C0A1C00     MOVA    0x1c(R10), R12
   \   000082   ........     CALLA   #pick_lfn
   \   000086   0C93         CMP.W   #0x0, R12
   \   000088   0224         JEQ     ??dir_read_11
   \   00008A   7853         ADD.B   #0xff, R8
   \   00008C   0C3C         JMP     ??dir_read_4
   \                     ??dir_read_11:
   \   00008E   7843         MOV.B   #0xff, R8
   \   000090   0A3C         JMP     ??dir_read_4
   1479          			} else {					/* An SFN entry is found */
   1480          				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
   \                     ??dir_read_9:
   \   000092   4893         CMP.B   #0x0, R8
   \   000094   0520         JNE     ??dir_read_12
   \   000096   CC0B         MOVA    R11, R12
   \   000098   ........     CALLA   #sum_sfn
   \   00009C   479C         CMP.B   R12, R7
   \   00009E   0A24         JEQ     ??dir_read_2
   1481          					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
   \                     ??dir_read_12:
   \   0000A0   BA432000     MOV.W   #0xffff, 0x20(R10)
   1482          				break;
   \   0000A4   073C         JMP     ??dir_read_2
   1483          			}
   1484          		}
   1485          #else		/* Non LFN configuration */
   1486          		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
   1487          			break;
   1488          #endif
   1489          		res = dir_next(dj, 0);				/* Next entry */
   \                     ??dir_read_4:
   \   0000A6   0D43         MOV.W   #0x0, R13
   \   0000A8   CC0A         MOVA    R10, R12
   \   0000AA   ........     CALLA   #dir_next
   \   0000AE   494C         MOV.B   R12, R9
   1490          		if (res != FR_OK) break;
   \   0000B0   4993         CMP.B   #0x0, R9
   \   0000B2   AB27         JEQ     ??dir_read_0
   1491          	}
   1492          
   1493          	if (res != FR_OK) dj->sect = 0;
   \                     ??dir_read_2:
   \   0000B4   4993         CMP.B   #0x0, R9
   \   0000B6   0424         JEQ     ??dir_read_13
   \   0000B8   8A431000     MOV.W   #0x0, 0x10(R10)
   \   0000BC   8A431200     MOV.W   #0x0, 0x12(R10)
   1494          
   1495          	return res;
   \                     ??dir_read_13:
   \   0000C0   4C49         MOV.B   R9, R12
   \   0000C2   7416         POPM.A  #0x8, R11
   \   0000C4   1001         RETA
   1496          }
   1497          #endif
   1498          
   1499          
   1500          
   1501          /*-----------------------------------------------------------------------*/
   1502          /* Register an object to the directory                                   */
   1503          /*-----------------------------------------------------------------------*/
   1504          #if !_FS_READONLY

   \                                 In  segment CODE, align 2
   1505          static
   1506          FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
   \                     dir_register:
   1507          	DIR *dj				/* Target directory with object name to be created */
   1508          )
   1509          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   31800E00     SUB.W   #0xe, SP
   \   000006   CA0C         MOVA    R12, R10
   1510          	FRESULT res;
   1511          	BYTE c, *dir;
   1512          #if _USE_LFN	/* LFN configuration */
   1513          	WORD n, ne, is;
   1514          	BYTE sn[12], *fn, sum;
   1515          	WCHAR *lfn;
   1516          
   1517          
   1518          	fn = dj->fn; lfn = dj->lfn;
   \   000008   360A1800     MOVA    0x18(R10), R6
   \   00000C   370A1C00     MOVA    0x1c(R10), R7
   1519          	mem_cpy(sn, fn, 12);
   \   000010   3E400C00     MOV.W   #0xc, R14
   \   000014   CD06         MOVA    R6, R13
   \   000016   0C41         MOV.W   SP, R12
   \   000018   2C53         ADD.W   #0x2, R12
   \   00001A   ........     CALLA   #mem_cpy
   1520          
   1521          	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
   \   00001E   F1B020000D00 BIT.B   #0x20, 0xd(SP)
   \   000024   0328         JNC     ??dir_register_10
   1522          		return FR_INVALID_NAME;
   \   000026   7C400600     MOV.B   #0x6, R12
   \   00002A   CE3C         JMP     ??dir_register_11
   1523          
   1524          	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
   \                     ??dir_register_10:
   \   00002C   D1B30D00     BIT.B   #0x1, 0xd(SP)
   \   000030   2728         JNC     ??dir_register_12
   1525          		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
   \   000032   C6430B00     MOV.B   #0x0, 0xb(R6)
   \   000036   0018CA431C00 MOVX.A  #0x0, 0x1c(R10)
   1526          		for (n = 1; n < 100; n++) {
   \   00003C   1943         MOV.W   #0x1, R9
   \                     ??dir_register_0:
   \   00003E   39906400     CMP.W   #0x64, R9
   \   000042   0F2C         JC      ??dir_register_5
   1527          			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
   \   000044   0F49         MOV.W   R9, R15
   \   000046   CE07         MOVA    R7, R14
   \   000048   0D41         MOV.W   SP, R13
   \   00004A   2D53         ADD.W   #0x2, R13
   \   00004C   CC06         MOVA    R6, R12
   \   00004E   ........     CALLA   #gen_numname
   1528          			res = dir_find(dj);				/* Check if the name collides with existing SFN */
   \   000052   CC0A         MOVA    R10, R12
   \   000054   ........     CALLA   #dir_find
   \   000058   4B4C         MOV.B   R12, R11
   1529          			if (res != FR_OK) break;
   \   00005A   4B93         CMP.B   #0x0, R11
   \   00005C   0220         JNE     ??dir_register_5
   1530          		}
   \   00005E   1953         ADD.W   #0x1, R9
   \   000060   EE3F         JMP     ??dir_register_0
   1531          		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
   \                     ??dir_register_5:
   \   000062   39906400     CMP.W   #0x64, R9
   \   000066   0320         JNE     ??dir_register_13
   \   000068   7C400700     MOV.B   #0x7, R12
   \   00006C   AD3C         JMP     ??dir_register_11
   1532          		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
   \                     ??dir_register_13:
   \   00006E   6B92         CMP.B   #0x4, R11
   \   000070   0224         JEQ     ??dir_register_14
   \   000072   4C4B         MOV.B   R11, R12
   \   000074   A93C         JMP     ??dir_register_11
   1533          		fn[NS] = sn[NS]; dj->lfn = lfn;
   \                     ??dir_register_14:
   \   000076   D6410D000B00 MOV.B   0xd(SP), 0xb(R6)
   \   00007C   7A071C00     MOVA    R7, 0x1c(R10)
   1534          	}
   1535          
   1536          	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
   \                     ??dir_register_12:
   \   000080   E1B30D00     BIT.B   #0x2, 0xd(SP)
   \   000084   1228         JNC     ??dir_register_15
   1537          		for (ne = 0; lfn[ne]; ne++) ;
   \   000086   0843         MOV.W   #0x0, R8
   \                     ??dir_register_1:
   \   000088   0F48         MOV.W   R8, R15
   \   00008A   EF0F         ADDA    R15, R15
   \   00008C   EF07         ADDA    R7, R15
   \   00008E   8F930000     CMP.W   #0x0, 0(R15)
   \   000092   0224         JEQ     ??dir_register_16
   \   000094   1853         ADD.W   #0x1, R8
   \   000096   F83F         JMP     ??dir_register_1
   1538          		ne = (ne + 25) / 13;
   \                     ??dir_register_16:
   \   000098   38501900     ADD.W   #0x19, R8
   \   00009C   0C48         MOV.W   R8, R12
   \   00009E   3E400D00     MOV.W   #0xd, R14
   \   0000A2   ........     CALLA   #?DivMod16u
   \   0000A6   084C         MOV.W   R12, R8
   \   0000A8   013C         JMP     ??dir_register_17
   1539          	} else {						/* Otherwise reserve only an SFN entry. */
   1540          		ne = 1;
   \                     ??dir_register_15:
   \   0000AA   1843         MOV.W   #0x1, R8
   1541          	}
   1542          
   1543          	/* Reserve contiguous entries */
   1544          	res = dir_sdi(dj, 0);
   \                     ??dir_register_17:
   \   0000AC   0D43         MOV.W   #0x0, R13
   \   0000AE   CC0A         MOVA    R10, R12
   \   0000B0   ........     CALLA   #dir_sdi
   \   0000B4   4B4C         MOV.B   R12, R11
   1545          	if (res != FR_OK) return res;
   \   0000B6   4B93         CMP.B   #0x0, R11
   \   0000B8   0224         JEQ     ??dir_register_18
   \   0000BA   4C4B         MOV.B   R11, R12
   \   0000BC   853C         JMP     ??dir_register_11
   1546          	n = is = 0;
   \                     ??dir_register_18:
   \   0000BE   0F43         MOV.W   #0x0, R15
   \   0000C0   054F         MOV.W   R15, R5
   \   0000C2   094F         MOV.W   R15, R9
   1547          	do {
   1548          		res = move_window(dj->fs, dj->sect);
   \                     ??dir_register_2:
   \   0000C4   1E4A1000     MOV.W   0x10(R10), R14
   \   0000C8   1F4A1200     MOV.W   0x12(R10), R15
   \   0000CC   0C0A         MOVA    @R10, R12
   \   0000CE   ........     CALLA   #move_window
   \   0000D2   4B4C         MOV.B   R12, R11
   1549          		if (res != FR_OK) break;
   \   0000D4   4B93         CMP.B   #0x0, R11
   \   0000D6   1C20         JNE     ??dir_register_7
   1550          		c = *dj->dir;				/* Check the entry status */
   \   0000D8   3F0A1400     MOVA    0x14(R10), R15
   \   0000DC   4018E14F0000 MOVX.B  @R15, 0(SP)
   1551          		if (c == DDE || c == 0) {	/* Is it a blank entry? */
   \   0000E2   F190E5000000 CMP.B   #0xe5, 0(SP)
   \   0000E8   0324         JEQ     ??dir_register_19
   \   0000EA   C1930000     CMP.B   #0x0, 0(SP)
   \   0000EE   0820         JNE     ??dir_register_20
   1552          			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
   \                     ??dir_register_19:
   \   0000F0   0993         CMP.W   #0x0, R9
   \   0000F2   0220         JNE     ??dir_register_21
   \   0000F4   154A0600     MOV.W   0x6(R10), R5
   1553          			if (++n == ne) break;	/* A contiguous entry that required count is found */
   \                     ??dir_register_21:
   \   0000F8   1953         ADD.W   #0x1, R9
   \   0000FA   0998         CMP.W   R8, R9
   \   0000FC   0220         JNE     ??dir_register_22
   \   0000FE   083C         JMP     ??dir_register_7
   1554          		} else {
   1555          			n = 0;					/* Not a blank entry. Restart to search */
   \                     ??dir_register_20:
   \   000100   0943         MOV.W   #0x0, R9
   1556          		}
   1557          		res = dir_next(dj, 1);		/* Next entry with table stretch */
   \                     ??dir_register_22:
   \   000102   1D43         MOV.W   #0x1, R13
   \   000104   CC0A         MOVA    R10, R12
   \   000106   ........     CALLA   #dir_next
   \   00010A   4B4C         MOV.B   R12, R11
   1558          	} while (res == FR_OK);
   \   00010C   4B93         CMP.B   #0x0, R11
   \   00010E   DA27         JEQ     ??dir_register_2
   1559          
   1560          	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
   \                     ??dir_register_7:
   \   000110   4B93         CMP.B   #0x0, R11
   \   000112   3320         JNE     ??dir_register_9
   \   000114   2893         CMP.W   #0x2, R8
   \   000116   3128         JNC     ??dir_register_9
   1561          		res = dir_sdi(dj, is);
   \   000118   0D45         MOV.W   R5, R13
   \   00011A   CC0A         MOVA    R10, R12
   \   00011C   ........     CALLA   #dir_sdi
   \   000120   4B4C         MOV.B   R12, R11
   1562          		if (res == FR_OK) {
   \   000122   4B93         CMP.B   #0x0, R11
   \   000124   2A20         JNE     ??dir_register_9
   1563          			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
   \   000126   3C0A1800     MOVA    0x18(R10), R12
   \   00012A   ........     CALLA   #sum_sfn
   \   00012E   C14C0100     MOV.B   R12, 0x1(SP)
   1564          			ne--;
   \   000132   3853         ADD.W   #0xffff, R8
   1565          			do {					/* Store LFN entries in bottom first */
   1566          				res = move_window(dj->fs, dj->sect);
   \                     ??dir_register_3:
   \   000134   1E4A1000     MOV.W   0x10(R10), R14
   \   000138   1F4A1200     MOV.W   0x12(R10), R15
   \   00013C   0C0A         MOVA    @R10, R12
   \   00013E   ........     CALLA   #move_window
   \   000142   4B4C         MOV.B   R12, R11
   1567          				if (res != FR_OK) break;
   \   000144   4B93         CMP.B   #0x0, R11
   \   000146   1920         JNE     ??dir_register_9
   1568          				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
   \   000148   5F410100     MOV.B   0x1(SP), R15
   \   00014C   0E12         PUSH.W  R14
   \   00014E   C1480000     MOV.B   R8, 0(SP)
   \   000152   3E41         POP.W   R14
   \   000154   3D0A1400     MOVA    0x14(R10), R13
   \   000158   3C0A1C00     MOVA    0x1c(R10), R12
   \   00015C   ........     CALLA   #fit_lfn
   1569          				dj->fs->wflag = 1;
   \   000160   0F0A         MOVA    @R10, R15
   \   000162   DF430400     MOV.B   #0x1, 0x4(R15)
   1570          				res = dir_next(dj, 0);	/* Next entry */
   \   000166   0D43         MOV.W   #0x0, R13
   \   000168   CC0A         MOVA    R10, R12
   \   00016A   ........     CALLA   #dir_next
   \   00016E   4B4C         MOV.B   R12, R11
   1571          			} while (res == FR_OK && --ne);
   \   000170   4B93         CMP.B   #0x0, R11
   \   000172   0320         JNE     ??dir_register_9
   \   000174   3853         ADD.W   #0xffff, R8
   \   000176   0893         CMP.W   #0x0, R8
   \   000178   DD23         JNE     ??dir_register_3
   1572          		}
   1573          	}
   1574          
   1575          #else	/* Non LFN configuration */
   1576          	res = dir_sdi(dj, 0);
   1577          	if (res == FR_OK) {
   1578          		do {	/* Find a blank entry for the SFN */
   1579          			res = move_window(dj->fs, dj->sect);
   1580          			if (res != FR_OK) break;
   1581          			c = *dj->dir;
   1582          			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
   1583          			res = dir_next(dj, 1);			/* Next entry with table stretch */
   1584          		} while (res == FR_OK);
   1585          	}
   1586          #endif
   1587          
   1588          	if (res == FR_OK) {		/* Initialize the SFN entry */
   \                     ??dir_register_9:
   \   00017A   4B93         CMP.B   #0x0, R11
   \   00017C   2420         JNE     ??dir_register_23
   1589          		res = move_window(dj->fs, dj->sect);
   \   00017E   1E4A1000     MOV.W   0x10(R10), R14
   \   000182   1F4A1200     MOV.W   0x12(R10), R15
   \   000186   0C0A         MOVA    @R10, R12
   \   000188   ........     CALLA   #move_window
   \   00018C   4B4C         MOV.B   R12, R11
   1590          		if (res == FR_OK) {
   \   00018E   4B93         CMP.B   #0x0, R11
   \   000190   1A20         JNE     ??dir_register_23
   1591          			dir = dj->dir;
   \   000192   340A1400     MOVA    0x14(R10), R4
   1592          			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
   \   000196   3E402000     MOV.W   #0x20, R14
   \   00019A   0D43         MOV.W   #0x0, R13
   \   00019C   CC04         MOVA    R4, R12
   \   00019E   ........     CALLA   #mem_set
   1593          			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
   \   0001A2   3E400B00     MOV.W   #0xb, R14
   \   0001A6   3D0A1800     MOVA    0x18(R10), R13
   \   0001AA   CC04         MOVA    R4, R12
   \   0001AC   ........     CALLA   #mem_cpy
   1594          #if _USE_LFN
   1595          			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
   \   0001B0   3F0A1800     MOVA    0x18(R10), R15
   \   0001B4   5E4F0B00     MOV.B   0xb(R15), R14
   \   0001B8   7EF01800     AND.B   #0x18, R14
   \   0001BC   C44E0C00     MOV.B   R14, 0xc(R4)
   1596          #endif
   1597          			dj->fs->wflag = 1;
   \   0001C0   0F0A         MOVA    @R10, R15
   \   0001C2   DF430400     MOV.B   #0x1, 0x4(R15)
   1598          		}
   1599          	}
   1600          
   1601          	return res;
   \                     ??dir_register_23:
   \   0001C6   4C4B         MOV.B   R11, R12
   \                     ??dir_register_11:
   \   0001C8   31500E00     ADD.W   #0xe, SP
   \   0001CC   7416         POPM.A  #0x8, R11
   \   0001CE   1001         RETA
   1602          }
   1603          #endif /* !_FS_READONLY */
   1604          
   1605          
   1606          
   1607          
   1608          /*-----------------------------------------------------------------------*/
   1609          /* Remove an object from the directory                                   */
   1610          /*-----------------------------------------------------------------------*/
   1611          #if !_FS_READONLY && !_FS_MINIMIZE

   \                                 In  segment CODE, align 2
   1612          static
   1613          FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
   \                     dir_remove:
   1614          	DIR *dj				/* Directory object pointing the entry to be removed */
   1615          )
   1616          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   CA0C         MOVA    R12, R10
   1617          	FRESULT res;
   1618          #if _USE_LFN	/* LFN configuration */
   1619          	WORD i;
   1620          
   1621          	i = dj->index;	/* SFN index */
   \   000004   184A0600     MOV.W   0x6(R10), R8
   1622          	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
   \   000008   BA932000     CMP.W   #0xffff, 0x20(R10)
   \   00000C   0220         JNE     ??dir_remove_4
   \   00000E   0D48         MOV.W   R8, R13
   \   000010   023C         JMP     ??dir_remove_5
   \                     ??dir_remove_4:
   \   000012   1D4A2000     MOV.W   0x20(R10), R13
   \                     ??dir_remove_5:
   \   000016   CC0A         MOVA    R10, R12
   \   000018   ........     CALLA   #dir_sdi
   \   00001C   4B4C         MOV.B   R12, R11
   1623          	if (res == FR_OK) {
   \   00001E   4B93         CMP.B   #0x0, R11
   \   000020   1F20         JNE     ??dir_remove_6
   1624          		do {
   1625          			res = move_window(dj->fs, dj->sect);
   \                     ??dir_remove_0:
   \   000022   1E4A1000     MOV.W   0x10(R10), R14
   \   000026   1F4A1200     MOV.W   0x12(R10), R15
   \   00002A   0C0A         MOVA    @R10, R12
   \   00002C   ........     CALLA   #move_window
   \   000030   4B4C         MOV.B   R12, R11
   1626          			if (res != FR_OK) break;
   \   000032   4B93         CMP.B   #0x0, R11
   \   000034   1220         JNE     ??dir_remove_2
   1627          			*dj->dir = DDE;			/* Mark the entry "deleted" */
   \   000036   3F0A1400     MOVA    0x14(R10), R15
   \   00003A   FF40E5000000 MOV.B   #0xe5, 0(R15)
   1628          			dj->fs->wflag = 1;
   \   000040   0F0A         MOVA    @R10, R15
   \   000042   DF430400     MOV.B   #0x1, 0x4(R15)
   1629          			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
   \   000046   8A980600     CMP.W   R8, 0x6(R10)
   \   00004A   072C         JC      ??dir_remove_2
   1630          			res = dir_next(dj, 0);		/* Next entry */
   \   00004C   0D43         MOV.W   #0x0, R13
   \   00004E   CC0A         MOVA    R10, R12
   \   000050   ........     CALLA   #dir_next
   \   000054   4B4C         MOV.B   R12, R11
   1631          		} while (res == FR_OK);
   \   000056   4B93         CMP.B   #0x0, R11
   \   000058   E427         JEQ     ??dir_remove_0
   1632          		if (res == FR_NO_FILE) res = FR_INT_ERR;
   \                     ??dir_remove_2:
   \   00005A   6B92         CMP.B   #0x4, R11
   \   00005C   0120         JNE     ??dir_remove_6
   \   00005E   6B43         MOV.B   #0x2, R11
   1633          	}
   1634          
   1635          #else			/* Non LFN configuration */
   1636          	res = dir_sdi(dj, dj->index);
   1637          	if (res == FR_OK) {
   1638          		res = move_window(dj->fs, dj->sect);
   1639          		if (res == FR_OK) {
   1640          			*dj->dir = DDE;			/* Mark the entry "deleted" */
   1641          			dj->fs->wflag = 1;
   1642          		}
   1643          	}
   1644          #endif
   1645          
   1646          	return res;
   \                     ??dir_remove_6:
   \   000060   4C4B         MOV.B   R11, R12
   \   000062   3816         POPM.A  #0x4, R11
   \   000064   1001         RETA
   1647          }
   1648          #endif /* !_FS_READONLY */
   1649          
   1650          
   1651          
   1652          
   1653          /*-----------------------------------------------------------------------*/
   1654          /* Pick a segment and create the object name in directory form           */
   1655          /*-----------------------------------------------------------------------*/
   1656          

   \                                 In  segment CODE, align 2
   1657          static
   1658          FRESULT create_name (
   \                     create_name:
   1659          	DIR *dj,			/* Pointer to the directory object */
   1660          	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
   1661          )
   1662          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   0D14         PUSHM.A #0x1, R13
   \   000004   31800600     SUB.W   #0x6, SP
   \   000008   C50C         MOVA    R12, R5
   1663          #ifdef _EXCVT
   1664          	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
   1665          #endif
   1666          
   1667          #if _USE_LFN	/* LFN configuration */
   1668          	BYTE b, cf;
   1669          	WCHAR w, *lfn;
   1670          	UINT i, ni, si, di;
   1671          	const TCHAR *p;
   1672          
   1673          	/* Create LFN in Unicode */
   1674          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   \   00000A   3F010600     MOVA    0x6(SP), R15
   \   00000E   0018E14F0200 MOVX.A  @R15, 0x2(SP)
   \                     ??create_name_0:
   \   000014   3F010200     MOVA    0x2(SP), R15
   \   000018   FF902F000000 CMP.B   #0x2f, 0(R15)
   \   00001E   0624         JEQ     ??create_name_12
   \   000020   3F010200     MOVA    0x2(SP), R15
   \   000024   FF905C000000 CMP.B   #0x5c, 0(R15)
   \   00002A   0720         JNE     ??create_name_13
   \                     ??create_name_12:
   \   00002C   3F010200     MOVA    0x2(SP), R15
   \   000030   AF000100     ADDA    #0x1, R15
   \   000034   710F0200     MOVA    R15, 0x2(SP)
   \   000038   ED3F         JMP     ??create_name_0
   1675          	lfn = dj->lfn;
   \                     ??create_name_13:
   \   00003A   39051C00     MOVA    0x1c(R5), R9
   1676          	si = di = 0;
   \   00003E   0F43         MOV.W   #0x0, R15
   \   000040   0A4F         MOV.W   R15, R10
   \   000042   064F         MOV.W   R15, R6
   1677          	for (;;) {
   1678          		w = p[si++];					/* Get a character */
   \                     ??create_name_1:
   \   000044   3F010200     MOVA    0x2(SP), R15
   \   000048   EF06         ADDA    R6, R15
   \   00004A   6F4F         MOV.B   @R15, R15
   \   00004C   4F4F         MOV.B   R15, R15
   \   00004E   084F         MOV.W   R15, R8
   \   000050   1653         ADD.W   #0x1, R6
   1679          		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
   \   000052   38902000     CMP.W   #0x20, R8
   \   000056   0628         JNC     ??create_name_14
   \   000058   38902F00     CMP.W   #0x2f, R8
   \   00005C   0324         JEQ     ??create_name_14
   \   00005E   38905C00     CMP.W   #0x5c, R8
   \   000062   0B20         JNE     ??create_name_15
   1680          		if (di >= _MAX_LFN)				/* Reject too long name */
   1681          			return FR_INVALID_NAME;
   1682          #if !_LFN_UNICODE
   1683          		w &= 0xFF;
   1684          		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1685          			b = (BYTE)p[si++];			/* Get 2nd byte */
   1686          			if (!IsDBCS2(b))
   1687          				return FR_INVALID_NAME;	/* Reject invalid sequence */
   1688          #pragma diag_suppress = Pe111                        
   1689          			w = (w << 8) + b;			/* Create a DBC */
   1690          		}
   1691          		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
   1692          		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   1693          #endif
   1694          		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
   1695          			return FR_INVALID_NAME;
   1696          		lfn[di++] = w;					/* Store the Unicode char */
   1697          	}
   1698          	*path = &p[si];						/* Return pointer to the next segment */
   \                     ??create_name_14:
   \   000064   3F010200     MOVA    0x2(SP), R15
   \   000068   EF06         ADDA    R6, R15
   \   00006A   3E010600     MOVA    0x6(SP), R14
   \   00006E   7E0F0000     MOVA    R15, 0(R14)
   1699          	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   \   000072   38902000     CMP.W   #0x20, R8
   \   000076   292C         JC      ??create_name_16
   \   000078   263C         JMP     ??create_name_17
   \                     ??create_name_15:
   \   00007A   3A906400     CMP.W   #0x64, R10
   \   00007E   0328         JNC     ??create_name_18
   \   000080   7C400600     MOV.B   #0x6, R12
   \   000084   3B3D         JMP     ??create_name_19
   \                     ??create_name_18:
   \   000086   38F0FF00     AND.W   #0xff, R8
   \   00008A   1D43         MOV.W   #0x1, R13
   \   00008C   0C48         MOV.W   R8, R12
   \   00008E   ........     CALLA   #ff_convert
   \   000092   084C         MOV.W   R12, R8
   \   000094   0893         CMP.W   #0x0, R8
   \   000096   0320         JNE     ??create_name_20
   \   000098   7C400600     MOV.B   #0x6, R12
   \   00009C   2F3D         JMP     ??create_name_19
   \                     ??create_name_20:
   \   00009E   38908000     CMP.W   #0x80, R8
   \   0000A2   0A2C         JC      ??create_name_21
   \   0000A4   0D48         MOV.W   R8, R13
   \   0000A6   ........     MOVA    #`?<Constant "\\"*:<>?|\\177">`, R12
   \   0000AA   ........     CALLA   #chk_chr
   \   0000AE   0C93         CMP.W   #0x0, R12
   \   0000B0   0324         JEQ     ??create_name_21
   \   0000B2   7C400600     MOV.B   #0x6, R12
   \   0000B6   223D         JMP     ??create_name_19
   \                     ??create_name_21:
   \   0000B8   0F4A         MOV.W   R10, R15
   \   0000BA   EF0F         ADDA    R15, R15
   \   0000BC   EF09         ADDA    R9, R15
   \   0000BE   8F480000     MOV.W   R8, 0(R15)
   \   0000C2   1A53         ADD.W   #0x1, R10
   \   0000C4   BF3F         JMP     ??create_name_1
   \                     ??create_name_17:
   \   0000C6   6B42         MOV.B   #0x4, R11
   \   0000C8   013C         JMP     ??create_name_22
   \                     ??create_name_16:
   \   0000CA   4B43         MOV.B   #0x0, R11
   1700          #if _FS_RPATH
   1701          	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
   1702          		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
   \                     ??create_name_22:
   \   0000CC   1A93         CMP.W   #0x1, R10
   \   0000CE   0820         JNE     ??create_name_23
   \   0000D0   0F4A         MOV.W   R10, R15
   \   0000D2   3F53         ADD.W   #0xffff, R15
   \   0000D4   EF0F         ADDA    R15, R15
   \   0000D6   EF09         ADDA    R9, R15
   \   0000D8   BF902E000000 CMP.W   #0x2e, 0(R15)
   \   0000DE   1324         JEQ     ??create_name_24
   \                     ??create_name_23:
   \   0000E0   2A93         CMP.W   #0x2, R10
   \   0000E2   3220         JNE     ??create_name_3
   \   0000E4   0F4A         MOV.W   R10, R15
   \   0000E6   3F53         ADD.W   #0xffff, R15
   \   0000E8   EF0F         ADDA    R15, R15
   \   0000EA   EF09         ADDA    R9, R15
   \   0000EC   BF902E000000 CMP.W   #0x2e, 0(R15)
   \   0000F2   2A20         JNE     ??create_name_3
   \   0000F4   0F4A         MOV.W   R10, R15
   \   0000F6   3F50FEFF     ADD.W   #0xfffe, R15
   \   0000FA   EF0F         ADDA    R15, R15
   \   0000FC   EF09         ADDA    R9, R15
   \   0000FE   BF902E000000 CMP.W   #0x2e, 0(R15)
   \   000104   2120         JNE     ??create_name_3
   1703          		lfn[di] = 0;
   \                     ??create_name_24:
   \   000106   0F4A         MOV.W   R10, R15
   \   000108   EF0F         ADDA    R15, R15
   \   00010A   EF09         ADDA    R9, R15
   \   00010C   8F430000     MOV.W   #0x0, 0(R15)
   1704          		for (i = 0; i < 11; i++)
   \   000110   0743         MOV.W   #0x0, R7
   \                     ??create_name_2:
   \   000112   37900B00     CMP.W   #0xb, R7
   \   000116   0E2C         JC      ??create_name_25
   1705          			dj->fn[i] = (i < di) ? '.' : ' ';
   \   000118   079A         CMP.W   R10, R7
   \   00011A   032C         JC      ??create_name_26
   \   00011C   7E402E00     MOV.B   #0x2e, R14
   \   000120   023C         JMP     ??create_name_27
   \                     ??create_name_26:
   \   000122   7E402000     MOV.B   #0x20, R14
   \                     ??create_name_27:
   \   000126   3F051800     MOVA    0x18(R5), R15
   \   00012A   EF07         ADDA    R7, R15
   \   00012C   CF4E0000     MOV.B   R14, 0(R15)
   \   000130   1753         ADD.W   #0x1, R7
   \   000132   EF3F         JMP     ??create_name_2
   1706          		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
   \                     ??create_name_25:
   \   000134   4E4B         MOV.B   R11, R14
   \   000136   7ED02000     BIS.B   #0x20, R14
   \   00013A   3F051800     MOVA    0x18(R5), R15
   \   00013E   EF07         ADDA    R7, R15
   \   000140   CF4E0000     MOV.B   R14, 0(R15)
   1707          		return FR_OK;
   \   000144   4C43         MOV.B   #0x0, R12
   \   000146   DA3C         JMP     ??create_name_19
   1708          	}
   1709          #endif
   1710          	while (di) {						/* Strip trailing spaces and dots */
   \                     ??create_name_3:
   \   000148   0A93         CMP.W   #0x0, R10
   \   00014A   0D24         JEQ     ??create_name_8
   1711          		w = lfn[di-1];
   \   00014C   0F4A         MOV.W   R10, R15
   \   00014E   3F53         ADD.W   #0xffff, R15
   \   000150   EF0F         ADDA    R15, R15
   \   000152   EF09         ADDA    R9, R15
   \   000154   284F         MOV.W   @R15, R8
   1712          		if (w != ' ' && w != '.') break;
   \   000156   38902000     CMP.W   #0x20, R8
   \   00015A   0324         JEQ     ??create_name_7
   \   00015C   38902E00     CMP.W   #0x2e, R8
   \   000160   0220         JNE     ??create_name_8
   1713          		di--;
   \                     ??create_name_7:
   \   000162   3A53         ADD.W   #0xffff, R10
   \   000164   F13F         JMP     ??create_name_3
   1714          	}
   1715          	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
   \                     ??create_name_8:
   \   000166   0A93         CMP.W   #0x0, R10
   \   000168   0320         JNE     ??create_name_28
   \   00016A   7C400600     MOV.B   #0x6, R12
   \   00016E   C63C         JMP     ??create_name_19
   1716          
   1717          	lfn[di] = 0;						/* LFN is created */
   \                     ??create_name_28:
   \   000170   0F4A         MOV.W   R10, R15
   \   000172   EF0F         ADDA    R15, R15
   \   000174   EF09         ADDA    R9, R15
   \   000176   8F430000     MOV.W   #0x0, 0(R15)
   1718          
   1719          	/* Create SFN in directory form */
   1720          	mem_set(dj->fn, ' ', 11);
   \   00017A   3E400B00     MOV.W   #0xb, R14
   \   00017E   3D402000     MOV.W   #0x20, R13
   \   000182   3C051800     MOVA    0x18(R5), R12
   \   000186   ........     CALLA   #mem_set
   1721          	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
   \   00018A   0643         MOV.W   #0x0, R6
   \                     ??create_name_4:
   \   00018C   0F46         MOV.W   R6, R15
   \   00018E   EF0F         ADDA    R15, R15
   \   000190   EF09         ADDA    R9, R15
   \   000192   BF9020000000 CMP.W   #0x20, 0(R15)
   \   000198   0724         JEQ     ??create_name_29
   \   00019A   0F46         MOV.W   R6, R15
   \   00019C   EF0F         ADDA    R15, R15
   \   00019E   EF09         ADDA    R9, R15
   \   0001A0   BF902E000000 CMP.W   #0x2e, 0(R15)
   \   0001A6   0220         JNE     ??create_name_30
   \                     ??create_name_29:
   \   0001A8   1653         ADD.W   #0x1, R6
   \   0001AA   F03F         JMP     ??create_name_4
   1722          	if (si) cf |= NS_LOSS | NS_LFN;
   \                     ??create_name_30:
   \   0001AC   0693         CMP.W   #0x0, R6
   \   0001AE   0224         JEQ     ??create_name_5
   \   0001B0   7BD00300     BIS.B   #0x3, R11
   1723          	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   \                     ??create_name_5:
   \   0001B4   0A93         CMP.W   #0x0, R10
   \   0001B6   0A24         JEQ     ??create_name_31
   \   0001B8   0F4A         MOV.W   R10, R15
   \   0001BA   3F53         ADD.W   #0xffff, R15
   \   0001BC   EF0F         ADDA    R15, R15
   \   0001BE   EF09         ADDA    R9, R15
   \   0001C0   BF902E000000 CMP.W   #0x2e, 0(R15)
   \   0001C6   0224         JEQ     ??create_name_31
   \   0001C8   3A53         ADD.W   #0xffff, R10
   \   0001CA   F43F         JMP     ??create_name_5
   1724          
   1725          	b = i = 0; ni = 8;
   \                     ??create_name_31:
   \   0001CC   0E43         MOV.W   #0x0, R14
   \   0001CE   074E         MOV.W   R14, R7
   \   0001D0   444E         MOV.B   R14, R4
   \   0001D2   B1420000     MOV.W   #0x8, 0(SP)
   1726          	for (;;) {
   1727          		w = lfn[si++];					/* Get an LFN char */
   \                     ??create_name_6:
   \   0001D6   0F46         MOV.W   R6, R15
   \   0001D8   EF0F         ADDA    R15, R15
   \   0001DA   EF09         ADDA    R9, R15
   \   0001DC   284F         MOV.W   @R15, R8
   \   0001DE   1653         ADD.W   #0x1, R6
   1728          		if (!w) break;					/* Break on end of the LFN */
   \   0001E0   0893         CMP.W   #0x0, R8
   \   0001E2   5B24         JEQ     ??create_name_10
   1729          		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
   \   0001E4   38902000     CMP.W   #0x20, R8
   \   0001E8   0524         JEQ     ??create_name_32
   \   0001EA   38902E00     CMP.W   #0x2e, R8
   \   0001EE   0520         JNE     ??create_name_33
   \   0001F0   069A         CMP.W   R10, R6
   \   0001F2   0324         JEQ     ??create_name_33
   1730          			cf |= NS_LOSS | NS_LFN; continue;
   \                     ??create_name_32:
   \   0001F4   7BD00300     BIS.B   #0x3, R11
   \   0001F8   EE3F         JMP     ??create_name_6
   1731          		}
   1732          
   1733          		if (i >= ni || si == di) {		/* Extension or end of SFN */
   \                     ??create_name_33:
   \   0001FA   2791         CMP.W   @SP, R7
   \   0001FC   022C         JC      ??create_name_34
   \   0001FE   069A         CMP.W   R10, R6
   \   000200   1520         JNE     ??create_name_35
   1734          			if (ni == 11) {				/* Long extension */
   \                     ??create_name_34:
   \   000202   B1900B000000 CMP.W   #0xb, 0(SP)
   \   000208   0320         JNE     ??create_name_36
   1735          				cf |= NS_LOSS | NS_LFN; break;
   \   00020A   7BD00300     BIS.B   #0x3, R11
   \   00020E   453C         JMP     ??create_name_10
   1736          			}
   1737          			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   \                     ??create_name_36:
   \   000210   069A         CMP.W   R10, R6
   \   000212   0224         JEQ     ??create_name_37
   \   000214   7BD00300     BIS.B   #0x3, R11
   1738          			if (si > di) break;			/* No extension */
   \                     ??create_name_37:
   \   000218   0A96         CMP.W   R6, R10
   \   00021A   3F28         JNC     ??create_name_10
   1739          			si = di; i = 8; ni = 11;	/* Enter extension section */
   \   00021C   064A         MOV.W   R10, R6
   \   00021E   3742         MOV.W   #0x8, R7
   \   000220   B1400B000000 MOV.W   #0xb, 0(SP)
   1740          			b <<= 2; continue;
   \   000226                RPT     #0x2
   \   000226   41184454     RLAX.B  R4
   \   00022A   D53F         JMP     ??create_name_6
   1741          		}
   1742          
   1743          		if (w >= 0x80) {				/* Non ASCII char */
   \                     ??create_name_35:
   \   00022C   38908000     CMP.W   #0x80, R8
   \   000230   0E28         JNC     ??create_name_38
   1744          #ifdef _EXCVT
   1745          			w = ff_convert(w, 0);		/* Unicode -> OEM code */
   \   000232   0D43         MOV.W   #0x0, R13
   \   000234   0C48         MOV.W   R8, R12
   \   000236   ........     CALLA   #ff_convert
   \   00023A   084C         MOV.W   R12, R8
   1746          			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
   \   00023C   0893         CMP.W   #0x0, R8
   \   00023E   0624         JEQ     ??create_name_39
   \   000240   385080FF     ADD.W   #0xff80, R8
   \   000244   ....5848.... MOVX.B  ??excvt(R8), R8
   \   00024A   4848         MOV.B   R8, R8
   1747          #else
   1748          			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
   1749          #endif
   1750          			cf |= NS_LFN;				/* Force create LFN entry */
   \                     ??create_name_39:
   \   00024C   6BD3         BIS.B   #0x2, R11
   1751          		}
   1752          
   1753          		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
   1754          			if (i >= ni - 1) {
   1755          				cf |= NS_LOSS | NS_LFN; i = ni; continue;
   1756          			}
   1757          			dj->fn[i++] = (BYTE)(w >> 8);
   1758          		} else {						/* Single byte char */
   1759          			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
   \                     ??create_name_38:
   \   00024E   0893         CMP.W   #0x0, R8
   \   000250   0724         JEQ     ??create_name_40
   \   000252   0D48         MOV.W   R8, R13
   \   000254   ........     MOVA    #`?<Constant "+,;=[]">`, R12
   \   000258   ........     CALLA   #chk_chr
   \   00025C   0C93         CMP.W   #0x0, R12
   \   00025E   0524         JEQ     ??create_name_41
   1760          				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
   \                     ??create_name_40:
   \   000260   38405F00     MOV.W   #0x5f, R8
   \   000264   7BD00300     BIS.B   #0x3, R11
   \   000268   113C         JMP     ??create_name_42
   1761          			} else {
   1762          				if (IsUpper(w)) {		/* ASCII large capital */
   \                     ??create_name_41:
   \   00026A   38904100     CMP.W   #0x41, R8
   \   00026E   0528         JNC     ??create_name_43
   \   000270   38905B00     CMP.W   #0x5b, R8
   \   000274   022C         JC      ??create_name_43
   1763          					b |= 2;
   \   000276   64D3         BIS.B   #0x2, R4
   \   000278   093C         JMP     ??create_name_42
   1764          				} else {
   1765          					if (IsLower(w)) {	/* ASCII small capital */
   \                     ??create_name_43:
   \   00027A   38906100     CMP.W   #0x61, R8
   \   00027E   0628         JNC     ??create_name_42
   \   000280   38907B00     CMP.W   #0x7b, R8
   \   000284   032C         JC      ??create_name_42
   1766          						b |= 1; w -= 0x20;
   \   000286   54D3         BIS.B   #0x1, R4
   \   000288   3850E0FF     ADD.W   #0xffe0, R8
   1767          					}
   1768          				}
   1769          			}
   1770          		}
   1771          		dj->fn[i++] = (BYTE)w;
   \                     ??create_name_42:
   \   00028C   3F051800     MOVA    0x18(R5), R15
   \   000290   EF07         ADDA    R7, R15
   \   000292   CF480000     MOV.B   R8, 0(R15)
   \   000296   1753         ADD.W   #0x1, R7
   \   000298   9E3F         JMP     ??create_name_6
   1772          	}
   1773          
   1774          	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
   \                     ??create_name_10:
   \   00029A   3F051800     MOVA    0x18(R5), R15
   \   00029E   FF90E5000000 CMP.B   #0xe5, 0(R15)
   \   0002A4   0520         JNE     ??create_name_44
   \   0002A6   3F051800     MOVA    0x18(R5), R15
   \   0002AA   FF4005000000 MOV.B   #0x5, 0(R15)
   1775          
   1776          	if (ni == 8) b <<= 2;
   \                     ??create_name_44:
   \   0002B0   B1920000     CMP.W   #0x8, 0(SP)
   \   0002B4   0220         JNE     ??create_name_45
   \   0002B6                RPT     #0x2
   \   0002B6   41184454     RLAX.B  R4
   1777          	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
   \                     ??create_name_45:
   \   0002BA   4E44         MOV.B   R4, R14
   \   0002BC   7EF00C00     AND.B   #0xc, R14
   \   0002C0   7E900C00     CMP.B   #0xc, R14
   \   0002C4   0624         JEQ     ??create_name_46
   \   0002C6   4E44         MOV.B   R4, R14
   \   0002C8   7EF00300     AND.B   #0x3, R14
   \   0002CC   7E900300     CMP.B   #0x3, R14
   \   0002D0   0120         JNE     ??create_name_47
   1778          		cf |= NS_LFN;
   \                     ??create_name_46:
   \   0002D2   6BD3         BIS.B   #0x2, R11
   1779          	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
   \                     ??create_name_47:
   \   0002D4   6BB3         BIT.B   #0x2, R11
   \   0002D6   0D2C         JC      ??create_name_48
   1780          		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
   \   0002D8   4E44         MOV.B   R4, R14
   \   0002DA   7EF00300     AND.B   #0x3, R14
   \   0002DE   5E93         CMP.B   #0x1, R14
   \   0002E0   0220         JNE     ??create_name_49
   \   0002E2   7BD01000     BIS.B   #0x10, R11
   1781          		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
   \                     ??create_name_49:
   \   0002E6   4E44         MOV.B   R4, R14
   \   0002E8   7EF00C00     AND.B   #0xc, R14
   \   0002EC   6E92         CMP.B   #0x4, R14
   \   0002EE   0120         JNE     ??create_name_48
   \   0002F0   7BD2         BIS.B   #0x8, R11
   1782          	}
   1783          
   1784          	dj->fn[NS] = cf;	/* SFN is created */
   \                     ??create_name_48:
   \   0002F2   3F051800     MOVA    0x18(R5), R15
   \   0002F6   CF4B0B00     MOV.B   R11, 0xb(R15)
   1785          
   1786          	return FR_OK;
   \   0002FA   4C43         MOV.B   #0x0, R12
   \                     ??create_name_19:
   \   0002FC   31500A00     ADD.W   #0xa, SP
   \   000300   7416         POPM.A  #0x8, R11
   \   000302   1001         RETA
   1787          
   1788          
   1789          #else	/* Non-LFN configuration */
   1790          	BYTE b, c, d, *sfn;
   1791          	UINT ni, si, i;
   1792          	const char *p;
   1793          
   1794          	/* Create file name in directory form */
   1795          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   1796          	sfn = dj->fn;
   1797          	mem_set(sfn, ' ', 11);
   1798          	si = i = b = 0; ni = 8;
   1799          #if _FS_RPATH
   1800          	if (p[si] == '.') { /* Is this a dot entry? */
   1801          		for (;;) {
   1802          			c = (BYTE)p[si++];
   1803          			if (c != '.' || si >= 3) break;
   1804          			sfn[i++] = c;
   1805          		}
   1806          		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
   1807          		*path = &p[si];									/* Return pointer to the next segment */
   1808          		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
   1809          		return FR_OK;
   1810          	}
   1811          #endif
   1812          	for (;;) {
   1813          		c = (BYTE)p[si++];
   1814          		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
   1815          		if (c == '.' || i >= ni) {
   1816          			if (ni != 8 || c != '.') return FR_INVALID_NAME;
   1817          			i = 8; ni = 11;
   1818          			b <<= 2; continue;
   1819          		}
   1820          		if (c >= 0x80) {				/* Extended char? */
   1821          			b |= 3;						/* Eliminate NT flag */
   1822          #ifdef _EXCVT
   1823          			c = excvt[c - 0x80];		/* Upper conversion (SBCS) */
   1824          #else
   1825          #if !_DF1S	/* ASCII only cfg */
   1826          			return FR_INVALID_NAME;
   1827          #endif
   1828          #endif
   1829          		}
   1830          		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1831          			d = (BYTE)p[si++];			/* Get 2nd byte */
   1832          			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
   1833          				return FR_INVALID_NAME;
   1834          			sfn[i++] = c;
   1835          			sfn[i++] = d;
   1836          		} else {						/* Single byte code */
   1837          			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
   1838          				return FR_INVALID_NAME;
   1839          			if (IsUpper(c)) {			/* ASCII large capital? */
   1840          				b |= 2;
   1841          			} else {
   1842          				if (IsLower(c)) {		/* ASCII small capital? */
   1843          					b |= 1; c -= 0x20;
   1844          				}
   1845          			}
   1846          			sfn[i++] = c;
   1847          		}
   1848          	}
   1849          	*path = &p[si];						/* Return pointer to the next segment */
   1850          	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   1851          
   1852          	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
   1853          	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
   1854          
   1855          	if (ni == 8) b <<= 2;
   1856          	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
   1857          	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
   1858          
   1859          	sfn[NS] = c;		/* Store NT flag, File name is created */
   1860          
   1861          	return FR_OK;
   1862          #endif
   1863          }

   \                                 In  segment DATA20_C, align 1, align-sorted
   \                     ??excvt:
   \   000000   809A90418E41 DC8 128, 154, 144, 65, 142, 65, 143, 128, 69, 69, 69, 73, 73, 73, 142
   \            8F8045454549
   \            49498E      
   \   00000F   8F9092924F99 DC8 143, 144, 146, 146, 79, 153, 79, 85, 85, 89, 153, 154, 155, 156
   \            4F555559999A
   \            9B9C        
   \   00001D   9D9E9F41494F DC8 157, 158, 159, 65, 73, 79, 85, 165, 165, 166, 167, 168, 169, 170
   \            55A5A5A6A7A8
   \            A9AA        
   \   00002B   ABAC21AEAFB0 DC8 171, 172, 33, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184
   \            B1B2B3B4B5B6
   \            B7B8        
   \   000039   B9BABBBCBDBE DC8 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197
   \            BFC0C1C2C3C4
   \            C5          
   \   000046   C6C7C8C9CACB DC8 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210
   \            CCCDCECFD0D1
   \            D2          
   \   000053   D3D4D5D6D7D8 DC8 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223
   \            D9DADBDCDDDE
   \            DF          
   \   000060   E0E1E2E3E4E5 DC8 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236
   \            E6E7E8E9EAEB
   \            EC          
   \   00006D   EDEEEFF0F1F2 DC8 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249
   \            F3F4F5F6F7F8
   \            F9          
   \   00007A   FAFBFCFDFEFF DC8 250, 251, 252, 253, 254, 255
   1864          
   1865          
   1866          
   1867          
   1868          /*-----------------------------------------------------------------------*/
   1869          /* Get file information from directory entry                             */
   1870          /*-----------------------------------------------------------------------*/
   1871          #if _FS_MINIMIZE <= 1

   \                                 In  segment CODE, align 2
   1872          static
   1873          void get_fileinfo (		/* No return code */
   \                     get_fileinfo:
   1874          	DIR *dj,			/* Pointer to the directory object */
   1875          	FILINFO *fno	 	/* Pointer to the file information to be filled */
   1876          )
   1877          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   31800600     SUB.W   #0x6, SP
   \   000006   C70C         MOVA    R12, R7
   \   000008   CA0D         MOVA    R13, R10
   1878          	UINT i;
   1879          	BYTE nt, *dir;
   1880          	TCHAR *p, c;
   1881          
   1882          
   1883          	p = fno->fname;
   \   00000A   CF0A         MOVA    R10, R15
   \   00000C   AF000900     ADDA    #0x9, R15
   \   000010   C60F         MOVA    R15, R6
   1884          	if (dj->sect) {
   \   000012   1F471000     MOV.W   0x10(R7), R15
   \   000016   1FD71200     BIS.W   0x12(R7), R15
   \   00001A   0F93         CMP.W   #0x0, R15
   \   00001C   8624         JEQ     ??get_fileinfo_7
   1885          		dir = dj->dir;
   \   00001E   3B071400     MOVA    0x14(R7), R11
   1886          		nt = dir[DIR_NTres];		/* NT flag */
   \   000022   D14B0C000000 MOV.B   0xc(R11), 0(SP)
   1887          		for (i = 0; i < 8; i++) {	/* Copy name body */
   \   000028   0943         MOV.W   #0x0, R9
   \                     ??get_fileinfo_0:
   \   00002A   3992         CMP.W   #0x8, R9
   \   00002C   1C2C         JC      ??get_fileinfo_4
   1888          			c = dir[i];
   \   00002E   CF0B         MOVA    R11, R15
   \   000030   EF09         ADDA    R9, R15
   \   000032   684F         MOV.B   @R15, R8
   1889          			if (c == ' ') break;
   \   000034   78902000     CMP.B   #0x20, R8
   \   000038   1624         JEQ     ??get_fileinfo_4
   1890          			if (c == NDDE) c = (TCHAR)DDE;
   \   00003A   78900500     CMP.B   #0x5, R8
   \   00003E   0220         JNE     ??get_fileinfo_8
   \   000040   7840E500     MOV.B   #0xe5, R8
   1891          			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
   \                     ??get_fileinfo_8:
   \   000044   F1B20000     BIT.B   #0x8, 0(SP)
   \   000048   0828         JNC     ??get_fileinfo_9
   \   00004A   78904100     CMP.B   #0x41, R8
   \   00004E   0528         JNC     ??get_fileinfo_9
   \   000050   78905B00     CMP.B   #0x5b, R8
   \   000054   022C         JC      ??get_fileinfo_9
   \   000056   78502000     ADD.B   #0x20, R8
   1892          #if _LFN_UNICODE
   1893          			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
   1894          				c = (c << 8) | dir[++i];
   1895          			c = ff_convert(c, 1);
   1896          			if (!c) c = '?';
   1897          #endif
   1898          			*p++ = c;
   \                     ??get_fileinfo_9:
   \   00005A   C6480000     MOV.B   R8, 0(R6)
   \   00005E   A6000100     ADDA    #0x1, R6
   1899          		}
   \   000062   1953         ADD.W   #0x1, R9
   \   000064   E23F         JMP     ??get_fileinfo_0
   1900          		if (dir[8] != ' ') {		/* Copy name extension */
   \                     ??get_fileinfo_4:
   \   000066   FB9020000800 CMP.B   #0x20, 0x8(R11)
   \   00006C   2124         JEQ     ??get_fileinfo_6
   1901          			*p++ = '.';
   \   00006E   F6402E000000 MOV.B   #0x2e, 0(R6)
   \   000074   A6000100     ADDA    #0x1, R6
   1902          			for (i = 8; i < 11; i++) {
   \   000078   3942         MOV.W   #0x8, R9
   \                     ??get_fileinfo_1:
   \   00007A   39900B00     CMP.W   #0xb, R9
   \   00007E   182C         JC      ??get_fileinfo_6
   1903          				c = dir[i];
   \   000080   CF0B         MOVA    R11, R15
   \   000082   EF09         ADDA    R9, R15
   \   000084   684F         MOV.B   @R15, R8
   1904          				if (c == ' ') break;
   \   000086   78902000     CMP.B   #0x20, R8
   \   00008A   1224         JEQ     ??get_fileinfo_6
   1905          				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
   \   00008C   F1B010000000 BIT.B   #0x10, 0(SP)
   \   000092   0828         JNC     ??get_fileinfo_10
   \   000094   78904100     CMP.B   #0x41, R8
   \   000098   0528         JNC     ??get_fileinfo_10
   \   00009A   78905B00     CMP.B   #0x5b, R8
   \   00009E   022C         JC      ??get_fileinfo_10
   \   0000A0   78502000     ADD.B   #0x20, R8
   1906          #if _LFN_UNICODE
   1907          				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
   1908          					c = (c << 8) | dir[++i];
   1909          				c = ff_convert(c, 1);
   1910          				if (!c) c = '?';
   1911          #endif
   1912          				*p++ = c;
   \                     ??get_fileinfo_10:
   \   0000A4   C6480000     MOV.B   R8, 0(R6)
   \   0000A8   A6000100     ADDA    #0x1, R6
   1913          			}
   \   0000AC   1953         ADD.W   #0x1, R9
   \   0000AE   E53F         JMP     ??get_fileinfo_1
   1914          		}
   1915          		fno->fattrib = dir[DIR_Attr];				/* Attribute */
   \                     ??get_fileinfo_6:
   \   0000B0   DA4B0B000800 MOV.B   0xb(R11), 0x8(R10)
   1916          		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
   \   0000B6   554B1C00     MOV.B   0x1c(R11), R5
   \   0000BA   4545         MOV.B   R5, R5
   \   0000BC   544B1D00     MOV.B   0x1d(R11), R4
   \   0000C0   4444         MOV.B   R4, R4
   \   0000C2   34F0FF00     AND.W   #0xff, R4
   \   0000C6   8410         SWPB    R4
   \   0000C8   5E4B1E00     MOV.B   0x1e(R11), R14
   \   0000CC   4E4E         MOV.B   R14, R14
   \   0000CE   0F43         MOV.W   #0x0, R15
   \   0000D0   0F4E         MOV.W   R14, R15
   \   0000D2   0E43         MOV.W   #0x0, R14
   \   0000D4   0C4E         MOV.W   R14, R12
   \   0000D6   0D4F         MOV.W   R15, R13
   \   0000D8   5E4B1F00     MOV.B   0x1f(R11), R14
   \   0000DC   4E4E         MOV.B   R14, R14
   \   0000DE   0F43         MOV.W   #0x0, R15
   \   0000E0   3EF0FF00     AND.W   #0xff, R14
   \   0000E4   8E10         SWPB    R14
   \   0000E6   0F4E         MOV.W   R14, R15
   \   0000E8   0E43         MOV.W   #0x0, R14
   \   0000EA   0EDC         BIS.W   R12, R14
   \   0000EC   0FDD         BIS.W   R13, R15
   \   0000EE   0ED4         BIS.W   R4, R14
   \   0000F0   0ED5         BIS.W   R5, R14
   \   0000F2   8A4E0000     MOV.W   R14, 0(R10)
   \   0000F6   8A4F0200     MOV.W   R15, 0x2(R10)
   1917          		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
   \   0000FA   5E4B1800     MOV.B   0x18(R11), R14
   \   0000FE   4E4E         MOV.B   R14, R14
   \   000100   5F4B1900     MOV.B   0x19(R11), R15
   \   000104   4F4F         MOV.B   R15, R15
   \   000106   3FF0FF00     AND.W   #0xff, R15
   \   00010A   8F10         SWPB    R15
   \   00010C   0FDE         BIS.W   R14, R15
   \   00010E   8A4F0400     MOV.W   R15, 0x4(R10)
   1918          		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
   \   000112   5E4B1600     MOV.B   0x16(R11), R14
   \   000116   4E4E         MOV.B   R14, R14
   \   000118   5F4B1700     MOV.B   0x17(R11), R15
   \   00011C   4F4F         MOV.B   R15, R15
   \   00011E   3FF0FF00     AND.W   #0xff, R15
   \   000122   8F10         SWPB    R15
   \   000124   0FDE         BIS.W   R14, R15
   \   000126   8A4F0600     MOV.W   R15, 0x6(R10)
   1919          	}
   1920          	*p = 0;		/* Terminate SFN str by a \0 */
   \                     ??get_fileinfo_7:
   \   00012A   C6430000     MOV.B   #0x0, 0(R6)
   1921          
   1922          #if _USE_LFN
   1923          	if (fno->lfname && fno->lfsize) {
   \   00012E   3F0A1600     MOVA    0x16(R10), R15
   \   000132   DF03         CMPA    #0x0, R15
   \   000134   3424         JEQ     ??get_fileinfo_11
   \   000136   8A931A00     CMP.W   #0x0, 0x1a(R10)
   \   00013A   3124         JEQ     ??get_fileinfo_11
   1924          		TCHAR *tp = fno->lfname;
   \   00013C   0018D14A1600 MOVX.A  0x16(R10), 0x2(SP)
   \            0200        
   1925          		WCHAR w, *lfn;
   1926          
   1927          		i = 0;
   \   000144   0943         MOV.W   #0x0, R9
   1928          		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
   \   000146   1F471000     MOV.W   0x10(R7), R15
   \   00014A   1FD71200     BIS.W   0x12(R7), R15
   \   00014E   0F93         CMP.W   #0x0, R15
   \   000150   2124         JEQ     ??get_fileinfo_12
   \   000152   B7932000     CMP.W   #0xffff, 0x20(R7)
   \   000156   1E24         JEQ     ??get_fileinfo_12
   1929          			lfn = dj->lfn;
   \   000158   34071C00     MOVA    0x1c(R7), R4
   1930          			while ((w = *lfn++) != 0) {			/* Get an LFN char */
   \                     ??get_fileinfo_2:
   \   00015C   2F44         MOV.W   @R4, R15
   \   00015E   E403         ADDA    #0x2, R4
   \   000160   054F         MOV.W   R15, R5
   \   000162   0F93         CMP.W   #0x0, R15
   \   000164   1724         JEQ     ??get_fileinfo_12
   1931          #if !_LFN_UNICODE
   1932          				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
   \   000166   0D43         MOV.W   #0x0, R13
   \   000168   0C45         MOV.W   R5, R12
   \   00016A   ........     CALLA   #ff_convert
   \   00016E   054C         MOV.W   R12, R5
   1933          				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
   \   000170   0593         CMP.W   #0x0, R5
   \   000172   0220         JNE     ??get_fileinfo_13
   \   000174   0943         MOV.W   #0x0, R9
   \   000176   0E3C         JMP     ??get_fileinfo_12
   1934          				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
   1935          					tp[i++] = (TCHAR)(w >> 8);
   1936          #endif
   1937          				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
   \                     ??get_fileinfo_13:
   \   000178   1F4A1A00     MOV.W   0x1a(R10), R15
   \   00017C   3F53         ADD.W   #0xffff, R15
   \   00017E   099F         CMP.W   R15, R9
   \   000180   0228         JNC     ??get_fileinfo_14
   \   000182   0943         MOV.W   #0x0, R9
   \   000184   073C         JMP     ??get_fileinfo_12
   1938          				tp[i++] = (TCHAR)w;
   \                     ??get_fileinfo_14:
   \   000186   3F010200     MOVA    0x2(SP), R15
   \   00018A   EF09         ADDA    R9, R15
   \   00018C   CF450000     MOV.B   R5, 0(R15)
   \   000190   1953         ADD.W   #0x1, R9
   \   000192   E43F         JMP     ??get_fileinfo_2
   1939          			}
   1940          		}
   1941          		tp[i] = 0;	/* Terminate the LFN str by a \0 */
   \                     ??get_fileinfo_12:
   \   000194   3F010200     MOVA    0x2(SP), R15
   \   000198   EF09         ADDA    R9, R15
   \   00019A   CF430000     MOV.B   #0x0, 0(R15)
   1942          	}
   1943          #endif
   1944          }
   \                     ??get_fileinfo_11:
   \   00019E   31500600     ADD.W   #0x6, SP
   \   0001A2   7416         POPM.A  #0x8, R11
   \   0001A4   1001         RETA
   1945          #endif /* _FS_MINIMIZE <= 1 */
   1946          
   1947          
   1948          
   1949          
   1950          /*-----------------------------------------------------------------------*/
   1951          /* Follow a file path                                                    */
   1952          /*-----------------------------------------------------------------------*/
   1953          

   \                                 In  segment CODE, align 2
   1954          static
   1955          FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
   \                     follow_path:
   1956          	DIR *dj,			/* Directory object to return last directory and found object */
   1957          	const TCHAR *path	/* Full-path string to find a file or directory */
   1958          )
   1959          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   0D14         PUSHM.A #0x1, R13
   \   000004   CA0C         MOVA    R12, R10
   1960          	FRESULT res;
   1961          	BYTE *dir, ns;
   1962          
   1963          
   1964          #if _FS_RPATH
   1965          	if (*path == '/' || *path == '\\') { /* There is a heading separator */
   \   000006   0F01         MOVA    @SP, R15
   \   000008   FF902F000000 CMP.B   #0x2f, 0(R15)
   \   00000E   0524         JEQ     ??follow_path_6
   \   000010   0F01         MOVA    @SP, R15
   \   000012   FF905C000000 CMP.B   #0x5c, 0(R15)
   \   000018   0A20         JNE     ??follow_path_7
   1966          		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
   \                     ??follow_path_6:
   \   00001A   0F01         MOVA    @SP, R15
   \   00001C   AF000100     ADDA    #0x1, R15
   \   000020   710F0000     MOVA    R15, 0(SP)
   \   000024   8A430800     MOV.W   #0x0, 0x8(R10)
   \   000028   8A430A00     MOV.W   #0x0, 0xa(R10)
   \   00002C   073C         JMP     ??follow_path_8
   1967          	} else {							/* No heading separator */
   1968          		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
   \                     ??follow_path_7:
   \   00002E   0F0A         MOVA    @R10, R15
   \   000030   9A4F16000800 MOV.W   0x16(R15), 0x8(R10)
   \   000036   9A4F18000A00 MOV.W   0x18(R15), 0xa(R10)
   1969          	}
   1970          #else
   1971          	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
   1972          		path++;
   1973          	dj->sclust = 0;						/* Start from the root dir */
   1974          #endif
   1975          
   1976          	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
   \                     ??follow_path_8:
   \   00003C   0F01         MOVA    @SP, R15
   \   00003E   FF9020000000 CMP.B   #0x20, 0(R15)
   \   000044   092C         JC      ??follow_path_0
   1977          		res = dir_sdi(dj, 0);
   \   000046   0D43         MOV.W   #0x0, R13
   \   000048   CC0A         MOVA    R10, R12
   \   00004A   ........     CALLA   #dir_sdi
   \   00004E   4B4C         MOV.B   R12, R11
   1978          		dj->dir = 0;
   \   000050   0018CA431400 MOVX.A  #0x0, 0x14(R10)
   \   000056   3B3C         JMP     ??follow_path_2
   1979          	} else {							/* Follow path */
   1980          		for (;;) {
   1981          			res = create_name(dj, &path);	/* Get a segment */
   \                     ??follow_path_0:
   \   000058   0D41         MOV.W   SP, R13
   \   00005A   0D53         ADD.W   #0x0, R13
   \   00005C   CC0A         MOVA    R10, R12
   \   00005E   ........     CALLA   #create_name
   \   000062   4B4C         MOV.B   R12, R11
   1982          			if (res != FR_OK) break;
   \   000064   4B93         CMP.B   #0x0, R11
   \   000066   3320         JNE     ??follow_path_2
   1983          			res = dir_find(dj);				/* Find it */
   \   000068   CC0A         MOVA    R10, R12
   \   00006A   ........     CALLA   #dir_find
   \   00006E   4B4C         MOV.B   R12, R11
   1984          			ns = *(dj->fn+NS);
   \   000070   3F0A1800     MOVA    0x18(R10), R15
   \   000074   594F0B00     MOV.B   0xb(R15), R9
   1985          			if (res != FR_OK) {				/* Failed to find the object */
   \   000078   4B93         CMP.B   #0x0, R11
   \   00007A   1524         JEQ     ??follow_path_9
   1986          				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
   \   00007C   6B92         CMP.B   #0x4, R11
   \   00007E   2720         JNE     ??follow_path_2
   1987          				/* Object not found */
   1988          				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
   \   000080   79B02000     BIT.B   #0x20, R9
   \   000084   0B28         JNC     ??follow_path_10
   1989          					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
   \   000086   8A430800     MOV.W   #0x0, 0x8(R10)
   \   00008A   8A430A00     MOV.W   #0x0, 0xa(R10)
   \   00008E   0018CA431400 MOVX.A  #0x0, 0x14(R10)
   1990          					res = FR_OK;
   \   000094   4B43         MOV.B   #0x0, R11
   1991          					if (!(ns & NS_LAST)) continue;
   \   000096   69B2         BIT.B   #0x4, R9
   \   000098   1A2C         JC      ??follow_path_2
   \   00009A   DE3F         JMP     ??follow_path_0
   1992          				} else {							/* Could not find the object */
   1993          					if (!(ns & NS_LAST)) res = FR_NO_PATH;
   \                     ??follow_path_10:
   \   00009C   69B2         BIT.B   #0x4, R9
   \   00009E   172C         JC      ??follow_path_2
   \   0000A0   7B400500     MOV.B   #0x5, R11
   1994          				}
   1995          				break;
   \   0000A4   143C         JMP     ??follow_path_2
   1996          			}
   1997          			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
   \                     ??follow_path_9:
   \   0000A6   69B2         BIT.B   #0x4, R9
   \   0000A8   122C         JC      ??follow_path_2
   1998          			dir = dj->dir;						/* There is next segment. Follow the sub directory */
   \   0000AA   380A1400     MOVA    0x14(R10), R8
   1999          			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
   \   0000AE   F8B010000B00 BIT.B   #0x10, 0xb(R8)
   \   0000B4   032C         JC      ??follow_path_11
   2000          				res = FR_NO_PATH; break;
   \   0000B6   7B400500     MOV.B   #0x5, R11
   \   0000BA   093C         JMP     ??follow_path_2
   2001          			}
   2002          			dj->sclust = ld_clust(dj->fs, dir);
   \                     ??follow_path_11:
   \   0000BC   CD08         MOVA    R8, R13
   \   0000BE   0C0A         MOVA    @R10, R12
   \   0000C0   ........     CALLA   #ld_clust
   \   0000C4   8A4C0800     MOV.W   R12, 0x8(R10)
   \   0000C8   8A4D0A00     MOV.W   R13, 0xa(R10)
   \   0000CC   C53F         JMP     ??follow_path_0
   2003          		}
   2004          	}
   2005          
   2006          	return res;
   \                     ??follow_path_2:
   \   0000CE   4C4B         MOV.B   R11, R12
   \   0000D0   2152         ADD.W   #0x4, SP
   \   0000D2   3816         POPM.A  #0x4, R11
   \   0000D4   1001         RETA
   2007          }
   2008          
   2009          
   2010          
   2011          
   2012          /*-----------------------------------------------------------------------*/
   2013          /* Load a sector and check if it is an FAT Volume Boot Record            */
   2014          /*-----------------------------------------------------------------------*/
   2015          

   \                                 In  segment CODE, align 2
   2016          static
   2017          BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
   \                     check_fs:
   2018          	FATFS *fs,	/* File system object */
   2019          	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
   2020          )
   2021          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   C80C         MOVA    R12, R8
   \   000004   0A4E         MOV.W   R14, R10
   \   000006   0B4F         MOV.W   R15, R11
   2022          	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
   \   000008   5312         PUSH.B  #0x1
   \   00000A   0E4A         MOV.W   R10, R14
   \   00000C   0F4B         MOV.W   R11, R15
   \   00000E   CD08         MOVA    R8, R13
   \   000010   AD003200     ADDA    #0x32, R13
   \   000014   5C480100     MOV.B   0x1(R8), R12
   \   000018   ........     CALLA   #disk_read
   \   00001C   2153         ADD.W   #0x2, SP
   \   00001E   4C93         CMP.B   #0x0, R12
   \   000020   0324         JEQ     ??check_fs_0
   2023          		return 3;
   \   000022   7C400300     MOV.B   #0x3, R12
   \   000026   3A3C         JMP     ??check_fs_1
   2024          	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
   \                     ??check_fs_0:
   \   000028   5E483002     MOV.B   0x230(R8), R14
   \   00002C   4E4E         MOV.B   R14, R14
   \   00002E   5F483102     MOV.B   0x231(R8), R15
   \   000032   4F4F         MOV.B   R15, R15
   \   000034   3FF0FF00     AND.W   #0xff, R15
   \   000038   8F10         SWPB    R15
   \   00003A   0FDE         BIS.W   R14, R15
   \   00003C   3F9055AA     CMP.W   #0xaa55, R15
   \   000040   0224         JEQ     ??check_fs_2
   2025          		return 2;
   \   000042   6C43         MOV.B   #0x2, R12
   \   000044   2B3C         JMP     ??check_fs_1
   2026          
   2027          	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
   \                     ??check_fs_2:
   \   000046   5D486800     MOV.B   0x68(R8), R13
   \   00004A   4D4D         MOV.B   R13, R13
   \   00004C   5E486900     MOV.B   0x69(R8), R14
   \   000050   4E4E         MOV.B   R14, R14
   \   000052   3EF0FF00     AND.W   #0xff, R14
   \   000056   8E10         SWPB    R14
   \   000058   5F486A00     MOV.B   0x6a(R8), R15
   \   00005C   4F4F         MOV.B   R15, R15
   \   00005E   0EDD         BIS.W   R13, R14
   \   000060   3E904641     CMP.W   #0x4146, R14
   \   000064   0520         JNE     ??check_fs_3
   \   000066   3F905400     CMP.W   #0x54, R15
   \   00006A   0220         JNE     ??check_fs_3
   2028          		return 0;
   \   00006C   4C43         MOV.B   #0x0, R12
   \   00006E   163C         JMP     ??check_fs_1
   2029          	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
   \                     ??check_fs_3:
   \   000070   5D488400     MOV.B   0x84(R8), R13
   \   000074   4D4D         MOV.B   R13, R13
   \   000076   5E488500     MOV.B   0x85(R8), R14
   \   00007A   4E4E         MOV.B   R14, R14
   \   00007C   3EF0FF00     AND.W   #0xff, R14
   \   000080   8E10         SWPB    R14
   \   000082   5F488600     MOV.B   0x86(R8), R15
   \   000086   4F4F         MOV.B   R15, R15
   \   000088   0EDD         BIS.W   R13, R14
   \   00008A   3E904641     CMP.W   #0x4146, R14
   \   00008E   0520         JNE     ??check_fs_4
   \   000090   3F905400     CMP.W   #0x54, R15
   \   000094   0220         JNE     ??check_fs_4
   2030          		return 0;
   \   000096   4C43         MOV.B   #0x0, R12
   \   000098   013C         JMP     ??check_fs_1
   2031          
   2032          	return 1;
   \                     ??check_fs_4:
   \   00009A   5C43         MOV.B   #0x1, R12
   \                     ??check_fs_1:
   \   00009C   3816         POPM.A  #0x4, R11
   \   00009E   1001         RETA
   2033          }
   2034          
   2035          
   2036          
   2037          
   2038          /*-----------------------------------------------------------------------*/
   2039          /* Check if the file system object is valid or not                       */
   2040          /*-----------------------------------------------------------------------*/
   2041          

   \                                 In  segment CODE, align 2
   2042          static
   2043          FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
   \                     chk_mounted:
   2044          	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
   2045          	FATFS **rfs,		/* Pointer to pointer to the found file system object */
   2046          	BYTE wmode			/* !=0: Check write protection for write access */
   2047          )
   2048          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   0C14         PUSHM.A #0x1, R12
   \   000004   0D14         PUSHM.A #0x1, R13
   \   000006   4E12         PUSH.B  R14
   \   000008   31801A00     SUB.W   #0x1a, SP
   2049          	BYTE fmt, b, pi, *tbl;
   2050          	UINT vol;
   2051          	DSTATUS stat;
   2052          	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
   2053          	WORD nrsv;
   2054          	const TCHAR *p = *path;
   \   00000C   3F012000     MOVA    0x20(SP), R15
   \   000010   0018E14F0600 MOVX.A  @R15, 0x6(SP)
   2055          	FATFS *fs;
   2056          
   2057          
   2058          	/* Get logical drive number from the path name */
   2059          	vol = p[0] - '0';					/* Is there a drive number? */
   \   000016   3F010600     MOVA    0x6(SP), R15
   \   00001A   6F4F         MOV.B   @R15, R15
   \   00001C   4F4F         MOV.B   R15, R15
   \   00001E   3F50D0FF     ADD.W   #0xffd0, R15
   \   000022   814F0200     MOV.W   R15, 0x2(SP)
   2060          	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
   \   000026   B1900A000200 CMP.W   #0xa, 0x2(SP)
   \   00002C   122C         JC      ??chk_mounted_0
   \   00002E   3F010600     MOVA    0x6(SP), R15
   \   000032   FF903A000100 CMP.B   #0x3a, 0x1(R15)
   \   000038   0C20         JNE     ??chk_mounted_0
   2061          		p += 2; *path = p;				/* Return pointer to the path name */
   \   00003A   3F010600     MOVA    0x6(SP), R15
   \   00003E   EF03         ADDA    #0x2, R15
   \   000040   710F0600     MOVA    R15, 0x6(SP)
   \   000044   3F010600     MOVA    0x6(SP), R15
   \   000048   3E012000     MOVA    0x20(SP), R14
   \   00004C   7E0F0000     MOVA    R15, 0(R14)
   \   000050   063C         JMP     ??chk_mounted_1
   2062          	} else {							/* No drive number is given */
   2063          #if _FS_RPATH
   2064          		vol = CurrVol;					/* Use current drive */
   \                     ??chk_mounted_0:
   \   000052   ....5F42.... MOVX.B  &CurrVol, R15
   \   000058   4F4F         MOV.B   R15, R15
   \   00005A   814F0200     MOV.W   R15, 0x2(SP)
   2065          #else
   2066          		vol = 0;						/* Use drive 0 */
   2067          #endif
   2068          	}
   2069          
   2070          	/* Check if the file system object is valid or not */
   2071          	*rfs = 0;
   \                     ??chk_mounted_1:
   \   00005E   3F011C00     MOVA    0x1c(SP), R15
   \   000062   0018CF430000 MOVX.A  #0x0, 0(R15)
   2072          	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
   \   000068   81930200     CMP.W   #0x0, 0x2(SP)
   \   00006C   0424         JEQ     ??chk_mounted_2
   2073          		return FR_INVALID_DRIVE;
   \   00006E   7C400B00     MOV.B   #0xb, R12
   \   000072   ........     BRA     #??chk_mounted_3
   2074          	fs = FatFs[vol];					/* Get corresponding file system object */
   \                     ??chk_mounted_2:
   \   000076   1F410200     MOV.W   0x2(SP), R15
   \   00007A   4F06         RLAM.A  #0x2, R15
   \   00007C   ....5A4F.... MOVX.A  FatFs(R15), R10
   2075          	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   \   000082   DA03         CMPA    #0x0, R10
   \   000084   0420         JNE     ??chk_mounted_4
   \   000086   7C400C00     MOV.B   #0xc, R12
   \   00008A   ........     BRA     #??chk_mounted_3
   2076          
   2077          	ENTER_FF(fs);						/* Lock file system */
   2078          
   2079          	*rfs = fs;							/* Return pointer to the corresponding file system object */
   \                     ??chk_mounted_4:
   \   00008E   3F011C00     MOVA    0x1c(SP), R15
   \   000092   7F0A0000     MOVA    R10, 0(R15)
   2080          	if (fs->fs_type) {					/* If the volume has been mounted */
   \   000096   CA930000     CMP.B   #0x0, 0(R10)
   \   00009A   1624         JEQ     ??chk_mounted_5
   2081          		stat = disk_status(fs->drv);
   \   00009C   5C4A0100     MOV.B   0x1(R10), R12
   \   0000A0   ........     CALLA   #disk_status
   \   0000A4   C14C0000     MOV.B   R12, 0(SP)
   2082          		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
   \   0000A8   D1B30000     BIT.B   #0x1, 0(SP)
   \   0000AC   0D2C         JC      ??chk_mounted_5
   2083          			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
   \   0000AE   C1931A00     CMP.B   #0x0, 0x1a(SP)
   \   0000B2   0724         JEQ     ??chk_mounted_6
   \   0000B4   E1B20000     BIT.B   #0x4, 0(SP)
   \   0000B8   0428         JNC     ??chk_mounted_6
   2084          				return FR_WRITE_PROTECTED;
   \   0000BA   7C400A00     MOV.B   #0xa, R12
   \   0000BE   ........     BRA     #??chk_mounted_3
   2085          			return FR_OK;				/* The file system object is valid */
   \                     ??chk_mounted_6:
   \   0000C2   4C43         MOV.B   #0x0, R12
   \   0000C4   ........     BRA     #??chk_mounted_3
   2086          		}
   2087          	}
   2088          
   2089          	/* The file system object is not valid. */
   2090          	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
   2091          
   2092          	fs->fs_type = 0;					/* Clear the file system object */
   \                     ??chk_mounted_5:
   \   0000C8   CA430000     MOV.B   #0x0, 0(R10)
   2093          	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
   \   0000CC   DA4102000100 MOV.B   0x2(SP), 0x1(R10)
   2094          	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
   \   0000D2   5C4A0100     MOV.B   0x1(R10), R12
   \   0000D6   ........     CALLA   #disk_initialize
   \   0000DA   C14C0000     MOV.B   R12, 0(SP)
   2095          	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
   \   0000DE   D1B30000     BIT.B   #0x1, 0(SP)
   \   0000E2   0428         JNC     ??chk_mounted_7
   2096          		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
   \   0000E4   7C400300     MOV.B   #0x3, R12
   \   0000E8   ........     BRA     #??chk_mounted_3
   2097          	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
   \                     ??chk_mounted_7:
   \   0000EC   C1931A00     CMP.B   #0x0, 0x1a(SP)
   \   0000F0   0724         JEQ     ??chk_mounted_8
   \   0000F2   E1B20000     BIT.B   #0x4, 0(SP)
   \   0000F6   0428         JNC     ??chk_mounted_8
   2098          		return FR_WRITE_PROTECTED;
   \   0000F8   7C400A00     MOV.B   #0xa, R12
   \   0000FC   ........     BRA     #??chk_mounted_3
   2099          #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
   2100          	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
   2101          		return FR_DISK_ERR;
   2102          #endif
   2103          	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
   2104          	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
   \                     ??chk_mounted_8:
   \   000100   0E43         MOV.W   #0x0, R14
   \   000102   0F43         MOV.W   #0x0, R15
   \   000104   064E         MOV.W   R14, R6
   \   000106   074F         MOV.W   R15, R7
   \   000108   CC0A         MOVA    R10, R12
   \   00010A   ........     CALLA   #check_fs
   \   00010E   4B4C         MOV.B   R12, R11
   2105          	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
   2106          	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
   \   000110   5B93         CMP.B   #0x1, R11
   \   000112   4720         JNE     ??chk_mounted_9
   2107          		/* Check the partition listed in the partition table */
   2108          		pi = LD2PT(vol);
   \   000114   C1430100     MOV.B   #0x0, 0x1(SP)
   2109          		if (pi) pi--;
   \   000118   C1930100     CMP.B   #0x0, 0x1(SP)
   \   00011C   0524         JEQ     ??chk_mounted_10
   \   00011E   5E410100     MOV.B   0x1(SP), R14
   \   000122   7E53         ADD.B   #0xff, R14
   \   000124   C14E0100     MOV.B   R14, 0x1(SP)
   2110          		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
   \                     ??chk_mounted_10:
   \   000128   5F410100     MOV.B   0x1(SP), R15
   \   00012C   4F4F         MOV.B   R15, R15
   \   00012E   5F0E         RLAM.W  #0x4, R15
   \   000130   3F50BE01     ADD.W   #0x1be, R15
   \   000134   0E4F         MOV.W   R15, R14
   \   000136   3EE00080     XOR.W   #0x8000, R14
   \   00013A   BE000080     SUBA    #0x8000, R14
   \   00013E   CF0A         MOVA    R10, R15
   \   000140   EF0E         ADDA    R14, R15
   \   000142   AF003200     ADDA    #0x32, R15
   \   000146   C40F         MOVA    R15, R4
   2111          		if (tbl[4]) {						/* Is the partition existing? */
   \   000148   C4930400     CMP.B   #0x0, 0x4(R4)
   \   00014C   2A24         JEQ     ??chk_mounted_9
   2112          			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
   \   00014E   5F440800     MOV.B   0x8(R4), R15
   \   000152   4F4F         MOV.B   R15, R15
   \   000154   0F12         PUSH.W  R15
   \   000156   5F440900     MOV.B   0x9(R4), R15
   \   00015A   4F4F         MOV.B   R15, R15
   \   00015C   3FF0FF00     AND.W   #0xff, R15
   \   000160   8F10         SWPB    R15
   \   000162   0F12         PUSH.W  R15
   \   000164   5E440A00     MOV.B   0xa(R4), R14
   \   000168   4E4E         MOV.B   R14, R14
   \   00016A   0F43         MOV.W   #0x0, R15
   \   00016C   0F4E         MOV.W   R14, R15
   \   00016E   0E43         MOV.W   #0x0, R14
   \   000170   0C4E         MOV.W   R14, R12
   \   000172   0D4F         MOV.W   R15, R13
   \   000174   5E440B00     MOV.B   0xb(R4), R14
   \   000178   4E4E         MOV.B   R14, R14
   \   00017A   0F43         MOV.W   #0x0, R15
   \   00017C   3EF0FF00     AND.W   #0xff, R14
   \   000180   8E10         SWPB    R14
   \   000182   0F4E         MOV.W   R14, R15
   \   000184   0E43         MOV.W   #0x0, R14
   \   000186   0EDC         BIS.W   R12, R14
   \   000188   0FDD         BIS.W   R13, R15
   \   00018A   3D41         POP.W   R13
   \   00018C   0EDD         BIS.W   R13, R14
   \   00018E   3D41         POP.W   R13
   \   000190   0EDD         BIS.W   R13, R14
   \   000192   064E         MOV.W   R14, R6
   \   000194   074F         MOV.W   R15, R7
   2113          			fmt = check_fs(fs, bsect);		/* Check the partition */
   \   000196   0E46         MOV.W   R6, R14
   \   000198   0F47         MOV.W   R7, R15
   \   00019A   CC0A         MOVA    R10, R12
   \   00019C   ........     CALLA   #check_fs
   \   0001A0   4B4C         MOV.B   R12, R11
   2114          		}
   2115          	}
   2116          	if (fmt == 3) return FR_DISK_ERR;
   \                     ??chk_mounted_9:
   \   0001A2   7B900300     CMP.B   #0x3, R11
   \   0001A6   0320         JNE     ??chk_mounted_11
   \   0001A8   5C43         MOV.B   #0x1, R12
   \   0001AA   ........     BRA     #??chk_mounted_3
   2117          	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
   \                     ??chk_mounted_11:
   \   0001AE   4B93         CMP.B   #0x0, R11
   \   0001B0   0424         JEQ     ??chk_mounted_12
   \   0001B2   7C400D00     MOV.B   #0xd, R12
   \   0001B6   ........     BRA     #??chk_mounted_3
   2118          
   2119          	/* An FAT volume is found. Following code initializes the file system object */
   2120          
   2121          	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
   \                     ??chk_mounted_12:
   \   0001BA   5E4A3D00     MOV.B   0x3d(R10), R14
   \   0001BE   4E4E         MOV.B   R14, R14
   \   0001C0   5F4A3E00     MOV.B   0x3e(R10), R15
   \   0001C4   4F4F         MOV.B   R15, R15
   \   0001C6   3FF0FF00     AND.W   #0xff, R15
   \   0001CA   8F10         SWPB    R15
   \   0001CC   0FDE         BIS.W   R14, R15
   \   0001CE   3F900002     CMP.W   #0x200, R15
   \   0001D2   0424         JEQ     ??chk_mounted_13
   2122          		return FR_NO_FILESYSTEM;
   \   0001D4   7C400D00     MOV.B   #0xd, R12
   \   0001D8   ........     BRA     #??chk_mounted_3
   2123          
   2124          	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
   \                     ??chk_mounted_13:
   \   0001DC   5F4A4800     MOV.B   0x48(R10), R15
   \   0001E0   4F4F         MOV.B   R15, R15
   \   0001E2   5E4A4900     MOV.B   0x49(R10), R14
   \   0001E6   4E4E         MOV.B   R14, R14
   \   0001E8   3EF0FF00     AND.W   #0xff, R14
   \   0001EC   8E10         SWPB    R14
   \   0001EE   0EDF         BIS.W   R15, R14
   \   0001F0   0F43         MOV.W   #0x0, R15
   \   0001F2   084E         MOV.W   R14, R8
   \   0001F4   094F         MOV.W   R15, R9
   2125          	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
   \   0001F6   0F48         MOV.W   R8, R15
   \   0001F8   0FD9         BIS.W   R9, R15
   \   0001FA   0F93         CMP.W   #0x0, R15
   \   0001FC   2420         JNE     ??chk_mounted_14
   \   0001FE   5F4A5600     MOV.B   0x56(R10), R15
   \   000202   4F4F         MOV.B   R15, R15
   \   000204   0F12         PUSH.W  R15
   \   000206   5F4A5700     MOV.B   0x57(R10), R15
   \   00020A   4F4F         MOV.B   R15, R15
   \   00020C   3FF0FF00     AND.W   #0xff, R15
   \   000210   8F10         SWPB    R15
   \   000212   0F12         PUSH.W  R15
   \   000214   5E4A5800     MOV.B   0x58(R10), R14
   \   000218   4E4E         MOV.B   R14, R14
   \   00021A   0F43         MOV.W   #0x0, R15
   \   00021C   0F4E         MOV.W   R14, R15
   \   00021E   0E43         MOV.W   #0x0, R14
   \   000220   0C4E         MOV.W   R14, R12
   \   000222   0D4F         MOV.W   R15, R13
   \   000224   5E4A5900     MOV.B   0x59(R10), R14
   \   000228   4E4E         MOV.B   R14, R14
   \   00022A   0F43         MOV.W   #0x0, R15
   \   00022C   3EF0FF00     AND.W   #0xff, R14
   \   000230   8E10         SWPB    R14
   \   000232   0F4E         MOV.W   R14, R15
   \   000234   0E43         MOV.W   #0x0, R14
   \   000236   0EDC         BIS.W   R12, R14
   \   000238   0FDD         BIS.W   R13, R15
   \   00023A   3D41         POP.W   R13
   \   00023C   0EDD         BIS.W   R13, R14
   \   00023E   3D41         POP.W   R13
   \   000240   0EDD         BIS.W   R13, R14
   \   000242   084E         MOV.W   R14, R8
   \   000244   094F         MOV.W   R15, R9
   2126          	fs->fsize = fasize;
   \                     ??chk_mounted_14:
   \   000246   8A481E00     MOV.W   R8, 0x1e(R10)
   \   00024A   8A492000     MOV.W   R9, 0x20(R10)
   2127          
   2128          	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
   \   00024E   5E4A4200     MOV.B   0x42(R10), R14
   \   000252   454E         MOV.B   R14, R5
   \   000254   CA4E0300     MOV.B   R14, 0x3(R10)
   2129          	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
   \   000258   5593         CMP.B   #0x1, R5
   \   00025A   0624         JEQ     ??chk_mounted_15
   \   00025C   6593         CMP.B   #0x2, R5
   \   00025E   0424         JEQ     ??chk_mounted_15
   \   000260   7C400D00     MOV.B   #0xd, R12
   \   000264   ........     BRA     #??chk_mounted_3
   2130          	fasize *= b;										/* Number of sectors for FAT area */
   \                     ??chk_mounted_15:
   \   000268   0C48         MOV.W   R8, R12
   \   00026A   0D49         MOV.W   R9, R13
   \   00026C   4E45         MOV.B   R5, R14
   \   00026E   0F43         MOV.W   #0x0, R15
   \   000270   ........     CALLA   #?Mul32
   \   000274   084C         MOV.W   R12, R8
   \   000276   094D         MOV.W   R13, R9
   2131          
   2132          	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
   \   000278   5E4A3F00     MOV.B   0x3f(R10), R14
   \   00027C   454E         MOV.B   R14, R5
   \   00027E   CA4E0200     MOV.B   R14, 0x2(R10)
   2133          	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
   \   000282   4593         CMP.B   #0x0, R5
   \   000284   0424         JEQ     ??chk_mounted_16
   \   000286   4E45         MOV.B   R5, R14
   \   000288   7E53         ADD.B   #0xff, R14
   \   00028A   45BE         BIT.B   R14, R5
   \   00028C   0424         JEQ     ??chk_mounted_17
   \                     ??chk_mounted_16:
   \   00028E   7C400D00     MOV.B   #0xd, R12
   \   000292   ........     BRA     #??chk_mounted_3
   2134          
   2135          	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
   \                     ??chk_mounted_17:
   \   000296   5E4A4300     MOV.B   0x43(R10), R14
   \   00029A   4E4E         MOV.B   R14, R14
   \   00029C   5F4A4400     MOV.B   0x44(R10), R15
   \   0002A0   4F4F         MOV.B   R15, R15
   \   0002A2   3FF0FF00     AND.W   #0xff, R15
   \   0002A6   8F10         SWPB    R15
   \   0002A8   0FDE         BIS.W   R14, R15
   \   0002AA   8A4F0800     MOV.W   R15, 0x8(R10)
   2136          	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
   \   0002AE   1C4A0800     MOV.W   0x8(R10), R12
   \   0002B2   3E401000     MOV.W   #0x10, R14
   \   0002B6   ........     CALLA   #?DivMod16u
   \   0002BA   0E93         CMP.W   #0x0, R14
   \   0002BC   0424         JEQ     ??chk_mounted_18
   \   0002BE   7C400D00     MOV.B   #0xd, R12
   \   0002C2   ........     BRA     #??chk_mounted_3
   2137          
   2138          	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
   \                     ??chk_mounted_18:
   \   0002C6   5F4A4500     MOV.B   0x45(R10), R15
   \   0002CA   4F4F         MOV.B   R15, R15
   \   0002CC   5E4A4600     MOV.B   0x46(R10), R14
   \   0002D0   4E4E         MOV.B   R14, R14
   \   0002D2   3EF0FF00     AND.W   #0xff, R14
   \   0002D6   8E10         SWPB    R14
   \   0002D8   0EDF         BIS.W   R15, R14
   \   0002DA   0F43         MOV.W   #0x0, R15
   \   0002DC   814E0E00     MOV.W   R14, 0xe(SP)
   \   0002E0   814F1000     MOV.W   R15, 0x10(SP)
   2139          	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
   \   0002E4   1F410E00     MOV.W   0xe(SP), R15
   \   0002E8   1FD11000     BIS.W   0x10(SP), R15
   \   0002EC   0F93         CMP.W   #0x0, R15
   \   0002EE   2620         JNE     ??chk_mounted_19
   \   0002F0   5F4A5200     MOV.B   0x52(R10), R15
   \   0002F4   4F4F         MOV.B   R15, R15
   \   0002F6   0F12         PUSH.W  R15
   \   0002F8   5F4A5300     MOV.B   0x53(R10), R15
   \   0002FC   4F4F         MOV.B   R15, R15
   \   0002FE   3FF0FF00     AND.W   #0xff, R15
   \   000302   8F10         SWPB    R15
   \   000304   0F12         PUSH.W  R15
   \   000306   5E4A5400     MOV.B   0x54(R10), R14
   \   00030A   4E4E         MOV.B   R14, R14
   \   00030C   0F43         MOV.W   #0x0, R15
   \   00030E   0F4E         MOV.W   R14, R15
   \   000310   0E43         MOV.W   #0x0, R14
   \   000312   0C4E         MOV.W   R14, R12
   \   000314   0D4F         MOV.W   R15, R13
   \   000316   5E4A5500     MOV.B   0x55(R10), R14
   \   00031A   4E4E         MOV.B   R14, R14
   \   00031C   0F43         MOV.W   #0x0, R15
   \   00031E   3EF0FF00     AND.W   #0xff, R14
   \   000322   8E10         SWPB    R14
   \   000324   0F4E         MOV.W   R14, R15
   \   000326   0E43         MOV.W   #0x0, R14
   \   000328   0EDC         BIS.W   R12, R14
   \   00032A   0FDD         BIS.W   R13, R15
   \   00032C   3D41         POP.W   R13
   \   00032E   0EDD         BIS.W   R13, R14
   \   000330   3D41         POP.W   R13
   \   000332   0EDD         BIS.W   R13, R14
   \   000334   814E0E00     MOV.W   R14, 0xe(SP)
   \   000338   814F1000     MOV.W   R15, 0x10(SP)
   2140          
   2141          	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
   \                     ??chk_mounted_19:
   \   00033C   5E4A4000     MOV.B   0x40(R10), R14
   \   000340   4E4E         MOV.B   R14, R14
   \   000342   5F4A4100     MOV.B   0x41(R10), R15
   \   000346   4F4F         MOV.B   R15, R15
   \   000348   3FF0FF00     AND.W   #0xff, R15
   \   00034C   8F10         SWPB    R15
   \   00034E   0FDE         BIS.W   R14, R15
   \   000350   814F0400     MOV.W   R15, 0x4(SP)
   2142          	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
   \   000354   81930400     CMP.W   #0x0, 0x4(SP)
   \   000358   0320         JNE     ??chk_mounted_20
   \   00035A   7C400D00     MOV.B   #0xd, R12
   \   00035E   DE3D         JMP     ??chk_mounted_3
   2143          
   2144          	/* Determine the FAT sub type */
   2145          	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
   \                     ??chk_mounted_20:
   \   000360   1E410400     MOV.W   0x4(SP), R14
   \   000364   0F43         MOV.W   #0x0, R15
   \   000366   0E58         ADD.W   R8, R14
   \   000368   0F69         ADDC.W  R9, R15
   \   00036A   0C4E         MOV.W   R14, R12
   \   00036C   0D4F         MOV.W   R15, R13
   \   00036E   1E4A0800     MOV.W   0x8(R10), R14
   \   000372   5E0F         RRUM.W  #0x4, R14
   \   000374   0F43         MOV.W   #0x0, R15
   \   000376   0C5E         ADD.W   R14, R12
   \   000378   0D6F         ADDC.W  R15, R13
   \   00037A   814C1600     MOV.W   R12, 0x16(SP)
   \   00037E   814D1800     MOV.W   R13, 0x18(SP)
   2146          	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   \   000382   919118001000 CMP.W   0x18(SP), 0x10(SP)
   \   000388   0528         JNC     ??chk_mounted_21
   \   00038A   0720         JNE     ??chk_mounted_22
   \   00038C   919116000E00 CMP.W   0x16(SP), 0xe(SP)
   \   000392   032C         JC      ??chk_mounted_22
   \                     ??chk_mounted_21:
   \   000394   7C400D00     MOV.B   #0xd, R12
   \   000398   C13D         JMP     ??chk_mounted_3
   2147          	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
   \                     ??chk_mounted_22:
   \   00039A   1C410E00     MOV.W   0xe(SP), R12
   \   00039E   1D411000     MOV.W   0x10(SP), R13
   \   0003A2   1C811600     SUB.W   0x16(SP), R12
   \   0003A6   1D711800     SUBC.W  0x18(SP), R13
   \   0003AA   5E4A0200     MOV.B   0x2(R10), R14
   \   0003AE   4E4E         MOV.B   R14, R14
   \   0003B0   0F43         MOV.W   #0x0, R15
   \   0003B2   ........     CALLA   #?DivMod32u
   \   0003B6   814C0A00     MOV.W   R12, 0xa(SP)
   \   0003BA   814D0C00     MOV.W   R13, 0xc(SP)
   2148          	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
   \   0003BE   1F410A00     MOV.W   0xa(SP), R15
   \   0003C2   1FD10C00     BIS.W   0xc(SP), R15
   \   0003C6   0F93         CMP.W   #0x0, R15
   \   0003C8   0320         JNE     ??chk_mounted_23
   \   0003CA   7C400D00     MOV.B   #0xd, R12
   \   0003CE   A63D         JMP     ??chk_mounted_3
   2149          	fmt = FS_FAT12;
   \                     ??chk_mounted_23:
   \   0003D0   5B43         MOV.B   #0x1, R11
   2150          	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   \   0003D2   81930C00     CMP.W   #0x0, 0xc(SP)
   \   0003D6   0628         JNC     ??chk_mounted_24
   \   0003D8   0420         JNE     ??chk_mounted_25
   \   0003DA   B190F60F0A00 CMP.W   #0xff6, 0xa(SP)
   \   0003E0   0128         JNC     ??chk_mounted_24
   \                     ??chk_mounted_25:
   \   0003E2   6B43         MOV.B   #0x2, R11
   2151          	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   \                     ??chk_mounted_24:
   \   0003E4   81930C00     CMP.W   #0x0, 0xc(SP)
   \   0003E8   0728         JNC     ??chk_mounted_26
   \   0003EA   0420         JNE     ??chk_mounted_27
   \   0003EC   B190F6FF0A00 CMP.W   #0xfff6, 0xa(SP)
   \   0003F2   0228         JNC     ??chk_mounted_26
   \                     ??chk_mounted_27:
   \   0003F4   7B400300     MOV.B   #0x3, R11
   2152          
   2153          	/* Boundaries and Limits */
   2154          	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   \                     ??chk_mounted_26:
   \   0003F8   1E410A00     MOV.W   0xa(SP), R14
   \   0003FC   1F410C00     MOV.W   0xc(SP), R15
   \   000400   2E53         ADD.W   #0x2, R14
   \   000402   0F63         ADDC.W  #0x0, R15
   \   000404   8A4E1A00     MOV.W   R14, 0x1a(R10)
   \   000408   8A4F1C00     MOV.W   R15, 0x1c(R10)
   2155          	fs->database = bsect + sysect;						/* Data start sector */
   \   00040C   0E46         MOV.W   R6, R14
   \   00040E   0F47         MOV.W   R7, R15
   \   000410   1E511600     ADD.W   0x16(SP), R14
   \   000414   1F611800     ADDC.W  0x18(SP), R15
   \   000418   8A4E2A00     MOV.W   R14, 0x2a(R10)
   \   00041C   8A4F2C00     MOV.W   R15, 0x2c(R10)
   2156          	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   \   000420   1E410400     MOV.W   0x4(SP), R14
   \   000424   0F43         MOV.W   #0x0, R15
   \   000426   0C46         MOV.W   R6, R12
   \   000428   0D47         MOV.W   R7, R13
   \   00042A   0C5E         ADD.W   R14, R12
   \   00042C   0D6F         ADDC.W  R15, R13
   \   00042E   8A4C2200     MOV.W   R12, 0x22(R10)
   \   000432   8A4D2400     MOV.W   R13, 0x24(R10)
   2157          	if (fmt == FS_FAT32) {
   \   000436   7B900300     CMP.B   #0x3, R11
   \   00043A   3920         JNE     ??chk_mounted_28
   2158          		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
   \   00043C   8A930800     CMP.W   #0x0, 0x8(R10)
   \   000440   0324         JEQ     ??chk_mounted_29
   \   000442   7C400D00     MOV.B   #0xd, R12
   \   000446   6A3D         JMP     ??chk_mounted_3
   2159          		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
   \                     ??chk_mounted_29:
   \   000448   5F4A5E00     MOV.B   0x5e(R10), R15
   \   00044C   4F4F         MOV.B   R15, R15
   \   00044E   0F12         PUSH.W  R15
   \   000450   5F4A5F00     MOV.B   0x5f(R10), R15
   \   000454   4F4F         MOV.B   R15, R15
   \   000456   3FF0FF00     AND.W   #0xff, R15
   \   00045A   8F10         SWPB    R15
   \   00045C   0F12         PUSH.W  R15
   \   00045E   5E4A6000     MOV.B   0x60(R10), R14
   \   000462   4E4E         MOV.B   R14, R14
   \   000464   0F43         MOV.W   #0x0, R15
   \   000466   0F4E         MOV.W   R14, R15
   \   000468   0E43         MOV.W   #0x0, R14
   \   00046A   0C4E         MOV.W   R14, R12
   \   00046C   0D4F         MOV.W   R15, R13
   \   00046E   5E4A6100     MOV.B   0x61(R10), R14
   \   000472   4E4E         MOV.B   R14, R14
   \   000474   0F43         MOV.W   #0x0, R15
   \   000476   3EF0FF00     AND.W   #0xff, R14
   \   00047A   8E10         SWPB    R14
   \   00047C   0F4E         MOV.W   R14, R15
   \   00047E   0E43         MOV.W   #0x0, R14
   \   000480   0EDC         BIS.W   R12, R14
   \   000482   0FDD         BIS.W   R13, R15
   \   000484   3D41         POP.W   R13
   \   000486   0EDD         BIS.W   R13, R14
   \   000488   3D41         POP.W   R13
   \   00048A   0EDD         BIS.W   R13, R14
   \   00048C   8A4E2600     MOV.W   R14, 0x26(R10)
   \   000490   8A4F2800     MOV.W   R15, 0x28(R10)
   2160          		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
   \   000494   1C4A1A00     MOV.W   0x1a(R10), R12
   \   000498   1D4A1C00     MOV.W   0x1c(R10), R13
   \   00049C   2E42         MOV.W   #0x4, R14
   \   00049E   0F43         MOV.W   #0x0, R15
   \   0004A0   ........     CALLA   #?Mul32
   \   0004A4   814C1200     MOV.W   R12, 0x12(SP)
   \   0004A8   814D1400     MOV.W   R13, 0x14(SP)
   \   0004AC   363C         JMP     ??chk_mounted_30
   2161          	} else {
   2162          		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
   \                     ??chk_mounted_28:
   \   0004AE   8A930800     CMP.W   #0x0, 0x8(R10)
   \   0004B2   0320         JNE     ??chk_mounted_31
   \   0004B4   7C400D00     MOV.B   #0xd, R12
   \   0004B8   313D         JMP     ??chk_mounted_3
   2163          		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
   \                     ??chk_mounted_31:
   \   0004BA   0E48         MOV.W   R8, R14
   \   0004BC   0F49         MOV.W   R9, R15
   \   0004BE   1E5A2200     ADD.W   0x22(R10), R14
   \   0004C2   1F6A2400     ADDC.W  0x24(R10), R15
   \   0004C6   8A4E2600     MOV.W   R14, 0x26(R10)
   \   0004CA   8A4F2800     MOV.W   R15, 0x28(R10)
   2164          		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
   2165          			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   \   0004CE   6B93         CMP.B   #0x2, R11
   \   0004D0   0D20         JNE     ??chk_mounted_32
   \   0004D2   1C4A1A00     MOV.W   0x1a(R10), R12
   \   0004D6   1D4A1C00     MOV.W   0x1c(R10), R13
   \   0004DA   2E43         MOV.W   #0x2, R14
   \   0004DC   0F43         MOV.W   #0x0, R15
   \   0004DE   ........     CALLA   #?Mul32
   \   0004E2   814C1200     MOV.W   R12, 0x12(SP)
   \   0004E6   814D1400     MOV.W   R13, 0x14(SP)
   \   0004EA   173C         JMP     ??chk_mounted_30
   \                     ??chk_mounted_32:
   \   0004EC   1C4A1A00     MOV.W   0x1a(R10), R12
   \   0004F0   1D4A1C00     MOV.W   0x1c(R10), R13
   \   0004F4   3E400300     MOV.W   #0x3, R14
   \   0004F8   0F43         MOV.W   #0x0, R15
   \   0004FA   ........     CALLA   #?Mul32
   \   0004FE   5D03         RRUM.W  #0x1, R13
   \   000500   0C10         RRC.W   R12
   \   000502   1E4A1A00     MOV.W   0x1a(R10), R14
   \   000506   1F4A1C00     MOV.W   0x1c(R10), R15
   \   00050A   1EF3         AND.W   #0x1, R14
   \   00050C   0FF3         AND.W   #0x0, R15
   \   00050E   0C5E         ADD.W   R14, R12
   \   000510   0D6F         ADDC.W  R15, R13
   \   000512   814C1200     MOV.W   R12, 0x12(SP)
   \   000516   814D1400     MOV.W   R13, 0x14(SP)
   2166          	}
   2167          	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
   \                     ??chk_mounted_30:
   \   00051A   1C411200     MOV.W   0x12(SP), R12
   \   00051E   1D411400     MOV.W   0x14(SP), R13
   \   000522   3C50FF01     ADD.W   #0x1ff, R12
   \   000526   0D63         ADDC.W  #0x0, R13
   \   000528   ........     CALLA   #?ShiftRight32u_9
   \   00052C   8A9D2000     CMP.W   R13, 0x20(R10)
   \   000530   0428         JNC     ??chk_mounted_33
   \   000532   0620         JNE     ??chk_mounted_34
   \   000534   8A9C1E00     CMP.W   R12, 0x1e(R10)
   \   000538   032C         JC      ??chk_mounted_34
   2168          		return FR_NO_FILESYSTEM;
   \                     ??chk_mounted_33:
   \   00053A   7C400D00     MOV.B   #0xd, R12
   \   00053E   EE3C         JMP     ??chk_mounted_3
   2169          
   2170          #if !_FS_READONLY
   2171          	/* Initialize cluster allocation information */
   2172          	fs->free_clust = 0xFFFFFFFF;
   \                     ??chk_mounted_34:
   \   000540   BA430E00     MOV.W   #0xffff, 0xe(R10)
   \   000544   BA431000     MOV.W   #0xffff, 0x10(R10)
   2173          	fs->last_clust = 0;
   \   000548   8A430A00     MOV.W   #0x0, 0xa(R10)
   \   00054C   8A430C00     MOV.W   #0x0, 0xc(R10)
   2174          
   2175          	/* Get fsinfo if available */
   2176          	if (fmt == FS_FAT32) {
   \   000550   7B900300     CMP.B   #0x3, R11
   \   000554   CD20         JNE     ??chk_mounted_35
   2177          	 	fs->fsi_flag = 0;
   \   000556   CA430500     MOV.B   #0x0, 0x5(R10)
   2178          		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
   \   00055A   5F4A6200     MOV.B   0x62(R10), R15
   \   00055E   4F4F         MOV.B   R15, R15
   \   000560   5E4A6300     MOV.B   0x63(R10), R14
   \   000564   4E4E         MOV.B   R14, R14
   \   000566   3EF0FF00     AND.W   #0xff, R14
   \   00056A   8E10         SWPB    R14
   \   00056C   0EDF         BIS.W   R15, R14
   \   00056E   0F43         MOV.W   #0x0, R15
   \   000570   0C46         MOV.W   R6, R12
   \   000572   0D47         MOV.W   R7, R13
   \   000574   0C5E         ADD.W   R14, R12
   \   000576   0D6F         ADDC.W  R15, R13
   \   000578   8A4C1200     MOV.W   R12, 0x12(R10)
   \   00057C   8A4D1400     MOV.W   R13, 0x14(R10)
   2179          		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
   2180          			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
   2181          			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
   2182          			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
   \   000580   5312         PUSH.B  #0x1
   \   000582   1E4A1200     MOV.W   0x12(R10), R14
   \   000586   1F4A1400     MOV.W   0x14(R10), R15
   \   00058A   CD0A         MOVA    R10, R13
   \   00058C   AD003200     ADDA    #0x32, R13
   \   000590   5C4A0100     MOV.B   0x1(R10), R12
   \   000594   ........     CALLA   #disk_read
   \   000598   2153         ADD.W   #0x2, SP
   \   00059A   4C93         CMP.B   #0x0, R12
   \   00059C   A920         JNE     ??chk_mounted_35
   \   00059E   5E4A3002     MOV.B   0x230(R10), R14
   \   0005A2   4E4E         MOV.B   R14, R14
   \   0005A4   5F4A3102     MOV.B   0x231(R10), R15
   \   0005A8   4F4F         MOV.B   R15, R15
   \   0005AA   3FF0FF00     AND.W   #0xff, R15
   \   0005AE   8F10         SWPB    R15
   \   0005B0   0FDE         BIS.W   R14, R15
   \   0005B2   3F9055AA     CMP.W   #0xaa55, R15
   \   0005B6   9C20         JNE     ??chk_mounted_35
   \   0005B8   5F4A3200     MOV.B   0x32(R10), R15
   \   0005BC   4F4F         MOV.B   R15, R15
   \   0005BE   0F12         PUSH.W  R15
   \   0005C0   5F4A3300     MOV.B   0x33(R10), R15
   \   0005C4   4F4F         MOV.B   R15, R15
   \   0005C6   3FF0FF00     AND.W   #0xff, R15
   \   0005CA   8F10         SWPB    R15
   \   0005CC   0F12         PUSH.W  R15
   \   0005CE   5E4A3400     MOV.B   0x34(R10), R14
   \   0005D2   4E4E         MOV.B   R14, R14
   \   0005D4   0F43         MOV.W   #0x0, R15
   \   0005D6   0F4E         MOV.W   R14, R15
   \   0005D8   0E43         MOV.W   #0x0, R14
   \   0005DA   0C4E         MOV.W   R14, R12
   \   0005DC   0D4F         MOV.W   R15, R13
   \   0005DE   5E4A3500     MOV.B   0x35(R10), R14
   \   0005E2   4E4E         MOV.B   R14, R14
   \   0005E4   0F43         MOV.W   #0x0, R15
   \   0005E6   3EF0FF00     AND.W   #0xff, R14
   \   0005EA   8E10         SWPB    R14
   \   0005EC   0F4E         MOV.W   R14, R15
   \   0005EE   0E43         MOV.W   #0x0, R14
   \   0005F0   0EDC         BIS.W   R12, R14
   \   0005F2   0FDD         BIS.W   R13, R15
   \   0005F4   3D41         POP.W   R13
   \   0005F6   0EDD         BIS.W   R13, R14
   \   0005F8   3D41         POP.W   R13
   \   0005FA   0EDD         BIS.W   R13, R14
   \   0005FC   3E905252     CMP.W   #0x5252, R14
   \   000600   7720         JNE     ??chk_mounted_35
   \   000602   3F906141     CMP.W   #0x4161, R15
   \   000606   7420         JNE     ??chk_mounted_35
   \   000608   5F4A1602     MOV.B   0x216(R10), R15
   \   00060C   4F4F         MOV.B   R15, R15
   \   00060E   0F12         PUSH.W  R15
   \   000610   5F4A1702     MOV.B   0x217(R10), R15
   \   000614   4F4F         MOV.B   R15, R15
   \   000616   3FF0FF00     AND.W   #0xff, R15
   \   00061A   8F10         SWPB    R15
   \   00061C   0F12         PUSH.W  R15
   \   00061E   5E4A1802     MOV.B   0x218(R10), R14
   \   000622   4E4E         MOV.B   R14, R14
   \   000624   0F43         MOV.W   #0x0, R15
   \   000626   0F4E         MOV.W   R14, R15
   \   000628   0E43         MOV.W   #0x0, R14
   \   00062A   0C4E         MOV.W   R14, R12
   \   00062C   0D4F         MOV.W   R15, R13
   \   00062E   5E4A1902     MOV.B   0x219(R10), R14
   \   000632   4E4E         MOV.B   R14, R14
   \   000634   0F43         MOV.W   #0x0, R15
   \   000636   3EF0FF00     AND.W   #0xff, R14
   \   00063A   8E10         SWPB    R14
   \   00063C   0F4E         MOV.W   R14, R15
   \   00063E   0E43         MOV.W   #0x0, R14
   \   000640   0EDC         BIS.W   R12, R14
   \   000642   0FDD         BIS.W   R13, R15
   \   000644   3D41         POP.W   R13
   \   000646   0EDD         BIS.W   R13, R14
   \   000648   3D41         POP.W   R13
   \   00064A   0EDD         BIS.W   R13, R14
   \   00064C   3E907272     CMP.W   #0x7272, R14
   \   000650   4F20         JNE     ??chk_mounted_35
   \   000652   3F904161     CMP.W   #0x6141, R15
   \   000656   4C20         JNE     ??chk_mounted_35
   2183          				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   \   000658   5F4A1E02     MOV.B   0x21e(R10), R15
   \   00065C   4F4F         MOV.B   R15, R15
   \   00065E   0F12         PUSH.W  R15
   \   000660   5F4A1F02     MOV.B   0x21f(R10), R15
   \   000664   4F4F         MOV.B   R15, R15
   \   000666   3FF0FF00     AND.W   #0xff, R15
   \   00066A   8F10         SWPB    R15
   \   00066C   0F12         PUSH.W  R15
   \   00066E   5E4A2002     MOV.B   0x220(R10), R14
   \   000672   4E4E         MOV.B   R14, R14
   \   000674   0F43         MOV.W   #0x0, R15
   \   000676   0F4E         MOV.W   R14, R15
   \   000678   0E43         MOV.W   #0x0, R14
   \   00067A   0C4E         MOV.W   R14, R12
   \   00067C   0D4F         MOV.W   R15, R13
   \   00067E   5E4A2102     MOV.B   0x221(R10), R14
   \   000682   4E4E         MOV.B   R14, R14
   \   000684   0F43         MOV.W   #0x0, R15
   \   000686   3EF0FF00     AND.W   #0xff, R14
   \   00068A   8E10         SWPB    R14
   \   00068C   0F4E         MOV.W   R14, R15
   \   00068E   0E43         MOV.W   #0x0, R14
   \   000690   0EDC         BIS.W   R12, R14
   \   000692   0FDD         BIS.W   R13, R15
   \   000694   3D41         POP.W   R13
   \   000696   0EDD         BIS.W   R13, R14
   \   000698   3D41         POP.W   R13
   \   00069A   0EDD         BIS.W   R13, R14
   \   00069C   8A4E0A00     MOV.W   R14, 0xa(R10)
   \   0006A0   8A4F0C00     MOV.W   R15, 0xc(R10)
   2184          				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   \   0006A4   5F4A1A02     MOV.B   0x21a(R10), R15
   \   0006A8   4F4F         MOV.B   R15, R15
   \   0006AA   0F12         PUSH.W  R15
   \   0006AC   5F4A1B02     MOV.B   0x21b(R10), R15
   \   0006B0   4F4F         MOV.B   R15, R15
   \   0006B2   3FF0FF00     AND.W   #0xff, R15
   \   0006B6   8F10         SWPB    R15
   \   0006B8   0F12         PUSH.W  R15
   \   0006BA   5E4A1C02     MOV.B   0x21c(R10), R14
   \   0006BE   4E4E         MOV.B   R14, R14
   \   0006C0   0F43         MOV.W   #0x0, R15
   \   0006C2   0F4E         MOV.W   R14, R15
   \   0006C4   0E43         MOV.W   #0x0, R14
   \   0006C6   0C4E         MOV.W   R14, R12
   \   0006C8   0D4F         MOV.W   R15, R13
   \   0006CA   5E4A1D02     MOV.B   0x21d(R10), R14
   \   0006CE   4E4E         MOV.B   R14, R14
   \   0006D0   0F43         MOV.W   #0x0, R15
   \   0006D2   3EF0FF00     AND.W   #0xff, R14
   \   0006D6   8E10         SWPB    R14
   \   0006D8   0F4E         MOV.W   R14, R15
   \   0006DA   0E43         MOV.W   #0x0, R14
   \   0006DC   0EDC         BIS.W   R12, R14
   \   0006DE   0FDD         BIS.W   R13, R15
   \   0006E0   3D41         POP.W   R13
   \   0006E2   0EDD         BIS.W   R13, R14
   \   0006E4   3D41         POP.W   R13
   \   0006E6   0EDD         BIS.W   R13, R14
   \   0006E8   8A4E0E00     MOV.W   R14, 0xe(R10)
   \   0006EC   8A4F1000     MOV.W   R15, 0x10(R10)
   2185          		}
   2186          	}
   2187          #endif
   2188          	fs->fs_type = fmt;		/* FAT sub-type */
   \                     ??chk_mounted_35:
   \   0006F0   CA4B0000     MOV.B   R11, 0(R10)
   2189          	fs->id = ++Fsid;		/* File system mount ID */
   \   0006F4   1F43         MOV.W   #0x1, R15
   \   0006F6   ....1F52.... ADDX.W  &Fsid, R15
   \   0006FC   ....824F.... MOVX.W  R15, &Fsid
   \   000702   8A4F0600     MOV.W   R15, 0x6(R10)
   2190          	fs->winsect = 0;		/* Invalidate sector cache */
   \   000706   8A432E00     MOV.W   #0x0, 0x2e(R10)
   \   00070A   8A433000     MOV.W   #0x0, 0x30(R10)
   2191          	fs->wflag = 0;
   \   00070E   CA430400     MOV.B   #0x0, 0x4(R10)
   2192          #if _FS_RPATH
   2193          	fs->cdir = 0;			/* Current directory (root dir) */
   \   000712   8A431600     MOV.W   #0x0, 0x16(R10)
   \   000716   8A431800     MOV.W   #0x0, 0x18(R10)
   2194          #endif
   2195          #if _FS_LOCK				/* Clear file lock semaphores */
   2196          	clear_lock(fs);
   2197          #endif
   2198          
   2199          	return FR_OK;
   \   00071A   4C43         MOV.B   #0x0, R12
   \                     ??chk_mounted_3:
   \   00071C   31502400     ADD.W   #0x24, SP
   \   000720   7416         POPM.A  #0x8, R11
   \   000722   1001         RETA
   2200          }
   2201          
   2202          
   2203          
   2204          
   2205          /*-----------------------------------------------------------------------*/
   2206          /* Check if the file/dir object is valid or not                          */
   2207          /*-----------------------------------------------------------------------*/
   2208          

   \                                 In  segment CODE, align 2
   2209          static
   2210          FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
   \                     validate:
   2211          	void* obj		/* Pointer to the object FIL/DIR to check validity */
   2212          )
   2213          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   CA0C         MOVA    R12, R10
   2214          	FIL *fil;
   2215          
   2216          
   2217          	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
   \   000004   CB0A         MOVA    R10, R11
   2218          	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
   \   000006   0F0B         MOVA    @R11, R15
   \   000008   DF03         CMPA    #0x0, R15
   \   00000A   0924         JEQ     ??validate_0
   \   00000C   0F0B         MOVA    @R11, R15
   \   00000E   CF930000     CMP.B   #0x0, 0(R15)
   \   000012   0524         JEQ     ??validate_0
   \   000014   0F0B         MOVA    @R11, R15
   \   000016   9F9B04000600 CMP.W   0x4(R11), 0x6(R15)
   \   00001C   0324         JEQ     ??validate_1
   2219          		return FR_INVALID_OBJECT;
   \                     ??validate_0:
   \   00001E   7C400900     MOV.B   #0x9, R12
   \   000022   0B3C         JMP     ??validate_2
   2220          
   2221          	ENTER_FF(fil->fs);		/* Lock file system */
   2222          
   2223          	if (disk_status(fil->fs->drv) & STA_NOINIT)
   \                     ??validate_1:
   \   000024   0F0B         MOVA    @R11, R15
   \   000026   5C4F0100     MOV.B   0x1(R15), R12
   \   00002A   ........     CALLA   #disk_status
   \   00002E   5CB3         BIT.B   #0x1, R12
   \   000030   0328         JNC     ??validate_3
   2224          		return FR_NOT_READY;
   \   000032   7C400300     MOV.B   #0x3, R12
   \   000036   013C         JMP     ??validate_2
   2225          
   2226          	return FR_OK;
   \                     ??validate_3:
   \   000038   4C43         MOV.B   #0x0, R12
   \                     ??validate_2:
   \   00003A   1A16         POPM.A  #0x2, R11
   \   00003C   1001         RETA
   2227          }
   2228          
   2229          
   2230          
   2231          
   2232          /*--------------------------------------------------------------------------
   2233          
   2234             Public Functions
   2235          
   2236          --------------------------------------------------------------------------*/
   2237          
   2238          /*-----------------------------------------------------------------------*/
   2239          /* Scan directory structure                                              */
   2240          /*-----------------------------------------------------------------------*/
   2241          

   \                                 In  segment CODE, align 2
   2242          FRESULT scan_files (
   \                     scan_files:
   2243              char* path        /* Start node to be scanned (also used as work area) */
   2244          )
   2245          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   31803E00     SUB.W   #0x3e, SP
   \   000006   CB0C         MOVA    R12, R11
   2246              FRESULT res;
   2247              FILINFO fno;
   2248              DIR dir;
   2249              int i;
   2250              char *fn;   /* This function is assuming non-Unicode cfg. */
   2251          #if _USE_LFN
   2252              static char lfn[_MAX_LFN + 1];
   2253              fno.lfname = lfn;
   \   000008   ....F140.... MOVX.A  #??lfn, 0x16(SP)
   \            1600        
   2254              fno.lfsize = sizeof lfn;
   \   000010   B14065001A00 MOV.W   #0x65, 0x1a(SP)
   2255          #endif
   2256          
   2257          
   2258              res = f_opendir(&dir, path);                       /* Open the directory */
   \   000016   CD0B         MOVA    R11, R13
   \   000018   0C41         MOV.W   SP, R12
   \   00001A   3C501C00     ADD.W   #0x1c, R12
   \   00001E   ........     CALLA   #f_opendir
   \   000022   484C         MOV.B   R12, R8
   2259              if (res == FR_OK) {
   \   000024   4893         CMP.B   #0x0, R8
   \   000026   4720         JNE     ??scan_files_2
   2260                  i = strlen(path);
   \   000028   CC0B         MOVA    R11, R12
   \   00002A   ........     CALLA   #strlen
   \   00002E   0A4C         MOV.W   R12, R10
   2261                  for (;;) {
   2262                      res = f_readdir(&dir, &fno);                   /* Read a directory item */
   \                     ??scan_files_0:
   \   000030   0D41         MOV.W   SP, R13
   \   000032   0D53         ADD.W   #0x0, R13
   \   000034   0C41         MOV.W   SP, R12
   \   000036   3C501C00     ADD.W   #0x1c, R12
   \   00003A   ........     CALLA   #f_readdir
   \   00003E   484C         MOV.B   R12, R8
   2263                      if (res != FR_OK || fno.fname[0] == 0) break;  /* Break on error or end of dir */
   \   000040   4893         CMP.B   #0x0, R8
   \   000042   3920         JNE     ??scan_files_2
   \   000044   C1930900     CMP.B   #0x0, 0x9(SP)
   \   000048   3624         JEQ     ??scan_files_2
   2264                      if (fno.fname[0] == '.') continue;             /* Ignore dot entry */
   \   00004A   F1902E000900 CMP.B   #0x2e, 0x9(SP)
   \   000050   EF27         JEQ     ??scan_files_0
   2265          #if _USE_LFN
   2266                      fn = *fno.lfname ? fno.lfname : fno.fname;
   \   000052   3F011600     MOVA    0x16(SP), R15
   \   000056   CF930000     CMP.B   #0x0, 0(R15)
   \   00005A   0324         JEQ     ??scan_files_6
   \   00005C   39011600     MOVA    0x16(SP), R9
   \   000060   033C         JMP     ??scan_files_7
   \                     ??scan_files_6:
   \   000062   0941         MOV.W   SP, R9
   \   000064   39500900     ADD.W   #0x9, R9
   2267          #else
   2268                      fn = fno.fname;
   2269          #endif
   2270                      if (fno.fattrib & AM_DIR) {                    /* It is a directory */
   \                     ??scan_files_7:
   \   000068   F1B010000800 BIT.B   #0x10, 0x8(SP)
   \   00006E   1B28         JNC     ??scan_files_8
   2271                          sprintf(&path[i], "/%s", fn);
   \   000070   0914         PUSHM.A #0x1, R9
   \   000072   ........     MOVA    #`?<Constant "/%s">`, R13
   \   000076   0F4A         MOV.W   R10, R15
   \   000078   3FE00080     XOR.W   #0x8000, R15
   \   00007C   BF000080     SUBA    #0x8000, R15
   \   000080   CC0B         MOVA    R11, R12
   \   000082   EC0F         ADDA    R15, R12
   \   000084   ........     CALLA   #sprintf
   2272                          res = scan_files(path);
   \   000088   CC0B         MOVA    R11, R12
   \   00008A   ........     CALLA   #scan_files
   \   00008E   484C         MOV.B   R12, R8
   2273                          if (res != FR_OK) break;
   \   000090   2152         ADD.W   #0x4, SP
   \   000092   4893         CMP.B   #0x0, R8
   \   000094   1020         JNE     ??scan_files_2
   2274                          path[i] = 0;
   \   000096   0F4A         MOV.W   R10, R15
   \   000098   3FE00080     XOR.W   #0x8000, R15
   \   00009C   EF0B         ADDA    R11, R15
   \   00009E   4F18CF430080 MOVX.B  #0x0, 0xf8000(R15)
   \   0000A4   C53F         JMP     ??scan_files_0
   2275                      } else {                                       /* It is a file. */
   2276                          printf("%s/%s\n", path, fn);
   \                     ??scan_files_8:
   \   0000A6   0914         PUSHM.A #0x1, R9
   \   0000A8   0B14         PUSHM.A #0x1, R11
   \   0000AA   ........     MOVA    #`?<Constant "%s/%s\\n">`, R12
   \   0000AE   ........     CALLA   #printf
   \   0000B2   3152         ADD.W   #0x8, SP
   \   0000B4   BD3F         JMP     ??scan_files_0
   2277                      }
   2278                  }
   2279              }
   2280          
   2281              return res;
   \                     ??scan_files_2:
   \   0000B6   4C48         MOV.B   R8, R12
   \   0000B8   31503E00     ADD.W   #0x3e, SP
   \   0000BC   3816         POPM.A  #0x4, R11
   \   0000BE   1001         RETA
   2282          }

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
   \                     ??lfn:
   \   000000                DS8 101
   2283          
   2284          /*-----------------------------------------------------------------------*/
   2285          /* Mount/Unmount a Logical Drive                                         */
   2286          /*-----------------------------------------------------------------------*/
   2287          

   \                                 In  segment CODE, align 2
   2288          FRESULT f_mount (
   \                     f_mount:
   2289          	BYTE vol,		/* Logical drive number to be mounted/unmounted */
   2290          	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
   2291          )
   2292          {
   \   000000   0A14         PUSHM.A #0x1, R10
   \   000002   4E4C         MOV.B   R12, R14
   2293          	FATFS *rfs;
   2294          
   2295          
   2296          	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
   \   000004   4E93         CMP.B   #0x0, R14
   \   000006   0324         JEQ     ??f_mount_0
   2297          		return FR_INVALID_DRIVE;
   \   000008   7C400B00     MOV.B   #0xb, R12
   \   00000C   133C         JMP     ??f_mount_1
   2298          	rfs = FatFs[vol];			/* Get current fs object */
   \                     ??f_mount_0:
   \   00000E   4C4E         MOV.B   R14, R12
   \   000010   4C06         RLAM.A  #0x2, R12
   \   000012   ....5F4C.... MOVX.A  FatFs(R12), R15
   2299          
   2300          	if (rfs) {
   \   000018   DF03         CMPA    #0x0, R15
   \   00001A   0224         JEQ     ??f_mount_2
   2301          #if _FS_LOCK
   2302          		clear_lock(rfs);
   2303          #endif
   2304          #if _FS_REENTRANT				/* Discard sync object of the current volume */
   2305          		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
   2306          #endif
   2307          		rfs->fs_type = 0;		/* Clear old fs object */
   \   00001C   CF430000     MOV.B   #0x0, 0(R15)
   2308          	}
   2309          
   2310          	if (fs) {
   \                     ??f_mount_2:
   \   000020   DD03         CMPA    #0x0, R13
   \   000022   0224         JEQ     ??f_mount_3
   2311          		fs->fs_type = 0;		/* Clear new fs object */
   \   000024   CD430000     MOV.B   #0x0, 0(R13)
   2312          #if _FS_REENTRANT				/* Create sync object for the new volume */
   2313          		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
   2314          #endif
   2315          	}
   2316          	FatFs[vol] = fs;			/* Register new fs object */
   \                     ??f_mount_3:
   \   000028   4A4E         MOV.B   R14, R10
   \   00002A   4A06         RLAM.A  #0x2, R10
   \   00002C   ....CA4D.... MOVX.A  R13, FatFs(R10)
   2317          
   2318          	return FR_OK;
   \   000032   4C43         MOV.B   #0x0, R12
   \                     ??f_mount_1:
   \   000034   0A16         POPM.A  #0x1, R10
   \   000036   1001         RETA
   2319          }
   2320          
   2321          
   2322          
   2323          
   2324          /*-----------------------------------------------------------------------*/
   2325          /* Open or Create a File                                                 */
   2326          /*-----------------------------------------------------------------------*/
   2327          

   \                                 In  segment CODE, align 2
   2328          FRESULT f_open (
   \                     f_open:
   2329          	FIL *fp,			/* Pointer to the blank file object */
   2330          	const TCHAR *path,	/* Pointer to the file name */
   2331          	BYTE mode			/* Access mode and file open mode flags */
   2332          )
   2333          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   0D14         PUSHM.A #0x1, R13
   \   000004   3180F800     SUB.W   #0xf8, SP
   \   000008   C80C         MOVA    R12, R8
   \   00000A   494E         MOV.B   R14, R9
   2334          	FRESULT res;
   2335          	DIR dj;
   2336          	BYTE *dir;
   2337          	DEF_NAMEBUF;
   2338          
   2339          
   2340          	if (!fp) return FR_INVALID_OBJECT;
   \   00000C   D803         CMPA    #0x0, R8
   \   00000E   0320         JNE     ??f_open_0
   \   000010   7C400900     MOV.B   #0x9, R12
   \   000014   F43C         JMP     ??f_open_1
   2341          	fp->fs = 0;			/* Clear file object */
   \                     ??f_open_0:
   \   000016   0018C8430000 MOVX.A  #0x0, 0(R8)
   2342          
   2343          #if !_FS_READONLY
   2344          	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   \   00001C   79F01F00     AND.B   #0x1f, R9
   2345          	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
   \   000020   4E49         MOV.B   R9, R14
   \   000022   7EF0FE00     AND.B   #0xfe, R14
   \   000026   0D41         MOV.W   SP, R13
   \   000028   0D53         ADD.W   #0x0, R13
   \   00002A   0C41         MOV.W   SP, R12
   \   00002C   3C50F800     ADD.W   #0xf8, R12
   \   000030   ........     CALLA   #chk_mounted
   \   000034   4A4C         MOV.B   R12, R10
   2346          #else
   2347          	mode &= FA_READ;
   2348          	res = chk_mounted(&path, &dj.fs, 0);
   2349          #endif
   2350          	if (res == FR_OK) {
   \   000036   4A93         CMP.B   #0x0, R10
   \   000038   E120         JNE     ??f_open_2
   2351          		INIT_BUF(dj);
   \   00003A   0F41         MOV.W   SP, R15
   \   00003C   3F502200     ADD.W   #0x22, R15
   \   000040   710F1800     MOVA    R15, 0x18(SP)
   \   000044   0F41         MOV.W   SP, R15
   \   000046   3F502E00     ADD.W   #0x2e, R15
   \   00004A   710F1C00     MOVA    R15, 0x1c(SP)
   2352          		res = follow_path(&dj, path);	/* Follow the file path */
   \   00004E   3D01F800     MOVA    0xf8(SP), R13
   \   000052   0C41         MOV.W   SP, R12
   \   000054   0C53         ADD.W   #0x0, R12
   \   000056   ........     CALLA   #follow_path
   \   00005A   4A4C         MOV.B   R12, R10
   2353          		dir = dj.dir;
   \   00005C   3B011400     MOVA    0x14(SP), R11
   2354          #if !_FS_READONLY	/* R/W configuration */
   2355          		if (res == FR_OK) {
   \   000060   4A93         CMP.B   #0x0, R10
   \   000062   0420         JNE     ??f_open_3
   2356          			if (!dir)	/* Current dir itself */
   \   000064   DB03         CMPA    #0x0, R11
   \   000066   0220         JNE     ??f_open_3
   2357          				res = FR_INVALID_NAME;
   \   000068   7A400600     MOV.B   #0x6, R10
   2358          #if _FS_LOCK
   2359          			else
   2360          				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   2361          #endif
   2362          		}
   2363          		/* Create or Open a file */
   2364          		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   \                     ??f_open_3:
   \   00006C   79B01C00     BIT.B   #0x1c, R9
   \   000070   6924         JEQ     ??f_open_4
   2365          			DWORD dw, cl;
   2366          
   2367          			if (res != FR_OK) {					/* No file, create new */
   \   000072   4A93         CMP.B   #0x0, R10
   \   000074   0B24         JEQ     ??f_open_5
   2368          				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
   \   000076   6A92         CMP.B   #0x4, R10
   \   000078   0520         JNE     ??f_open_6
   2369          #if _FS_LOCK
   2370          					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
   2371          #else
   2372          					res = dir_register(&dj);
   \   00007A   0C41         MOV.W   SP, R12
   \   00007C   0C53         ADD.W   #0x0, R12
   \   00007E   ........     CALLA   #dir_register
   \   000082   4A4C         MOV.B   R12, R10
   2373          #endif
   2374          				mode |= FA_CREATE_ALWAYS;		/* File is created */
   \                     ??f_open_6:
   \   000084   79D2         BIS.B   #0x8, R9
   2375          				dir = dj.dir;					/* New entry */
   \   000086   3B011400     MOVA    0x14(SP), R11
   \   00008A   0A3C         JMP     ??f_open_7
   2376          			}
   2377          			else {								/* Any object is already existing */
   2378          				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
   \                     ??f_open_5:
   \   00008C   FBB011000B00 BIT.B   #0x11, 0xb(R11)
   \   000092   0324         JEQ     ??f_open_8
   2379          					res = FR_DENIED;
   \   000094   7A400700     MOV.B   #0x7, R10
   \   000098   033C         JMP     ??f_open_7
   2380          				} else {
   2381          					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
   \                     ??f_open_8:
   \   00009A   69B2         BIT.B   #0x4, R9
   \   00009C   0128         JNC     ??f_open_7
   2382          						res = FR_EXIST;
   \   00009E   7A42         MOV.B   #0x8, R10
   2383          				}
   2384          			}
   2385          			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
   \                     ??f_open_7:
   \   0000A0   4A93         CMP.B   #0x0, R10
   \   0000A2   5F20         JNE     ??f_open_9
   \   0000A4   79B2         BIT.B   #0x8, R9
   \   0000A6   5D28         JNC     ??f_open_9
   2386          				dw = get_fattime();					/* Created time */
   \   0000A8   ........     CALLA   #get_fattime
   \   0000AC   064C         MOV.W   R12, R6
   \   0000AE   074D         MOV.W   R13, R7
   2387          				ST_DWORD(dir+DIR_CrtTime, dw);
   \   0000B0   CB460E00     MOV.B   R6, 0xe(R11)
   \   0000B4   0F46         MOV.W   R6, R15
   \   0000B6   8F10         SWPB    R15
   \   0000B8   3FF0FF00     AND.W   #0xff, R15
   \   0000BC   CB4F0F00     MOV.B   R15, 0xf(R11)
   \   0000C0   CB471000     MOV.B   R7, 0x10(R11)
   \   0000C4   0E46         MOV.W   R6, R14
   \   0000C6   0F47         MOV.W   R7, R15
   \   0000C8   8F10         SWPB    R15
   \   0000CA   4E4F         MOV.B   R15, R14
   \   0000CC   0F43         MOV.W   #0x0, R15
   \   0000CE   CB4E1100     MOV.B   R14, 0x11(R11)
   2388          				dir[DIR_Attr] = 0;					/* Reset attribute */
   \   0000D2   CB430B00     MOV.B   #0x0, 0xb(R11)
   2389          				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
   \   0000D6   CB431C00     MOV.B   #0x0, 0x1c(R11)
   \   0000DA   CB431D00     MOV.B   #0x0, 0x1d(R11)
   \   0000DE   CB431E00     MOV.B   #0x0, 0x1e(R11)
   \   0000E2   CB431F00     MOV.B   #0x0, 0x1f(R11)
   2390          				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
   \   0000E6   CD0B         MOVA    R11, R13
   \   0000E8   0C01         MOVA    @SP, R12
   \   0000EA   ........     CALLA   #ld_clust
   \   0000EE   044C         MOV.W   R12, R4
   \   0000F0   054D         MOV.W   R13, R5
   2391          				st_clust(dir, 0);					/* cluster = 0 */
   \   0000F2   0E43         MOV.W   #0x0, R14
   \   0000F4   0F43         MOV.W   #0x0, R15
   \   0000F6   CC0B         MOVA    R11, R12
   \   0000F8   ........     CALLA   #st_clust
   2392          				dj.fs->wflag = 1;
   \   0000FC   0F01         MOVA    @SP, R15
   \   0000FE   DF430400     MOV.B   #0x1, 0x4(R15)
   2393          				if (cl) {							/* Remove the cluster chain if exist */
   \   000102   0F44         MOV.W   R4, R15
   \   000104   0FD5         BIS.W   R5, R15
   \   000106   0F93         CMP.W   #0x0, R15
   \   000108   2C24         JEQ     ??f_open_9
   2394          					dw = dj.fs->winsect;
   \   00010A   0F01         MOVA    @SP, R15
   \   00010C   164F2E00     MOV.W   0x2e(R15), R6
   \   000110   174F3000     MOV.W   0x30(R15), R7
   2395          					res = remove_chain(dj.fs, cl);
   \   000114   0E44         MOV.W   R4, R14
   \   000116   0F45         MOV.W   R5, R15
   \   000118   0C01         MOVA    @SP, R12
   \   00011A   ........     CALLA   #remove_chain
   \   00011E   4A4C         MOV.B   R12, R10
   2396          					if (res == FR_OK) {
   \   000120   4A93         CMP.B   #0x0, R10
   \   000122   1F20         JNE     ??f_open_9
   2397          						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
   \   000124   0E44         MOV.W   R4, R14
   \   000126   0F45         MOV.W   R5, R15
   \   000128   3E53         ADD.W   #0xffff, R14
   \   00012A   3F63         ADDC.W  #0xffff, R15
   \   00012C   0D01         MOVA    @SP, R13
   \   00012E   8D4E0A00     MOV.W   R14, 0xa(R13)
   \   000132   8D4F0C00     MOV.W   R15, 0xc(R13)
   2398          						res = move_window(dj.fs, dw);
   \   000136   0E46         MOV.W   R6, R14
   \   000138   0F47         MOV.W   R7, R15
   \   00013A   0C01         MOVA    @SP, R12
   \   00013C   ........     CALLA   #move_window
   \   000140   4A4C         MOV.B   R12, R10
   \   000142   0F3C         JMP     ??f_open_9
   2399          					}
   2400          				}
   2401          			}
   2402          		}
   2403          		else {	/* Open an existing file */
   2404          			if (res == FR_OK) {						/* Follow succeeded */
   \                     ??f_open_4:
   \   000144   4A93         CMP.B   #0x0, R10
   \   000146   0D20         JNE     ??f_open_9
   2405          				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
   \   000148   FBB010000B00 BIT.B   #0x10, 0xb(R11)
   \   00014E   0228         JNC     ??f_open_10
   2406          					res = FR_NO_FILE;
   \   000150   6A42         MOV.B   #0x4, R10
   \   000152   073C         JMP     ??f_open_9
   2407          				} else {
   2408          					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
   \                     ??f_open_10:
   \   000154   69B3         BIT.B   #0x2, R9
   \   000156   0528         JNC     ??f_open_9
   \   000158   DBB30B00     BIT.B   #0x1, 0xb(R11)
   \   00015C   0228         JNC     ??f_open_9
   2409          						res = FR_DENIED;
   \   00015E   7A400700     MOV.B   #0x7, R10
   2410          				}
   2411          			}
   2412          		}
   2413          		if (res == FR_OK) {
   \                     ??f_open_9:
   \   000162   4A93         CMP.B   #0x0, R10
   \   000164   0D20         JNE     ??f_open_11
   2414          			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
   \   000166   79B2         BIT.B   #0x8, R9
   \   000168   0228         JNC     ??f_open_12
   2415          				mode |= FA__WRITTEN;
   \   00016A   79D02000     BIS.B   #0x20, R9
   2416          			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
   \                     ??f_open_12:
   \   00016E   0F01         MOVA    @SP, R15
   \   000170   984F2E001C00 MOV.W   0x2e(R15), 0x1c(R8)
   \   000176   984F30001E00 MOV.W   0x30(R15), 0x1e(R8)
   2417          			fp->dir_ptr = dir;
   \   00017C   780B2000     MOVA    R11, 0x20(R8)
   2418          #if _FS_LOCK
   2419          			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   2420          			if (!fp->lockid) res = FR_INT_ERR;
   2421          #endif
   2422          		}
   2423          
   2424          #else				/* R/O configuration */
   2425          		if (res == FR_OK) {					/* Follow succeeded */
   2426          			dir = dj.dir;
   2427          			if (!dir) {						/* Current dir itself */
   2428          				res = FR_INVALID_NAME;
   2429          			} else {
   2430          				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
   2431          					res = FR_NO_FILE;
   2432          			}
   2433          		}
   2434          #endif
   2435          		FREE_BUF();
   2436          
   2437          		if (res == FR_OK) {
   \                     ??f_open_11:
   \   000180   4A93         CMP.B   #0x0, R10
   \   000182   3C20         JNE     ??f_open_2
   2438          			fp->flag = mode;					/* File access mode */
   \   000184   C8490600     MOV.B   R9, 0x6(R8)
   2439          			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
   \   000188   CD0B         MOVA    R11, R13
   \   00018A   0C01         MOVA    @SP, R12
   \   00018C   ........     CALLA   #ld_clust
   \   000190   884C1000     MOV.W   R12, 0x10(R8)
   \   000194   884D1200     MOV.W   R13, 0x12(R8)
   2440          			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
   \   000198   544B1C00     MOV.B   0x1c(R11), R4
   \   00019C   4444         MOV.B   R4, R4
   \   00019E   5D4B1D00     MOV.B   0x1d(R11), R13
   \   0001A2   4D4D         MOV.B   R13, R13
   \   0001A4   3DF0FF00     AND.W   #0xff, R13
   \   0001A8   8D10         SWPB    R13
   \   0001AA   5E4B1E00     MOV.B   0x1e(R11), R14
   \   0001AE   4E4E         MOV.B   R14, R14
   \   0001B0   0F43         MOV.W   #0x0, R15
   \   0001B2   0F4E         MOV.W   R14, R15
   \   0001B4   0E43         MOV.W   #0x0, R14
   \   0001B6   564B1F00     MOV.B   0x1f(R11), R6
   \   0001BA   4646         MOV.B   R6, R6
   \   0001BC   0743         MOV.W   #0x0, R7
   \   0001BE   36F0FF00     AND.W   #0xff, R6
   \   0001C2   8610         SWPB    R6
   \   0001C4   0746         MOV.W   R6, R7
   \   0001C6   0643         MOV.W   #0x0, R6
   \   0001C8   06DE         BIS.W   R14, R6
   \   0001CA   07DF         BIS.W   R15, R7
   \   0001CC   06DD         BIS.W   R13, R6
   \   0001CE   06D4         BIS.W   R4, R6
   \   0001D0   88460C00     MOV.W   R6, 0xc(R8)
   \   0001D4   88470E00     MOV.W   R7, 0xe(R8)
   2441          			fp->fptr = 0;						/* File pointer */
   \   0001D8   88430800     MOV.W   #0x0, 0x8(R8)
   \   0001DC   88430A00     MOV.W   #0x0, 0xa(R8)
   2442          			fp->dsect = 0;
   \   0001E0   88431800     MOV.W   #0x0, 0x18(R8)
   \   0001E4   88431A00     MOV.W   #0x0, 0x1a(R8)
   2443          #if _USE_FASTSEEK
   2444          			fp->cltbl = 0;						/* Normal seek mode */
   \   0001E8   0018C8432400 MOVX.A  #0x0, 0x24(R8)
   2445          #endif
   2446          			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
   \   0001EE   0F01         MOVA    @SP, R15
   \   0001F0   780F0000     MOVA    R15, 0(R8)
   \   0001F4   0F01         MOVA    @SP, R15
   \   0001F6   984F06000400 MOV.W   0x6(R15), 0x4(R8)
   2447          		}
   2448          	}
   2449          
   2450          	LEAVE_FF(dj.fs, res);
   \                     ??f_open_2:
   \   0001FC   4C4A         MOV.B   R10, R12
   \                     ??f_open_1:
   \   0001FE   3150FC00     ADD.W   #0xfc, SP
   \   000202   7416         POPM.A  #0x8, R11
   \   000204   1001         RETA
   2451          }
   2452          
   2453          
   2454          
   2455          
   2456          /*-----------------------------------------------------------------------*/
   2457          /* Read File                                                             */
   2458          /*-----------------------------------------------------------------------*/
   2459          

   \                                 In  segment CODE, align 2
   2460          FRESULT f_read (
   \                     f_read:
   2461          	FIL *fp, 		/* Pointer to the file object */
   2462          	void *buff,		/* Pointer to data buffer */
   2463          	UINT btr,		/* Number of bytes to read */
   2464          	UINT *br		/* Pointer to number of bytes read */
   2465          )
   2466          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   0D14         PUSHM.A #0x1, R13
   \   000004   0F14         PUSHM.A #0x1, R15
   \   000006   31800A00     SUB.W   #0xa, SP
   \   00000A   CA0C         MOVA    R12, R10
   \   00000C   064E         MOV.W   R14, R6
   2467          	FRESULT res;
   2468          	DWORD clst, sect, remain;
   2469          	UINT rcnt, cc;
   2470          	BYTE csect, *rbuff = buff;
   \   00000E   0018D1410E00 MOVX.A  0xe(SP), 0x2(SP)
   \            0200        
   2471          
   2472          
   2473          	*br = 0;	/* Clear read byte counter */
   \   000016   3F010A00     MOVA    0xa(SP), R15
   \   00001A   8F430000     MOV.W   #0x0, 0(R15)
   2474          
   2475          	res = validate(fp);							/* Check validity */
   \   00001E   CC0A         MOVA    R10, R12
   \   000020   ........     CALLA   #validate
   \   000024   C14C0100     MOV.B   R12, 0x1(SP)
   2476          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   000028   C1930100     CMP.B   #0x0, 0x1(SP)
   \   00002C   0324         JEQ     ??f_read_1
   \   00002E   5C410100     MOV.B   0x1(SP), R12
   \   000032   693D         JMP     ??f_read_2
   2477          	if (fp->flag & FA__ERROR)					/* Aborted file? */
   \                     ??f_read_1:
   \   000034   CA930600     CMP.B   #0x0, 0x6(R10)
   \   000038   0234         JGE     ??f_read_3
   2478          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00003A   6C43         MOV.B   #0x2, R12
   \   00003C   643D         JMP     ??f_read_2
   2479          	if (!(fp->flag & FA_READ)) 					/* Check access mode */
   \                     ??f_read_3:
   \   00003E   DAB30600     BIT.B   #0x1, 0x6(R10)
   \   000042   032C         JC      ??f_read_4
   2480          		LEAVE_FF(fp->fs, FR_DENIED);
   \   000044   7C400700     MOV.B   #0x7, R12
   \   000048   5E3D         JMP     ??f_read_2
   2481          	remain = fp->fsize - fp->fptr;
   \                     ??f_read_4:
   \   00004A   1E4A0C00     MOV.W   0xc(R10), R14
   \   00004E   1F4A0E00     MOV.W   0xe(R10), R15
   \   000052   1E8A0800     SUB.W   0x8(R10), R14
   \   000056   1F7A0A00     SUBC.W  0xa(R10), R15
   \   00005A   814E0600     MOV.W   R14, 0x6(SP)
   \   00005E   814F0800     MOV.W   R15, 0x8(SP)
   2482          	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
   \   000062   0E46         MOV.W   R6, R14
   \   000064   0F43         MOV.W   #0x0, R15
   \   000066   819F0800     CMP.W   R15, 0x8(SP)
   \   00006A   0428         JNC     ??f_read_5
   \   00006C   0520         JNE     ??f_read_0
   \   00006E   819E0600     CMP.W   R14, 0x6(SP)
   \   000072   022C         JC      ??f_read_0
   \                     ??f_read_5:
   \   000074   16410600     MOV.W   0x6(SP), R6
   2483          
   2484          	for ( ;  btr;								/* Repeat until all data read */
   \                     ??f_read_0:
   \   000078   0693         CMP.W   #0x0, R6
   \   00007A   4425         JEQ     ??f_read_6
   2485          		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
   2486          		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
   \   00007C   1C4A0800     MOV.W   0x8(R10), R12
   \   000080   1D4A0A00     MOV.W   0xa(R10), R13
   \   000084   3E400002     MOV.W   #0x200, R14
   \   000088   0F43         MOV.W   #0x0, R15
   \   00008A   ........     CALLA   #?DivMod32u
   \   00008E   0D4E         MOV.W   R14, R13
   \   000090   0DDF         BIS.W   R15, R13
   \   000092   0D93         CMP.W   #0x0, R13
   \   000094   0121         JNE     ??f_read_7
   2487          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   \   000096   1C4A0800     MOV.W   0x8(R10), R12
   \   00009A   1D4A0A00     MOV.W   0xa(R10), R13
   \   00009E   ........     CALLA   #?ShiftRight32u_9
   \   0000A2   0F0A         MOVA    @R10, R15
   \   0000A4   5E4F0200     MOV.B   0x2(R15), R14
   \   0000A8   4E4E         MOV.B   R14, R14
   \   0000AA   3E53         ADD.W   #0xffff, R14
   \   0000AC   4CFE         AND.B   R14, R12
   \   0000AE   C14C0000     MOV.B   R12, 0(SP)
   2488          			if (!csect) {						/* On the cluster boundary? */
   \   0000B2   C1930000     CMP.B   #0x0, 0(SP)
   \   0000B6   3B20         JNE     ??f_read_8
   2489          				if (fp->fptr == 0) {			/* On the top of the file? */
   \   0000B8   1F4A0800     MOV.W   0x8(R10), R15
   \   0000BC   1FDA0A00     BIS.W   0xa(R10), R15
   \   0000C0   0F93         CMP.W   #0x0, R15
   \   0000C2   0520         JNE     ??f_read_9
   2490          					clst = fp->sclust;			/* Follow from the origin */
   \   0000C4   144A1000     MOV.W   0x10(R10), R4
   \   0000C8   154A1200     MOV.W   0x12(R10), R5
   \   0000CC   173C         JMP     ??f_read_10
   2491          				} else {						/* Middle or end of the file */
   2492          #if _USE_FASTSEEK
   2493          					if (fp->cltbl)
   \                     ??f_read_9:
   \   0000CE   3F0A2400     MOVA    0x24(R10), R15
   \   0000D2   DF03         CMPA    #0x0, R15
   \   0000D4   0A24         JEQ     ??f_read_11
   2494          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   \   0000D6   1E4A0800     MOV.W   0x8(R10), R14
   \   0000DA   1F4A0A00     MOV.W   0xa(R10), R15
   \   0000DE   CC0A         MOVA    R10, R12
   \   0000E0   ........     CALLA   #clmt_clust
   \   0000E4   044C         MOV.W   R12, R4
   \   0000E6   054D         MOV.W   R13, R5
   \   0000E8   093C         JMP     ??f_read_10
   2495          					else
   2496          #endif
   2497          						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
   \                     ??f_read_11:
   \   0000EA   1E4A1400     MOV.W   0x14(R10), R14
   \   0000EE   1F4A1600     MOV.W   0x16(R10), R15
   \   0000F2   0C0A         MOVA    @R10, R12
   \   0000F4   ........     CALLA   #get_fat
   \   0000F8   044C         MOV.W   R12, R4
   \   0000FA   054D         MOV.W   R13, R5
   2498          				}
   2499          				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
   \                     ??f_read_10:
   \   0000FC   0593         CMP.W   #0x0, R5
   \   0000FE   0328         JNC     ??f_read_12
   \   000100   0820         JNE     ??f_read_13
   \   000102   2493         CMP.W   #0x2, R4
   \   000104   062C         JC      ??f_read_13
   \                     ??f_read_12:
   \   000106   CF0A         MOVA    R10, R15
   \   000108   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   00010E   6C43         MOV.B   #0x2, R12
   \   000110   FA3C         JMP     ??f_read_2
   2500          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_read_13:
   \   000112   3493         CMP.W   #0xffff, R4
   \   000114   0820         JNE     ??f_read_14
   \   000116   3593         CMP.W   #0xffff, R5
   \   000118   0620         JNE     ??f_read_14
   \   00011A   CF0A         MOVA    R10, R15
   \   00011C   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   000122   5C43         MOV.B   #0x1, R12
   \   000124   F03C         JMP     ??f_read_2
   2501          				fp->clust = clst;				/* Update current cluster */
   \                     ??f_read_14:
   \   000126   8A441400     MOV.W   R4, 0x14(R10)
   \   00012A   8A451600     MOV.W   R5, 0x16(R10)
   2502          			}
   2503          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   \                     ??f_read_8:
   \   00012E   1E4A1400     MOV.W   0x14(R10), R14
   \   000132   1F4A1600     MOV.W   0x16(R10), R15
   \   000136   0C0A         MOVA    @R10, R12
   \   000138   ........     CALLA   #clust2sect
   \   00013C   084C         MOV.W   R12, R8
   \   00013E   094D         MOV.W   R13, R9
   2504          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   \   000140   0F48         MOV.W   R8, R15
   \   000142   0FD9         BIS.W   R9, R15
   \   000144   0F93         CMP.W   #0x0, R15
   \   000146   0620         JNE     ??f_read_15
   \   000148   CF0A         MOVA    R10, R15
   \   00014A   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   000150   6C43         MOV.B   #0x2, R12
   \   000152   D93C         JMP     ??f_read_2
   2505          			sect += csect;
   \                     ??f_read_15:
   \   000154   6E41         MOV.B   @SP, R14
   \   000156   4E4E         MOV.B   R14, R14
   \   000158   0F43         MOV.W   #0x0, R15
   \   00015A   085E         ADD.W   R14, R8
   \   00015C   096F         ADDC.W  R15, R9
   2506          			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
   \   00015E   0F46         MOV.W   R6, R15
   \   000160   8F10         SWPB    R15
   \   000162   3FF0FF00     AND.W   #0xff, R15
   \   000166   0F11         RRA.W   R15
   \   000168   074F         MOV.W   R15, R7
   2507          			if (cc) {							/* Read maximum contiguous sectors directly */
   \   00016A   0793         CMP.W   #0x0, R7
   \   00016C   5924         JEQ     ??f_read_16
   2508          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   \   00016E   0F0A         MOVA    @R10, R15
   \   000170   5E4F0200     MOV.B   0x2(R15), R14
   \   000174   4E4E         MOV.B   R14, R14
   \   000176   6F41         MOV.B   @SP, R15
   \   000178   4F4F         MOV.B   R15, R15
   \   00017A   0F57         ADD.W   R7, R15
   \   00017C   0E9F         CMP.W   R15, R14
   \   00017E   082C         JC      ??f_read_17
   2509          					cc = fp->fs->csize - csect;
   \   000180   0F0A         MOVA    @R10, R15
   \   000182   5E4F0200     MOV.B   0x2(R15), R14
   \   000186   4E4E         MOV.B   R14, R14
   \   000188   6F41         MOV.B   @SP, R15
   \   00018A   4F4F         MOV.B   R15, R15
   \   00018C   0E8F         SUB.W   R15, R14
   \   00018E   074E         MOV.W   R14, R7
   2510          				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
   \                     ??f_read_17:
   \   000190   4712         PUSH.B  R7
   \   000192   0E48         MOV.W   R8, R14
   \   000194   0F49         MOV.W   R9, R15
   \   000196   3D010400     MOVA    0x4(SP), R13
   \   00019A   0C0A         MOVA    @R10, R12
   \   00019C   5C4C0100     MOV.B   0x1(R12), R12
   \   0001A0   ........     CALLA   #disk_read
   \   0001A4   2153         ADD.W   #0x2, SP
   \   0001A6   4C93         CMP.B   #0x0, R12
   \   0001A8   0624         JEQ     ??f_read_18
   2511          					ABORT(fp->fs, FR_DISK_ERR);
   \   0001AA   CF0A         MOVA    R10, R15
   \   0001AC   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   0001B2   5C43         MOV.B   #0x1, R12
   \   0001B4   A83C         JMP     ??f_read_2
   2512          #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
   2513          #if _FS_TINY
   2514          				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
   2515          					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
   2516          #else
   2517          				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
   \                     ??f_read_18:
   \   0001B6   FAB040000600 BIT.B   #0x40, 0x6(R10)
   \   0001BC   2A28         JNC     ??f_read_19
   \   0001BE   1C4A1800     MOV.W   0x18(R10), R12
   \   0001C2   1D4A1A00     MOV.W   0x1a(R10), R13
   \   0001C6   0C88         SUB.W   R8, R12
   \   0001C8   0D79         SUBC.W  R9, R13
   \   0001CA   0E47         MOV.W   R7, R14
   \   0001CC   0F43         MOV.W   #0x0, R15
   \   0001CE   0D9F         CMP.W   R15, R13
   \   0001D0   0328         JNC     ??f_read_20
   \   0001D2   1F20         JNE     ??f_read_19
   \   0001D4   0C9E         CMP.W   R14, R12
   \   0001D6   1D2C         JC      ??f_read_19
   2518          					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
   \                     ??f_read_20:
   \   0001D8   3E400002     MOV.W   #0x200, R14
   \   0001DC   CD0A         MOVA    R10, R13
   \   0001DE   AD002800     ADDA    #0x28, R13
   \   0001E2   0D14         PUSHM.A #0x1, R13
   \   0001E4   0E12         PUSH.W  R14
   \   0001E6   3F010800     MOVA    0x8(SP), R15
   \   0001EA   0F14         PUSHM.A #0x1, R15
   \   0001EC   1C4A1800     MOV.W   0x18(R10), R12
   \   0001F0   1D4A1A00     MOV.W   0x1a(R10), R13
   \   0001F4   0C88         SUB.W   R8, R12
   \   0001F6   0D79         SUBC.W  R9, R13
   \   0001F8   3E400002     MOV.W   #0x200, R14
   \   0001FC   0F43         MOV.W   #0x0, R15
   \   0001FE   ........     CALLA   #?Mul32
   \   000202   1D15         PUSHM.W #0x2, R13
   \   000204   0F16         POPM.A  #0x1, R15
   \   000206   0C16         POPM.A  #0x1, R12
   \   000208   EC0F         ADDA    R15, R12
   \   00020A   3E41         POP.W   R14
   \   00020C   0D16         POPM.A  #0x1, R13
   \   00020E   ........     CALLA   #mem_cpy
   2519          #endif
   2520          #endif
   2521          				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
   \                     ??f_read_19:
   \   000212   0F47         MOV.W   R7, R15
   \   000214   4F5F         RLA.B   R15
   \   000216   3FF0FF00     AND.W   #0xff, R15
   \   00021A   8F10         SWPB    R15
   \   00021C   0B4F         MOV.W   R15, R11
   2522          				continue;
   \   00021E   613C         JMP     ??f_read_21
   2523          			}
   2524          #if !_FS_TINY
   2525          			if (fp->dsect != sect) {			/* Load data sector if not in cache */
   \                     ??f_read_16:
   \   000220   8A981800     CMP.W   R8, 0x18(R10)
   \   000224   0320         JNE     ??f_read_22
   \   000226   8A991A00     CMP.W   R9, 0x1a(R10)
   \   00022A   3224         JEQ     ??f_read_23
   2526          #if !_FS_READONLY
   2527          				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   \                     ??f_read_22:
   \   00022C   FAB040000600 BIT.B   #0x40, 0x6(R10)
   \   000232   1A28         JNC     ??f_read_24
   2528          					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   000234   5312         PUSH.B  #0x1
   \   000236   1E4A1800     MOV.W   0x18(R10), R14
   \   00023A   1F4A1A00     MOV.W   0x1a(R10), R15
   \   00023E   CD0A         MOVA    R10, R13
   \   000240   AD002800     ADDA    #0x28, R13
   \   000244   0C0A         MOVA    @R10, R12
   \   000246   5C4C0100     MOV.B   0x1(R12), R12
   \   00024A   ........     CALLA   #disk_write
   \   00024E   2153         ADD.W   #0x2, SP
   \   000250   4C93         CMP.B   #0x0, R12
   \   000252   0624         JEQ     ??f_read_25
   2529          						ABORT(fp->fs, FR_DISK_ERR);
   \   000254   CF0A         MOVA    R10, R15
   \   000256   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   00025C   5C43         MOV.B   #0x1, R12
   \   00025E   533C         JMP     ??f_read_2
   2530          					fp->flag &= ~FA__DIRTY;
   \                     ??f_read_25:
   \   000260   CF0A         MOVA    R10, R15
   \   000262   FFC040000600 BIC.B   #0x40, 0x6(R15)
   2531          				}
   2532          #endif
   2533          				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
   \                     ??f_read_24:
   \   000268   5312         PUSH.B  #0x1
   \   00026A   0E48         MOV.W   R8, R14
   \   00026C   0F49         MOV.W   R9, R15
   \   00026E   CD0A         MOVA    R10, R13
   \   000270   AD002800     ADDA    #0x28, R13
   \   000274   0C0A         MOVA    @R10, R12
   \   000276   5C4C0100     MOV.B   0x1(R12), R12
   \   00027A   ........     CALLA   #disk_read
   \   00027E   2153         ADD.W   #0x2, SP
   \   000280   4C93         CMP.B   #0x0, R12
   \   000282   0624         JEQ     ??f_read_23
   2534          					ABORT(fp->fs, FR_DISK_ERR);
   \   000284   CF0A         MOVA    R10, R15
   \   000286   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   00028C   5C43         MOV.B   #0x1, R12
   \   00028E   3B3C         JMP     ??f_read_2
   2535          			}
   2536          #endif
   2537          			fp->dsect = sect;
   \                     ??f_read_23:
   \   000290   8A481800     MOV.W   R8, 0x18(R10)
   \   000294   8A491A00     MOV.W   R9, 0x1a(R10)
   2538          		}
   2539          		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
   \                     ??f_read_7:
   \   000298   3F400002     MOV.W   #0x200, R15
   \   00029C   0F12         PUSH.W  R15
   \   00029E   1C4A0800     MOV.W   0x8(R10), R12
   \   0002A2   3E400002     MOV.W   #0x200, R14
   \   0002A6   ........     CALLA   #?DivMod16u
   \   0002AA   3F41         POP.W   R15
   \   0002AC   0F8E         SUB.W   R14, R15
   \   0002AE   0B4F         MOV.W   R15, R11
   2540          		if (rcnt > btr) rcnt = btr;
   \   0002B0   069B         CMP.W   R11, R6
   \   0002B2   012C         JC      ??f_read_26
   \   0002B4   0B46         MOV.W   R6, R11
   2541          #if _FS_TINY
   2542          		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
   2543          			ABORT(fp->fs, FR_DISK_ERR);
   2544          		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   2545          #else
   2546          		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   \                     ??f_read_26:
   \   0002B6   0E4B         MOV.W   R11, R14
   \   0002B8   0E12         PUSH.W  R14
   \   0002BA   1C4A0800     MOV.W   0x8(R10), R12
   \   0002BE   1D4A0A00     MOV.W   0xa(R10), R13
   \   0002C2   3E400002     MOV.W   #0x200, R14
   \   0002C6   0F43         MOV.W   #0x0, R15
   \   0002C8   ........     CALLA   #?DivMod32u
   \   0002CC   1F15         PUSHM.W #0x2, R15
   \   0002CE   0F16         POPM.A  #0x1, R15
   \   0002D0   CD0A         MOVA    R10, R13
   \   0002D2   ED0F         ADDA    R15, R13
   \   0002D4   AD002800     ADDA    #0x28, R13
   \   0002D8   3E41         POP.W   R14
   \   0002DA   3C010200     MOVA    0x2(SP), R12
   \   0002DE   ........     CALLA   #mem_cpy
   2547          #endif
   2548          	}
   \                     ??f_read_21:
   \   0002E2   3F010200     MOVA    0x2(SP), R15
   \   0002E6   EF0B         ADDA    R11, R15
   \   0002E8   710F0200     MOVA    R15, 0x2(SP)
   \   0002EC   0E4B         MOV.W   R11, R14
   \   0002EE   0F43         MOV.W   #0x0, R15
   \   0002F0   8A5E0800     ADD.W   R14, 0x8(R10)
   \   0002F4   8A6F0A00     ADDC.W  R15, 0xa(R10)
   \   0002F8   3F010A00     MOVA    0xa(SP), R15
   \   0002FC   8F5B0000     ADD.W   R11, 0(R15)
   \   000300   068B         SUB.W   R11, R6
   \   000302   BA3E         JMP     ??f_read_0
   2549          
   2550          	LEAVE_FF(fp->fs, FR_OK);
   \                     ??f_read_6:
   \   000304   4C43         MOV.B   #0x0, R12
   \                     ??f_read_2:
   \   000306   31501200     ADD.W   #0x12, SP
   \   00030A   7416         POPM.A  #0x8, R11
   \   00030C   1001         RETA
   2551          }
   2552          
   2553          
   2554          
   2555          
   2556          #if !_FS_READONLY
   2557          /*-----------------------------------------------------------------------*/
   2558          /* Write File                                                            */
   2559          /*-----------------------------------------------------------------------*/
   2560          

   \                                 In  segment CODE, align 2
   2561          FRESULT f_write (
   \                     f_write:
   2562          	FIL *fp,			/* Pointer to the file object */
   2563          	const void *buff,	/* Pointer to the data to be written */
   2564          	UINT btw,			/* Number of bytes to write */
   2565          	UINT *bw			/* Pointer to number of bytes written */
   2566          )
   2567          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   0D14         PUSHM.A #0x1, R13
   \   000004   0F14         PUSHM.A #0x1, R15
   \   000006   31800600     SUB.W   #0x6, SP
   \   00000A   CA0C         MOVA    R12, R10
   \   00000C   0B4E         MOV.W   R14, R11
   2568          	FRESULT res;
   2569          	DWORD clst, sect;
   2570          	UINT wcnt, cc;
   2571          	const BYTE *wbuff = buff;
   \   00000E   0018D1410A00 MOVX.A  0xa(SP), 0x2(SP)
   \            0200        
   2572          	BYTE csect;
   2573          
   2574          
   2575          	*bw = 0;	/* Clear write byte counter */
   \   000016   3F010600     MOVA    0x6(SP), R15
   \   00001A   8F430000     MOV.W   #0x0, 0(R15)
   2576          
   2577          	res = validate(fp);						/* Check validity */
   \   00001E   CC0A         MOVA    R10, R12
   \   000020   ........     CALLA   #validate
   \   000024   C14C0100     MOV.B   R12, 0x1(SP)
   2578          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   000028   C1930100     CMP.B   #0x0, 0x1(SP)
   \   00002C   0324         JEQ     ??f_write_3
   \   00002E   5C410100     MOV.B   0x1(SP), R12
   \   000032   923D         JMP     ??f_write_4
   2579          	if (fp->flag & FA__ERROR)				/* Aborted file? */
   \                     ??f_write_3:
   \   000034   CA930600     CMP.B   #0x0, 0x6(R10)
   \   000038   0234         JGE     ??f_write_5
   2580          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00003A   6C43         MOV.B   #0x2, R12
   \   00003C   8D3D         JMP     ??f_write_4
   2581          	if (!(fp->flag & FA_WRITE))				/* Check access mode */
   \                     ??f_write_5:
   \   00003E   EAB30600     BIT.B   #0x2, 0x6(R10)
   \   000042   032C         JC      ??f_write_6
   2582          		LEAVE_FF(fp->fs, FR_DENIED);
   \   000044   7C400700     MOV.B   #0x7, R12
   \   000048   873D         JMP     ??f_write_4
   2583          	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
   \                     ??f_write_6:
   \   00004A   0E4B         MOV.W   R11, R14
   \   00004C   0F43         MOV.W   #0x0, R15
   \   00004E   1E5A0C00     ADD.W   0xc(R10), R14
   \   000052   1F6A0E00     ADDC.W  0xe(R10), R15
   \   000056   1F9A0E00     CMP.W   0xe(R10), R15
   \   00005A   0428         JNC     ??f_write_7
   \   00005C   0420         JNE     ??f_write_0
   \   00005E   1E9A0C00     CMP.W   0xc(R10), R14
   \   000062   012C         JC      ??f_write_0
   \                     ??f_write_7:
   \   000064   0B43         MOV.W   #0x0, R11
   2584          
   2585          	for ( ;  btw;							/* Repeat until all data written */
   \                     ??f_write_0:
   \   000066   0B93         CMP.W   #0x0, R11
   \   000068   6325         JEQ     ??f_write_2
   2586          		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
   2587          		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
   \   00006A   1C4A0800     MOV.W   0x8(R10), R12
   \   00006E   1D4A0A00     MOV.W   0xa(R10), R13
   \   000072   3E400002     MOV.W   #0x200, R14
   \   000076   0F43         MOV.W   #0x0, R15
   \   000078   ........     CALLA   #?DivMod32u
   \   00007C   0D4E         MOV.W   R14, R13
   \   00007E   0DDF         BIS.W   R15, R13
   \   000080   0D93         CMP.W   #0x0, R13
   \   000082   1A21         JNE     ??f_write_8
   2588          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   \   000084   1C4A0800     MOV.W   0x8(R10), R12
   \   000088   1D4A0A00     MOV.W   0xa(R10), R13
   \   00008C   ........     CALLA   #?ShiftRight32u_9
   \   000090   0F0A         MOVA    @R10, R15
   \   000092   5E4F0200     MOV.B   0x2(R15), R14
   \   000096   4E4E         MOV.B   R14, R14
   \   000098   3E53         ADD.W   #0xffff, R14
   \   00009A   4CFE         AND.B   R14, R12
   \   00009C   C14C0000     MOV.B   R12, 0(SP)
   2589          			if (!csect) {					/* On the cluster boundary? */
   \   0000A0   C1930000     CMP.B   #0x0, 0(SP)
   \   0000A4   4D20         JNE     ??f_write_9
   2590          				if (fp->fptr == 0) {		/* On the top of the file? */
   \   0000A6   1F4A0800     MOV.W   0x8(R10), R15
   \   0000AA   1FDA0A00     BIS.W   0xa(R10), R15
   \   0000AE   0F93         CMP.W   #0x0, R15
   \   0000B0   1420         JNE     ??f_write_10
   2591          					clst = fp->sclust;		/* Follow from the origin */
   \   0000B2   164A1000     MOV.W   0x10(R10), R6
   \   0000B6   174A1200     MOV.W   0x12(R10), R7
   2592          					if (clst == 0)			/* When no cluster is allocated, */
   \   0000BA   0F46         MOV.W   R6, R15
   \   0000BC   0FD7         BIS.W   R7, R15
   \   0000BE   0F93         CMP.W   #0x0, R15
   \   0000C0   2320         JNE     ??f_write_11
   2593          						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
   \   0000C2   0E43         MOV.W   #0x0, R14
   \   0000C4   0F43         MOV.W   #0x0, R15
   \   0000C6   0C0A         MOVA    @R10, R12
   \   0000C8   ........     CALLA   #create_chain
   \   0000CC   064C         MOV.W   R12, R6
   \   0000CE   074D         MOV.W   R13, R7
   \   0000D0   8A4C1000     MOV.W   R12, 0x10(R10)
   \   0000D4   8A4D1200     MOV.W   R13, 0x12(R10)
   \   0000D8   173C         JMP     ??f_write_11
   2594          				} else {					/* Middle or end of the file */
   2595          #if _USE_FASTSEEK
   2596          					if (fp->cltbl)
   \                     ??f_write_10:
   \   0000DA   3F0A2400     MOVA    0x24(R10), R15
   \   0000DE   DF03         CMPA    #0x0, R15
   \   0000E0   0A24         JEQ     ??f_write_12
   2597          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   \   0000E2   1E4A0800     MOV.W   0x8(R10), R14
   \   0000E6   1F4A0A00     MOV.W   0xa(R10), R15
   \   0000EA   CC0A         MOVA    R10, R12
   \   0000EC   ........     CALLA   #clmt_clust
   \   0000F0   064C         MOV.W   R12, R6
   \   0000F2   074D         MOV.W   R13, R7
   \   0000F4   093C         JMP     ??f_write_11
   2598          					else
   2599          #endif
   2600          						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
   \                     ??f_write_12:
   \   0000F6   1E4A1400     MOV.W   0x14(R10), R14
   \   0000FA   1F4A1600     MOV.W   0x16(R10), R15
   \   0000FE   0C0A         MOVA    @R10, R12
   \   000100   ........     CALLA   #create_chain
   \   000104   064C         MOV.W   R12, R6
   \   000106   074D         MOV.W   R13, R7
   2601          				}
   2602          				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
   \                     ??f_write_11:
   \   000108   0F46         MOV.W   R6, R15
   \   00010A   0FD7         BIS.W   R7, R15
   \   00010C   0F93         CMP.W   #0x0, R15
   \   00010E   1025         JEQ     ??f_write_2
   2603          				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   \   000110   1693         CMP.W   #0x1, R6
   \   000112   0820         JNE     ??f_write_13
   \   000114   0793         CMP.W   #0x0, R7
   \   000116   0620         JNE     ??f_write_13
   \   000118   CF0A         MOVA    R10, R15
   \   00011A   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   000120   6C43         MOV.B   #0x2, R12
   \   000122   1A3D         JMP     ??f_write_4
   2604          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_write_13:
   \   000124   3693         CMP.W   #0xffff, R6
   \   000126   0820         JNE     ??f_write_14
   \   000128   3793         CMP.W   #0xffff, R7
   \   00012A   0620         JNE     ??f_write_14
   \   00012C   CF0A         MOVA    R10, R15
   \   00012E   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   000134   5C43         MOV.B   #0x1, R12
   \   000136   103D         JMP     ??f_write_4
   2605          				fp->clust = clst;			/* Update current cluster */
   \                     ??f_write_14:
   \   000138   8A461400     MOV.W   R6, 0x14(R10)
   \   00013C   8A471600     MOV.W   R7, 0x16(R10)
   2606          			}
   2607          #if _FS_TINY
   2608          			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
   2609          				ABORT(fp->fs, FR_DISK_ERR);
   2610          #else
   2611          			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
   \                     ??f_write_9:
   \   000140   FAB040000600 BIT.B   #0x40, 0x6(R10)
   \   000146   1A28         JNC     ??f_write_15
   2612          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   000148   5312         PUSH.B  #0x1
   \   00014A   1E4A1800     MOV.W   0x18(R10), R14
   \   00014E   1F4A1A00     MOV.W   0x1a(R10), R15
   \   000152   CD0A         MOVA    R10, R13
   \   000154   AD002800     ADDA    #0x28, R13
   \   000158   0C0A         MOVA    @R10, R12
   \   00015A   5C4C0100     MOV.B   0x1(R12), R12
   \   00015E   ........     CALLA   #disk_write
   \   000162   2153         ADD.W   #0x2, SP
   \   000164   4C93         CMP.B   #0x0, R12
   \   000166   0624         JEQ     ??f_write_16
   2613          					ABORT(fp->fs, FR_DISK_ERR);
   \   000168   CF0A         MOVA    R10, R15
   \   00016A   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   000170   5C43         MOV.B   #0x1, R12
   \   000172   F23C         JMP     ??f_write_4
   2614          				fp->flag &= ~FA__DIRTY;
   \                     ??f_write_16:
   \   000174   CF0A         MOVA    R10, R15
   \   000176   FFC040000600 BIC.B   #0x40, 0x6(R15)
   2615          			}
   2616          #endif
   2617          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   \                     ??f_write_15:
   \   00017C   1E4A1400     MOV.W   0x14(R10), R14
   \   000180   1F4A1600     MOV.W   0x16(R10), R15
   \   000184   0C0A         MOVA    @R10, R12
   \   000186   ........     CALLA   #clust2sect
   \   00018A   084C         MOV.W   R12, R8
   \   00018C   094D         MOV.W   R13, R9
   2618          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   \   00018E   0F48         MOV.W   R8, R15
   \   000190   0FD9         BIS.W   R9, R15
   \   000192   0F93         CMP.W   #0x0, R15
   \   000194   0620         JNE     ??f_write_17
   \   000196   CF0A         MOVA    R10, R15
   \   000198   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   00019E   6C43         MOV.B   #0x2, R12
   \   0001A0   DB3C         JMP     ??f_write_4
   2619          			sect += csect;
   \                     ??f_write_17:
   \   0001A2   6E41         MOV.B   @SP, R14
   \   0001A4   4E4E         MOV.B   R14, R14
   \   0001A6   0F43         MOV.W   #0x0, R15
   \   0001A8   085E         ADD.W   R14, R8
   \   0001AA   096F         ADDC.W  R15, R9
   2620          			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
   \   0001AC   0F4B         MOV.W   R11, R15
   \   0001AE   8F10         SWPB    R15
   \   0001B0   3FF0FF00     AND.W   #0xff, R15
   \   0001B4   0F11         RRA.W   R15
   \   0001B6   054F         MOV.W   R15, R5
   2621          			if (cc) {						/* Write maximum contiguous sectors directly */
   \   0001B8   0593         CMP.W   #0x0, R5
   \   0001BA   5724         JEQ     ??f_write_18
   2622          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   \   0001BC   0F0A         MOVA    @R10, R15
   \   0001BE   5E4F0200     MOV.B   0x2(R15), R14
   \   0001C2   4E4E         MOV.B   R14, R14
   \   0001C4   6F41         MOV.B   @SP, R15
   \   0001C6   4F4F         MOV.B   R15, R15
   \   0001C8   0F55         ADD.W   R5, R15
   \   0001CA   0E9F         CMP.W   R15, R14
   \   0001CC   082C         JC      ??f_write_19
   2623          					cc = fp->fs->csize - csect;
   \   0001CE   0F0A         MOVA    @R10, R15
   \   0001D0   5E4F0200     MOV.B   0x2(R15), R14
   \   0001D4   4E4E         MOV.B   R14, R14
   \   0001D6   6F41         MOV.B   @SP, R15
   \   0001D8   4F4F         MOV.B   R15, R15
   \   0001DA   0E8F         SUB.W   R15, R14
   \   0001DC   054E         MOV.W   R14, R5
   2624          				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
   \                     ??f_write_19:
   \   0001DE   4512         PUSH.B  R5
   \   0001E0   0E48         MOV.W   R8, R14
   \   0001E2   0F49         MOV.W   R9, R15
   \   0001E4   3D010400     MOVA    0x4(SP), R13
   \   0001E8   0C0A         MOVA    @R10, R12
   \   0001EA   5C4C0100     MOV.B   0x1(R12), R12
   \   0001EE   ........     CALLA   #disk_write
   \   0001F2   2153         ADD.W   #0x2, SP
   \   0001F4   4C93         CMP.B   #0x0, R12
   \   0001F6   0624         JEQ     ??f_write_20
   2625          					ABORT(fp->fs, FR_DISK_ERR);
   \   0001F8   CF0A         MOVA    R10, R15
   \   0001FA   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   000200   5C43         MOV.B   #0x1, R12
   \   000202   AA3C         JMP     ??f_write_4
   2626          #if _FS_TINY
   2627          				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
   2628          					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
   2629          					fp->fs->wflag = 0;
   2630          				}
   2631          #else
   2632          				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
   \                     ??f_write_20:
   \   000204   1C4A1800     MOV.W   0x18(R10), R12
   \   000208   1D4A1A00     MOV.W   0x1a(R10), R13
   \   00020C   0C88         SUB.W   R8, R12
   \   00020E   0D79         SUBC.W  R9, R13
   \   000210   0E45         MOV.W   R5, R14
   \   000212   0F43         MOV.W   #0x0, R15
   \   000214   0D9F         CMP.W   R15, R13
   \   000216   0328         JNC     ??f_write_21
   \   000218   2120         JNE     ??f_write_22
   \   00021A   0C9E         CMP.W   R14, R12
   \   00021C   1F2C         JC      ??f_write_22
   2633          					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
   \                     ??f_write_21:
   \   00021E   3E400002     MOV.W   #0x200, R14
   \   000222   0E12         PUSH.W  R14
   \   000224   3F010400     MOVA    0x4(SP), R15
   \   000228   0F14         PUSHM.A #0x1, R15
   \   00022A   1C4A1800     MOV.W   0x18(R10), R12
   \   00022E   1D4A1A00     MOV.W   0x1a(R10), R13
   \   000232   0C88         SUB.W   R8, R12
   \   000234   0D79         SUBC.W  R9, R13
   \   000236   3E400002     MOV.W   #0x200, R14
   \   00023A   0F43         MOV.W   #0x0, R15
   \   00023C   ........     CALLA   #?Mul32
   \   000240   1D15         PUSHM.W #0x2, R13
   \   000242   0F16         POPM.A  #0x1, R15
   \   000244   0D16         POPM.A  #0x1, R13
   \   000246   ED0F         ADDA    R15, R13
   \   000248   3E41         POP.W   R14
   \   00024A   CC0A         MOVA    R10, R12
   \   00024C   AC002800     ADDA    #0x28, R12
   \   000250   ........     CALLA   #mem_cpy
   2634          					fp->flag &= ~FA__DIRTY;
   \   000254   CF0A         MOVA    R10, R15
   \   000256   FFC040000600 BIC.B   #0x40, 0x6(R15)
   2635          				}
   2636          #endif
   2637          				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
   \                     ??f_write_22:
   \   00025C   0F45         MOV.W   R5, R15
   \   00025E   4F5F         RLA.B   R15
   \   000260   3FF0FF00     AND.W   #0xff, R15
   \   000264   8F10         SWPB    R15
   \   000266   044F         MOV.W   R15, R4
   2638          				continue;
   \   000268   523C         JMP     ??f_write_23
   2639          			}
   2640          #if _FS_TINY
   2641          			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
   2642          				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
   2643          				fp->fs->winsect = sect;
   2644          			}
   2645          #else
   2646          			if (fp->dsect != sect) {		/* Fill sector cache with file data */
   \                     ??f_write_18:
   \   00026A   8A981800     CMP.W   R8, 0x18(R10)
   \   00026E   0320         JNE     ??f_write_24
   \   000270   8A991A00     CMP.W   R9, 0x1a(R10)
   \   000274   1D24         JEQ     ??f_write_25
   2647          				if (fp->fptr < fp->fsize &&
   2648          					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
   \                     ??f_write_24:
   \   000276   9A9A0E000A00 CMP.W   0xe(R10), 0xa(R10)
   \   00027C   0528         JNC     ??f_write_26
   \   00027E   1820         JNE     ??f_write_25
   \   000280   9A9A0C000800 CMP.W   0xc(R10), 0x8(R10)
   \   000286   142C         JC      ??f_write_25
   \                     ??f_write_26:
   \   000288   5312         PUSH.B  #0x1
   \   00028A   0E48         MOV.W   R8, R14
   \   00028C   0F49         MOV.W   R9, R15
   \   00028E   CD0A         MOVA    R10, R13
   \   000290   AD002800     ADDA    #0x28, R13
   \   000294   0C0A         MOVA    @R10, R12
   \   000296   5C4C0100     MOV.B   0x1(R12), R12
   \   00029A   ........     CALLA   #disk_read
   \   00029E   2153         ADD.W   #0x2, SP
   \   0002A0   4C93         CMP.B   #0x0, R12
   \   0002A2   0624         JEQ     ??f_write_25
   2649          						ABORT(fp->fs, FR_DISK_ERR);
   \   0002A4   CF0A         MOVA    R10, R15
   \   0002A6   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   0002AC   5C43         MOV.B   #0x1, R12
   \   0002AE   543C         JMP     ??f_write_4
   2650          			}
   2651          #endif
   2652          			fp->dsect = sect;
   \                     ??f_write_25:
   \   0002B0   8A481800     MOV.W   R8, 0x18(R10)
   \   0002B4   8A491A00     MOV.W   R9, 0x1a(R10)
   2653          		}
   2654          		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
   \                     ??f_write_8:
   \   0002B8   3F400002     MOV.W   #0x200, R15
   \   0002BC   0F12         PUSH.W  R15
   \   0002BE   1C4A0800     MOV.W   0x8(R10), R12
   \   0002C2   3E400002     MOV.W   #0x200, R14
   \   0002C6   ........     CALLA   #?DivMod16u
   \   0002CA   3F41         POP.W   R15
   \   0002CC   0F8E         SUB.W   R14, R15
   \   0002CE   044F         MOV.W   R15, R4
   2655          		if (wcnt > btw) wcnt = btw;
   \   0002D0   0B94         CMP.W   R4, R11
   \   0002D2   012C         JC      ??f_write_27
   \   0002D4   044B         MOV.W   R11, R4
   2656          #if _FS_TINY
   2657          		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
   2658          			ABORT(fp->fs, FR_DISK_ERR);
   2659          		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   2660          		fp->fs->wflag = 1;
   2661          #else
   2662          		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   \                     ??f_write_27:
   \   0002D6   0E44         MOV.W   R4, R14
   \   0002D8   3D010200     MOVA    0x2(SP), R13
   \   0002DC   0D14         PUSHM.A #0x1, R13
   \   0002DE   0E12         PUSH.W  R14
   \   0002E0   1C4A0800     MOV.W   0x8(R10), R12
   \   0002E4   1D4A0A00     MOV.W   0xa(R10), R13
   \   0002E8   3E400002     MOV.W   #0x200, R14
   \   0002EC   0F43         MOV.W   #0x0, R15
   \   0002EE   ........     CALLA   #?DivMod32u
   \   0002F2   1F15         PUSHM.W #0x2, R15
   \   0002F4   0F16         POPM.A  #0x1, R15
   \   0002F6   CC0A         MOVA    R10, R12
   \   0002F8   EC0F         ADDA    R15, R12
   \   0002FA   AC002800     ADDA    #0x28, R12
   \   0002FE   3E41         POP.W   R14
   \   000300   0D16         POPM.A  #0x1, R13
   \   000302   ........     CALLA   #mem_cpy
   2663          		fp->flag |= FA__DIRTY;
   \   000306   CF0A         MOVA    R10, R15
   \   000308   FFD040000600 BIS.B   #0x40, 0x6(R15)
   2664          #endif
   2665          	}
   \                     ??f_write_23:
   \   00030E   3F010200     MOVA    0x2(SP), R15
   \   000312   EF04         ADDA    R4, R15
   \   000314   710F0200     MOVA    R15, 0x2(SP)
   \   000318   0E44         MOV.W   R4, R14
   \   00031A   0F43         MOV.W   #0x0, R15
   \   00031C   8A5E0800     ADD.W   R14, 0x8(R10)
   \   000320   8A6F0A00     ADDC.W  R15, 0xa(R10)
   \   000324   3F010600     MOVA    0x6(SP), R15
   \   000328   8F540000     ADD.W   R4, 0(R15)
   \   00032C   0B84         SUB.W   R4, R11
   \   00032E   9B3E         JMP     ??f_write_0
   2666          
   2667          	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
   \                     ??f_write_2:
   \   000330   9A9A0A000E00 CMP.W   0xa(R10), 0xe(R10)
   \   000336   0528         JNC     ??f_write_28
   \   000338   0A20         JNE     ??f_write_29
   \   00033A   9A9A08000C00 CMP.W   0x8(R10), 0xc(R10)
   \   000340   062C         JC      ??f_write_29
   \                     ??f_write_28:
   \   000342   9A4A08000C00 MOV.W   0x8(R10), 0xc(R10)
   \   000348   9A4A0A000E00 MOV.W   0xa(R10), 0xe(R10)
   2668          	fp->flag |= FA__WRITTEN;						/* Set file change flag */
   \                     ??f_write_29:
   \   00034E   CF0A         MOVA    R10, R15
   \   000350   FFD020000600 BIS.B   #0x20, 0x6(R15)
   2669          
   2670          	LEAVE_FF(fp->fs, FR_OK);
   \   000356   4C43         MOV.B   #0x0, R12
   \                     ??f_write_4:
   \   000358   31500E00     ADD.W   #0xe, SP
   \   00035C   7416         POPM.A  #0x8, R11
   \   00035E   1001         RETA
   2671          }
   2672          
   2673          
   2674          
   2675          
   2676          /*-----------------------------------------------------------------------*/
   2677          /* Synchronize the File Object                                           */
   2678          /*-----------------------------------------------------------------------*/
   2679          

   \                                 In  segment CODE, align 2
   2680          FRESULT f_sync (
   \                     f_sync:
   2681          	FIL *fp		/* Pointer to the file object */
   2682          )
   2683          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   CA0C         MOVA    R12, R10
   2684          	FRESULT res;
   2685          	DWORD tim;
   2686          	BYTE *dir;
   2687          
   2688          
   2689          	res = validate(fp);					/* Check validity of the object */
   \   000004   CC0A         MOVA    R10, R12
   \   000006   ........     CALLA   #validate
   \   00000A   464C         MOV.B   R12, R6
   2690          	if (res == FR_OK) {
   \   00000C   4693         CMP.B   #0x0, R6
   \   00000E   6C20         JNE     ??f_sync_0
   2691          		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
   \   000010   FAB020000600 BIT.B   #0x20, 0x6(R10)
   \   000016   6828         JNC     ??f_sync_0
   2692          #if !_FS_TINY	/* Write-back dirty buffer */
   2693          			if (fp->flag & FA__DIRTY) {
   \   000018   FAB040000600 BIT.B   #0x40, 0x6(R10)
   \   00001E   1628         JNC     ??f_sync_1
   2694          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   000020   5312         PUSH.B  #0x1
   \   000022   1E4A1800     MOV.W   0x18(R10), R14
   \   000026   1F4A1A00     MOV.W   0x1a(R10), R15
   \   00002A   CD0A         MOVA    R10, R13
   \   00002C   AD002800     ADDA    #0x28, R13
   \   000030   0C0A         MOVA    @R10, R12
   \   000032   5C4C0100     MOV.B   0x1(R12), R12
   \   000036   ........     CALLA   #disk_write
   \   00003A   2153         ADD.W   #0x2, SP
   \   00003C   4C93         CMP.B   #0x0, R12
   \   00003E   0224         JEQ     ??f_sync_2
   2695          					LEAVE_FF(fp->fs, FR_DISK_ERR);
   \   000040   5C43         MOV.B   #0x1, R12
   \   000042   533C         JMP     ??f_sync_3
   2696          				fp->flag &= ~FA__DIRTY;
   \                     ??f_sync_2:
   \   000044   CF0A         MOVA    R10, R15
   \   000046   FFC040000600 BIC.B   #0x40, 0x6(R15)
   2697          			}
   2698          #endif
   2699          			/* Update the directory entry */
   2700          			res = move_window(fp->fs, fp->dir_sect);
   \                     ??f_sync_1:
   \   00004C   1E4A1C00     MOV.W   0x1c(R10), R14
   \   000050   1F4A1E00     MOV.W   0x1e(R10), R15
   \   000054   0C0A         MOVA    @R10, R12
   \   000056   ........     CALLA   #move_window
   \   00005A   464C         MOV.B   R12, R6
   2701          			if (res == FR_OK) {
   \   00005C   4693         CMP.B   #0x0, R6
   \   00005E   4420         JNE     ??f_sync_0
   2702          				dir = fp->dir_ptr;
   \   000060   3B0A2000     MOVA    0x20(R10), R11
   2703          				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
   \   000064   CF0B         MOVA    R11, R15
   \   000066   FFD020000B00 BIS.B   #0x20, 0xb(R15)
   2704          				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
   \   00006C   DB4A0C001C00 MOV.B   0xc(R10), 0x1c(R11)
   \   000072   DB4A0D001D00 MOV.B   0xd(R10), 0x1d(R11)
   \   000078   1E4A0E00     MOV.W   0xe(R10), R14
   \   00007C   CB4E1E00     MOV.B   R14, 0x1e(R11)
   \   000080   1E4A0C00     MOV.W   0xc(R10), R14
   \   000084   1F4A0E00     MOV.W   0xe(R10), R15
   \   000088   8F10         SWPB    R15
   \   00008A   4E4F         MOV.B   R15, R14
   \   00008C   0F43         MOV.W   #0x0, R15
   \   00008E   CB4E1F00     MOV.B   R14, 0x1f(R11)
   2705          				st_clust(dir, fp->sclust);					/* Update start cluster */
   \   000092   1E4A1000     MOV.W   0x10(R10), R14
   \   000096   1F4A1200     MOV.W   0x12(R10), R15
   \   00009A   CC0B         MOVA    R11, R12
   \   00009C   ........     CALLA   #st_clust
   2706          				tim = get_fattime();						/* Update updated time */
   \   0000A0   ........     CALLA   #get_fattime
   \   0000A4   084C         MOV.W   R12, R8
   \   0000A6   094D         MOV.W   R13, R9
   2707          				ST_DWORD(dir+DIR_WrtTime, tim);
   \   0000A8   CB481600     MOV.B   R8, 0x16(R11)
   \   0000AC   0F48         MOV.W   R8, R15
   \   0000AE   8F10         SWPB    R15
   \   0000B0   3FF0FF00     AND.W   #0xff, R15
   \   0000B4   CB4F1700     MOV.B   R15, 0x17(R11)
   \   0000B8   CB491800     MOV.B   R9, 0x18(R11)
   \   0000BC   0E48         MOV.W   R8, R14
   \   0000BE   0F49         MOV.W   R9, R15
   \   0000C0   8F10         SWPB    R15
   \   0000C2   4E4F         MOV.B   R15, R14
   \   0000C4   0F43         MOV.W   #0x0, R15
   \   0000C6   CB4E1900     MOV.B   R14, 0x19(R11)
   2708          				ST_WORD(dir+DIR_LstAccDate, 0);
   \   0000CA   CB431200     MOV.B   #0x0, 0x12(R11)
   \   0000CE   CB431300     MOV.B   #0x0, 0x13(R11)
   2709          				fp->flag &= ~FA__WRITTEN;
   \   0000D2   CF0A         MOVA    R10, R15
   \   0000D4   FFC020000600 BIC.B   #0x20, 0x6(R15)
   2710          				fp->fs->wflag = 1;
   \   0000DA   0F0A         MOVA    @R10, R15
   \   0000DC   DF430400     MOV.B   #0x1, 0x4(R15)
   2711          				res = sync(fp->fs);
   \   0000E0   0C0A         MOVA    @R10, R12
   \   0000E2   ........     CALLA   #sync
   \   0000E6   464C         MOV.B   R12, R6
   2712          			}
   2713          		}
   2714          	}
   2715          
   2716          	LEAVE_FF(fp->fs, res);
   \                     ??f_sync_0:
   \   0000E8   4C46         MOV.B   R6, R12
   \                     ??f_sync_3:
   \   0000EA   5616         POPM.A  #0x6, R11
   \   0000EC   1001         RETA
   2717          }
   2718          
   2719          #endif /* !_FS_READONLY */
   2720          
   2721          
   2722          
   2723          
   2724          /*-----------------------------------------------------------------------*/
   2725          /* Close File                                                            */
   2726          /*-----------------------------------------------------------------------*/
   2727          

   \                                 In  segment CODE, align 2
   2728          FRESULT f_close (
   \                     f_close:
   2729          	FIL *fp		/* Pointer to the file object to be closed */
   2730          )
   2731          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   CA0C         MOVA    R12, R10
   2732          	FRESULT res;
   2733          
   2734          
   2735          #if _FS_READONLY
   2736          	res = validate(fp);
   2737          	{
   2738          #if _FS_REENTRANT
   2739          		FATFS *fs = fp->fs;
   2740          #endif
   2741          		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
   2742          		LEAVE_FF(fs, res);
   2743          	}
   2744          #else
   2745          	res = f_sync(fp);		/* Flush cached data */
   \   000004   CC0A         MOVA    R10, R12
   \   000006   ........     CALLA   #f_sync
   \   00000A   4B4C         MOV.B   R12, R11
   2746          #if _FS_LOCK
   2747          	if (res == FR_OK) {		/* Decrement open counter */
   2748          #if _FS_REENTRANT
   2749          		FATFS *fs = fp->fs;;
   2750          		res = validate(fp);
   2751          		if (res == FR_OK) {
   2752          			res = dec_lock(fp->lockid);	
   2753          			unlock_fs(fs, FR_OK);
   2754          		}
   2755          #else
   2756          		res = dec_lock(fp->lockid);
   2757          #endif
   2758          	}
   2759          #endif
   2760          	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
   \   00000C   4B93         CMP.B   #0x0, R11
   \   00000E   0320         JNE     ??f_close_0
   \   000010   0018CA430000 MOVX.A  #0x0, 0(R10)
   2761          	return res;
   \                     ??f_close_0:
   \   000016   4C4B         MOV.B   R11, R12
   \   000018   1A16         POPM.A  #0x2, R11
   \   00001A   1001         RETA
   2762          #endif
   2763          }
   2764          
   2765          
   2766          
   2767          
   2768          /*-----------------------------------------------------------------------*/
   2769          /* Current Drive/Directory Handlings                                     */
   2770          /*-----------------------------------------------------------------------*/
   2771          
   2772          #if _FS_RPATH >= 1
   2773          

   \                                 In  segment CODE, align 2
   2774          FRESULT f_chdrive (
   \                     f_chdrive:
   2775          	BYTE drv		/* Drive number */
   2776          )
   2777          {
   \   000000   4E4C         MOV.B   R12, R14
   2778          	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
   \   000002   4E93         CMP.B   #0x0, R14
   \   000004   0324         JEQ     ??f_chdrive_0
   \   000006   7C400B00     MOV.B   #0xb, R12
   \   00000A   1001         RETA
   2779          
   2780          	CurrVol = drv;
   \                     ??f_chdrive_0:
   \   00000C   ....C24E.... MOVX.B  R14, &CurrVol
   2781          
   2782          	return FR_OK;
   \   000012   4C43         MOV.B   #0x0, R12
   \   000014   1001         RETA
   2783          }
   2784          
   2785          
   2786          

   \                                 In  segment CODE, align 2
   2787          FRESULT f_chdir (
   \                     f_chdir:
   2788          	const TCHAR *path	/* Pointer to the directory path */
   2789          )
   2790          {
   \   000000   0A14         PUSHM.A #0x1, R10
   \   000002   0C14         PUSHM.A #0x1, R12
   \   000004   3180F800     SUB.W   #0xf8, SP
   2791          	FRESULT res;
   2792          	DIR dj;
   2793          	DEF_NAMEBUF;
   2794          
   2795          
   2796          	res = chk_mounted(&path, &dj.fs, 0);
   \   000008   4E43         MOV.B   #0x0, R14
   \   00000A   0D41         MOV.W   SP, R13
   \   00000C   0D53         ADD.W   #0x0, R13
   \   00000E   0C41         MOV.W   SP, R12
   \   000010   3C50F800     ADD.W   #0xf8, R12
   \   000014   ........     CALLA   #chk_mounted
   \   000018   4A4C         MOV.B   R12, R10
   2797          	if (res == FR_OK) {
   \   00001A   4A93         CMP.B   #0x0, R10
   \   00001C   3620         JNE     ??f_chdir_0
   2798          		INIT_BUF(dj);
   \   00001E   0F41         MOV.W   SP, R15
   \   000020   3F502200     ADD.W   #0x22, R15
   \   000024   710F1800     MOVA    R15, 0x18(SP)
   \   000028   0F41         MOV.W   SP, R15
   \   00002A   3F502E00     ADD.W   #0x2e, R15
   \   00002E   710F1C00     MOVA    R15, 0x1c(SP)
   2799          		res = follow_path(&dj, path);		/* Follow the path */
   \   000032   3D01F800     MOVA    0xf8(SP), R13
   \   000036   0C41         MOV.W   SP, R12
   \   000038   0C53         ADD.W   #0x0, R12
   \   00003A   ........     CALLA   #follow_path
   \   00003E   4A4C         MOV.B   R12, R10
   2800          		FREE_BUF();
   2801          		if (res == FR_OK) {					/* Follow completed */
   \   000040   4A93         CMP.B   #0x0, R10
   \   000042   1F20         JNE     ??f_chdir_1
   2802          			if (!dj.dir) {
   \   000044   3F011400     MOVA    0x14(SP), R15
   \   000048   DF03         CMPA    #0x0, R15
   \   00004A   0820         JNE     ??f_chdir_2
   2803          				dj.fs->cdir = dj.sclust;	/* Start directory itself */
   \   00004C   0F01         MOVA    @SP, R15
   \   00004E   9F4108001600 MOV.W   0x8(SP), 0x16(R15)
   \   000054   9F410A001800 MOV.W   0xa(SP), 0x18(R15)
   \   00005A   133C         JMP     ??f_chdir_1
   2804          			} else {
   2805          				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
   \                     ??f_chdir_2:
   \   00005C   3F011400     MOVA    0x14(SP), R15
   \   000060   FFB010000B00 BIT.B   #0x10, 0xb(R15)
   \   000066   0B28         JNC     ??f_chdir_3
   2806          					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
   \   000068   3D011400     MOVA    0x14(SP), R13
   \   00006C   0C01         MOVA    @SP, R12
   \   00006E   ........     CALLA   #ld_clust
   \   000072   0F01         MOVA    @SP, R15
   \   000074   8F4C1600     MOV.W   R12, 0x16(R15)
   \   000078   8F4D1800     MOV.W   R13, 0x18(R15)
   \   00007C   023C         JMP     ??f_chdir_1
   2807          				else
   2808          					res = FR_NO_PATH;		/* Reached but a file */
   \                     ??f_chdir_3:
   \   00007E   7A400500     MOV.B   #0x5, R10
   2809          			}
   2810          		}
   2811          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_chdir_1:
   \   000082   6A92         CMP.B   #0x4, R10
   \   000084   0220         JNE     ??f_chdir_0
   \   000086   7A400500     MOV.B   #0x5, R10
   2812          	}
   2813          
   2814          	LEAVE_FF(dj.fs, res);
   \                     ??f_chdir_0:
   \   00008A   4C4A         MOV.B   R10, R12
   \   00008C   3150FC00     ADD.W   #0xfc, SP
   \   000090   0A16         POPM.A  #0x1, R10
   \   000092   1001         RETA
   2815          }
   2816          
   2817          
   2818          #if _FS_RPATH >= 2

   \                                 In  segment CODE, align 2
   2819          FRESULT f_getcwd (
   \                     f_getcwd:
   2820          	TCHAR *path,	/* Pointer to the directory path */
   2821          	UINT sz_path	/* Size of path */
   2822          )
   2823          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   0C14         PUSHM.A #0x1, R12
   \   000004   31801401     SUB.W   #0x114, SP
   \   000008   064D         MOV.W   R13, R6
   2824          	FRESULT res;
   2825          	DIR dj;
   2826          	UINT i, n;
   2827          	DWORD ccl;
   2828          	TCHAR *tp;
   2829          	FILINFO fno;
   2830          	DEF_NAMEBUF;
   2831          
   2832          
   2833          	*path = 0;
   \   00000A   3F011401     MOVA    0x114(SP), R15
   \   00000E   CF430000     MOV.B   #0x0, 0(R15)
   2834          	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
   \   000012   4E43         MOV.B   #0x0, R14
   \   000014   0D41         MOV.W   SP, R13
   \   000016   0D53         ADD.W   #0x0, R13
   \   000018   0C41         MOV.W   SP, R12
   \   00001A   3C501401     ADD.W   #0x114, R12
   \   00001E   ........     CALLA   #chk_mounted
   \   000022   4A4C         MOV.B   R12, R10
   2835          	if (res == FR_OK) {
   \   000024   4A93         CMP.B   #0x0, R10
   \   000026   BB20         JNE     ??f_getcwd_12
   2836          		INIT_BUF(dj);
   \   000028   0F41         MOV.W   SP, R15
   \   00002A   3F502200     ADD.W   #0x22, R15
   \   00002E   710F1800     MOVA    R15, 0x18(SP)
   \   000032   0F41         MOV.W   SP, R15
   \   000034   3F504A00     ADD.W   #0x4a, R15
   \   000038   710F1C00     MOVA    R15, 0x1c(SP)
   2837          		i = sz_path;		/* Bottom of buffer (dir stack base) */
   \   00003C   0B46         MOV.W   R6, R11
   2838          		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
   \   00003E   0F01         MOVA    @SP, R15
   \   000040   914F16000800 MOV.W   0x16(R15), 0x8(SP)
   \   000046   914F18000A00 MOV.W   0x18(R15), 0xa(SP)
   2839          		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
   \                     ??f_getcwd_3:
   \   00004C   1E410800     MOV.W   0x8(SP), R14
   \   000050   1F410A00     MOV.W   0xa(SP), R15
   \   000054   044E         MOV.W   R14, R4
   \   000056   054F         MOV.W   R15, R5
   \   000058   0D4E         MOV.W   R14, R13
   \   00005A   0DDF         BIS.W   R15, R13
   \   00005C   0D93         CMP.W   #0x0, R13
   \   00005E   7924         JEQ     ??f_getcwd_6
   2840          			res = dir_sdi(&dj, 1);			/* Get parent dir */
   \   000060   1D43         MOV.W   #0x1, R13
   \   000062   0C41         MOV.W   SP, R12
   \   000064   0C53         ADD.W   #0x0, R12
   \   000066   ........     CALLA   #dir_sdi
   \   00006A   4A4C         MOV.B   R12, R10
   2841          			if (res != FR_OK) break;
   \   00006C   4A93         CMP.B   #0x0, R10
   \   00006E   7120         JNE     ??f_getcwd_6
   2842          			res = dir_read(&dj);
   \   000070   0C41         MOV.W   SP, R12
   \   000072   0C53         ADD.W   #0x0, R12
   \   000074   ........     CALLA   #dir_read
   \   000078   4A4C         MOV.B   R12, R10
   2843          			if (res != FR_OK) break;
   \   00007A   4A93         CMP.B   #0x0, R10
   \   00007C   6A20         JNE     ??f_getcwd_6
   2844          			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent dir */
   \   00007E   3D011400     MOVA    0x14(SP), R13
   \   000082   0C01         MOVA    @SP, R12
   \   000084   ........     CALLA   #ld_clust
   \   000088   814C0800     MOV.W   R12, 0x8(SP)
   \   00008C   814D0A00     MOV.W   R13, 0xa(SP)
   2845          			res = dir_sdi(&dj, 0);
   \   000090   0D43         MOV.W   #0x0, R13
   \   000092   0C41         MOV.W   SP, R12
   \   000094   0C53         ADD.W   #0x0, R12
   \   000096   ........     CALLA   #dir_sdi
   \   00009A   4A4C         MOV.B   R12, R10
   2846          			if (res != FR_OK) break;
   \   00009C   4A93         CMP.B   #0x0, R10
   \   00009E   5920         JNE     ??f_getcwd_6
   2847          			do {							/* Find the entry links to the child dir */
   2848          				res = dir_read(&dj);
   \                     ??f_getcwd_0:
   \   0000A0   0C41         MOV.W   SP, R12
   \   0000A2   0C53         ADD.W   #0x0, R12
   \   0000A4   ........     CALLA   #dir_read
   \   0000A8   4A4C         MOV.B   R12, R10
   2849          				if (res != FR_OK) break;
   \   0000AA   4A93         CMP.B   #0x0, R10
   \   0000AC   1120         JNE     ??f_getcwd_9
   2850          				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
   \   0000AE   3D011400     MOVA    0x14(SP), R13
   \   0000B2   0C01         MOVA    @SP, R12
   \   0000B4   ........     CALLA   #ld_clust
   \   0000B8   049C         CMP.W   R12, R4
   \   0000BA   0220         JNE     ??f_getcwd_10
   \   0000BC   059D         CMP.W   R13, R5
   \   0000BE   0824         JEQ     ??f_getcwd_9
   2851          				res = dir_next(&dj, 0);	
   \                     ??f_getcwd_10:
   \   0000C0   0D43         MOV.W   #0x0, R13
   \   0000C2   0C41         MOV.W   SP, R12
   \   0000C4   0C53         ADD.W   #0x0, R12
   \   0000C6   ........     CALLA   #dir_next
   \   0000CA   4A4C         MOV.B   R12, R10
   2852          			} while (res == FR_OK);
   \   0000CC   4A93         CMP.B   #0x0, R10
   \   0000CE   E827         JEQ     ??f_getcwd_0
   2853          			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
   \                     ??f_getcwd_9:
   \   0000D0   6A92         CMP.B   #0x4, R10
   \   0000D2   0120         JNE     ??f_getcwd_13
   \   0000D4   6A43         MOV.B   #0x2, R10
   2854          			if (res != FR_OK) break;
   \                     ??f_getcwd_13:
   \   0000D6   4A93         CMP.B   #0x0, R10
   \   0000D8   3C20         JNE     ??f_getcwd_6
   2855          #if _USE_LFN
   2856          			fno.lfname = path;
   \   0000DA   0018D1411401 MOVX.A  0x114(SP), 0x44(SP)
   \            4400        
   2857          			fno.lfsize = i;
   \   0000E2   814B4800     MOV.W   R11, 0x48(SP)
   2858          #endif
   2859          			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
   \   0000E6   0D41         MOV.W   SP, R13
   \   0000E8   3D502E00     ADD.W   #0x2e, R13
   \   0000EC   0C41         MOV.W   SP, R12
   \   0000EE   0C53         ADD.W   #0x0, R12
   \   0000F0   ........     CALLA   #get_fileinfo
   2860          			tp = fno.fname;
   \   0000F4   0F41         MOV.W   SP, R15
   \   0000F6   3F503700     ADD.W   #0x37, R15
   \   0000FA   C80F         MOVA    R15, R8
   2861          			if (_USE_LFN && *path) tp = path;
   \   0000FC   3F011401     MOVA    0x114(SP), R15
   \   000100   CF930000     CMP.B   #0x0, 0(R15)
   \   000104   0224         JEQ     ??f_getcwd_14
   \   000106   38011401     MOVA    0x114(SP), R8
   2862          			for (n = 0; tp[n]; n++) ;
   \                     ??f_getcwd_14:
   \   00010A   0943         MOV.W   #0x0, R9
   \                     ??f_getcwd_1:
   \   00010C   CF08         MOVA    R8, R15
   \   00010E   EF09         ADDA    R9, R15
   \   000110   CF930000     CMP.B   #0x0, 0(R15)
   \   000114   0224         JEQ     ??f_getcwd_15
   \   000116   1953         ADD.W   #0x1, R9
   \   000118   F93F         JMP     ??f_getcwd_1
   2863          			if (i < n + 3) {
   \                     ??f_getcwd_15:
   \   00011A   0F49         MOV.W   R9, R15
   \   00011C   3F500300     ADD.W   #0x3, R15
   \   000120   0B9F         CMP.W   R15, R11
   \   000122   032C         JC      ??f_getcwd_2
   2864          				res = FR_NOT_ENOUGH_CORE; break;
   \   000124   7A401100     MOV.B   #0x11, R10
   \   000128   143C         JMP     ??f_getcwd_6
   2865          			}
   2866          			while (n) path[--i] = tp[--n];
   \                     ??f_getcwd_2:
   \   00012A   0993         CMP.W   #0x0, R9
   \   00012C   0A24         JEQ     ??f_getcwd_16
   \   00012E   3B53         ADD.W   #0xffff, R11
   \   000130   3953         ADD.W   #0xffff, R9
   \   000132   CF08         MOVA    R8, R15
   \   000134   EF09         ADDA    R9, R15
   \   000136   3E011401     MOVA    0x114(SP), R14
   \   00013A   EE0B         ADDA    R11, R14
   \   00013C   EE4F0000     MOV.B   @R15, 0(R14)
   \   000140   F43F         JMP     ??f_getcwd_2
   2867          			path[--i] = '/';
   \                     ??f_getcwd_16:
   \   000142   3B53         ADD.W   #0xffff, R11
   \   000144   3F011401     MOVA    0x114(SP), R15
   \   000148   EF0B         ADDA    R11, R15
   \   00014A   FF402F000000 MOV.B   #0x2f, 0(R15)
   \   000150   7D3F         JMP     ??f_getcwd_3
   2868          		}
   2869          		tp = path;
   \                     ??f_getcwd_6:
   \   000152   38011401     MOVA    0x114(SP), R8
   2870          		if (res == FR_OK) {
   \   000156   4A93         CMP.B   #0x0, R10
   \   000158   2020         JNE     ??f_getcwd_17
   2871          			*tp++ = '0' + CurrVol;			/* Put drive number */
   \   00015A   7E403000     MOV.B   #0x30, R14
   \   00015E   ....5E52.... ADDX.B  &CurrVol, R14
   \   000164   C84E0000     MOV.B   R14, 0(R8)
   \   000168   A8000100     ADDA    #0x1, R8
   2872          			*tp++ = ':';
   \   00016C   F8403A000000 MOV.B   #0x3a, 0(R8)
   \   000172   A8000100     ADDA    #0x1, R8
   2873          			if (i == sz_path) {				/* Root-dir */
   \   000176   0B96         CMP.W   R6, R11
   \   000178   0620         JNE     ??f_getcwd_4
   2874          				*tp++ = '/';
   \   00017A   F8402F000000 MOV.B   #0x2f, 0(R8)
   \   000180   A8000100     ADDA    #0x1, R8
   \   000184   0A3C         JMP     ??f_getcwd_17
   2875          			} else {						/* Sub-dir */
   2876          				do		/* Add stacked path str */
   2877          					*tp++ = path[i++];
   \                     ??f_getcwd_4:
   \   000186   3F011401     MOVA    0x114(SP), R15
   \   00018A   EF0B         ADDA    R11, R15
   \   00018C   E84F0000     MOV.B   @R15, 0(R8)
   \   000190   1B53         ADD.W   #0x1, R11
   \   000192   A8000100     ADDA    #0x1, R8
   2878          				while (i < sz_path);
   \   000196   0B96         CMP.W   R6, R11
   \   000198   F62B         JNC     ??f_getcwd_4
   2879          			}
   2880          		}
   2881          		*tp = 0;
   \                     ??f_getcwd_17:
   \   00019A   C8430000     MOV.B   #0x0, 0(R8)
   2882          		FREE_BUF();
   2883          	}
   2884          
   2885          	LEAVE_FF(dj.fs, res);
   \                     ??f_getcwd_12:
   \   00019E   4C4A         MOV.B   R10, R12
   \   0001A0   31501801     ADD.W   #0x118, SP
   \   0001A4   7416         POPM.A  #0x8, R11
   \   0001A6   1001         RETA
   2886          }
   2887          #endif /* _FS_RPATH >= 2 */
   2888          #endif /* _FS_RPATH >= 1 */
   2889          
   2890          
   2891          
   2892          #if _FS_MINIMIZE <= 2
   2893          /*-----------------------------------------------------------------------*/
   2894          /* Seek File R/W Pointer                                                 */
   2895          /*-----------------------------------------------------------------------*/
   2896          

   \                                 In  segment CODE, align 2
   2897          FRESULT f_lseek (
   \                     f_lseek:
   2898          	FIL *fp,		/* Pointer to the file object */
   2899          	DWORD ofs		/* File pointer from top of file */
   2900          )
   2901          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   31801800     SUB.W   #0x18, SP
   \   000006   C80C         MOVA    R12, R8
   \   000008   0A4E         MOV.W   R14, R10
   \   00000A   0B4F         MOV.W   R15, R11
   2902          	FRESULT res;
   2903          
   2904          
   2905          	res = validate(fp);					/* Check validity of the object */
   \   00000C   CC08         MOVA    R8, R12
   \   00000E   ........     CALLA   #validate
   \   000012   494C         MOV.B   R12, R9
   2906          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   000014   4993         CMP.B   #0x0, R9
   \   000016   0324         JEQ     ??f_lseek_5
   \   000018   4C49         MOV.B   R9, R12
   \   00001A   ........     BRA     #??f_lseek_6
   2907          	if (fp->flag & FA__ERROR)			/* Check abort flag */
   \                     ??f_lseek_5:
   \   00001E   C8930600     CMP.B   #0x0, 0x6(R8)
   \   000022   0334         JGE     ??f_lseek_7
   2908          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   000024   6C43         MOV.B   #0x2, R12
   \   000026   ........     BRA     #??f_lseek_6
   2909          
   2910          #if _USE_FASTSEEK
   2911          	if (fp->cltbl) {	/* Fast seek */
   \                     ??f_lseek_7:
   \   00002A   3F082400     MOVA    0x24(R8), R15
   \   00002E   DF03         CMPA    #0x0, R15
   \   000030   4025         JEQ     ??f_lseek_8
   2912          		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
   2913          
   2914          		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
   \   000032   3A93         CMP.W   #0xffff, R10
   \   000034   A320         JNE     ??f_lseek_9
   \   000036   3B93         CMP.W   #0xffff, R11
   \   000038   A120         JNE     ??f_lseek_9
   2915          			tbl = fp->cltbl;
   \   00003A   34082400     MOVA    0x24(R8), R4
   2916          			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
   \   00003E   4018A1440C00 MOVX.W  @R4, 0xc(SP)
   \   000044   401891440200 MOVX.W  0x2(R4), 0xe(SP)
   \            0E00        
   \   00004C   A4000400     ADDA    #0x4, R4
   \   000050   A1430400     MOV.W   #0x2, 0x4(SP)
   \   000054   81430600     MOV.W   #0x0, 0x6(SP)
   2917          			cl = fp->sclust;			/* Top of the chain */
   \   000058   16481000     MOV.W   0x10(R8), R6
   \   00005C   17481200     MOV.W   0x12(R8), R7
   2918          			if (cl) {
   \   000060   0F46         MOV.W   R6, R15
   \   000062   0FD7         BIS.W   R7, R15
   \   000064   0F93         CMP.W   #0x0, R15
   \   000066   6D24         JEQ     ??f_lseek_3
   2919          				do {
   2920          					/* Get a fragment */
   2921          					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
   \                     ??f_lseek_1:
   \   000068   81461000     MOV.W   R6, 0x10(SP)
   \   00006C   81471200     MOV.W   R7, 0x12(SP)
   \   000070   81430800     MOV.W   #0x0, 0x8(SP)
   \   000074   81430A00     MOV.W   #0x0, 0xa(SP)
   \   000078   1E410400     MOV.W   0x4(SP), R14
   \   00007C   1F410600     MOV.W   0x6(SP), R15
   \   000080   2E53         ADD.W   #0x2, R14
   \   000082   0F63         ADDC.W  #0x0, R15
   \   000084   814E0400     MOV.W   R14, 0x4(SP)
   \   000088   814F0600     MOV.W   R15, 0x6(SP)
   2922          					do {
   2923          						pcl = cl; ncl++;
   \                     ??f_lseek_0:
   \   00008C   81461400     MOV.W   R6, 0x14(SP)
   \   000090   81471600     MOV.W   R7, 0x16(SP)
   \   000094   1E410800     MOV.W   0x8(SP), R14
   \   000098   1F410A00     MOV.W   0xa(SP), R15
   \   00009C   1E53         ADD.W   #0x1, R14
   \   00009E   0F63         ADDC.W  #0x0, R15
   \   0000A0   814E0800     MOV.W   R14, 0x8(SP)
   \   0000A4   814F0A00     MOV.W   R15, 0xa(SP)
   2924          						cl = get_fat(fp->fs, cl);
   \   0000A8   0E46         MOV.W   R6, R14
   \   0000AA   0F47         MOV.W   R7, R15
   \   0000AC   0C08         MOVA    @R8, R12
   \   0000AE   ........     CALLA   #get_fat
   \   0000B2   064C         MOV.W   R12, R6
   \   0000B4   074D         MOV.W   R13, R7
   2925          						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
   \   0000B6   0793         CMP.W   #0x0, R7
   \   0000B8   0328         JNC     ??f_lseek_10
   \   0000BA   0920         JNE     ??f_lseek_11
   \   0000BC   2693         CMP.W   #0x2, R6
   \   0000BE   072C         JC      ??f_lseek_11
   \                     ??f_lseek_10:
   \   0000C0   CF08         MOVA    R8, R15
   \   0000C2   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   0000C8   6C43         MOV.B   #0x2, R12
   \   0000CA   ........     BRA     #??f_lseek_6
   2926          						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_11:
   \   0000CE   3693         CMP.W   #0xffff, R6
   \   0000D0   0920         JNE     ??f_lseek_12
   \   0000D2   3793         CMP.W   #0xffff, R7
   \   0000D4   0720         JNE     ??f_lseek_12
   \   0000D6   CF08         MOVA    R8, R15
   \   0000D8   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   0000DE   5C43         MOV.B   #0x1, R12
   \   0000E0   ........     BRA     #??f_lseek_6
   2927          					} while (cl == pcl + 1);
   \                     ??f_lseek_12:
   \   0000E4   1E411400     MOV.W   0x14(SP), R14
   \   0000E8   1F411600     MOV.W   0x16(SP), R15
   \   0000EC   1E53         ADD.W   #0x1, R14
   \   0000EE   0F63         ADDC.W  #0x0, R15
   \   0000F0   069E         CMP.W   R14, R6
   \   0000F2   0220         JNE     ??f_lseek_13
   \   0000F4   079F         CMP.W   R15, R7
   \   0000F6   CA27         JEQ     ??f_lseek_0
   2928          					if (ulen <= tlen) {		/* Store the length and top of the fragment */
   \                     ??f_lseek_13:
   \   0000F8   919106000E00 CMP.W   0x6(SP), 0xe(SP)
   \   0000FE   1928         JNC     ??f_lseek_14
   \   000100   0420         JNE     ??f_lseek_15
   \   000102   919104000C00 CMP.W   0x4(SP), 0xc(SP)
   \   000108   1428         JNC     ??f_lseek_14
   2929          						*tbl++ = ncl; *tbl++ = tcl;
   \                     ??f_lseek_15:
   \   00010A   1E410800     MOV.W   0x8(SP), R14
   \   00010E   1F410A00     MOV.W   0xa(SP), R15
   \   000112   844E0000     MOV.W   R14, 0(R4)
   \   000116   844F0200     MOV.W   R15, 0x2(R4)
   \   00011A   A4000400     ADDA    #0x4, R4
   \   00011E   1E411000     MOV.W   0x10(SP), R14
   \   000122   1F411200     MOV.W   0x12(SP), R15
   \   000126   844E0000     MOV.W   R14, 0(R4)
   \   00012A   844F0200     MOV.W   R15, 0x2(R4)
   \   00012E   A4000400     ADDA    #0x4, R4
   2930          					}
   2931          				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
   \                     ??f_lseek_14:
   \   000132   0F08         MOVA    @R8, R15
   \   000134   179F1C00     CMP.W   0x1c(R15), R7
   \   000138   972B         JNC     ??f_lseek_1
   \   00013A   0320         JNE     ??f_lseek_3
   \   00013C   169F1A00     CMP.W   0x1a(R15), R6
   \   000140   932B         JNC     ??f_lseek_1
   2932          			}
   2933          			*fp->cltbl = ulen;	/* Number of items used */
   \                     ??f_lseek_3:
   \   000142   1E410400     MOV.W   0x4(SP), R14
   \   000146   1F410600     MOV.W   0x6(SP), R15
   \   00014A   3D082400     MOVA    0x24(R8), R13
   \   00014E   8D4E0000     MOV.W   R14, 0(R13)
   \   000152   8D4F0200     MOV.W   R15, 0x2(R13)
   2934          			if (ulen <= tlen)
   \   000156   919106000E00 CMP.W   0x6(SP), 0xe(SP)
   \   00015C   0B28         JNC     ??f_lseek_16
   \   00015E   0420         JNE     ??f_lseek_17
   \   000160   919104000C00 CMP.W   0x4(SP), 0xc(SP)
   \   000166   0628         JNC     ??f_lseek_16
   2935          				*tbl = 0;		/* Terminate table */
   \                     ??f_lseek_17:
   \   000168   84430000     MOV.W   #0x0, 0(R4)
   \   00016C   84430200     MOV.W   #0x0, 0x2(R4)
   \   000170   ........     BRA     #??f_lseek_18
   2936          			else
   2937          				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
   \                     ??f_lseek_16:
   \   000174   79401100     MOV.B   #0x11, R9
   \   000178   ........     BRA     #??f_lseek_18
   2938          
   2939          		} else {						/* Fast seek */
   2940          			if (ofs > fp->fsize)		/* Clip offset at the file size */
   \                     ??f_lseek_9:
   \   00017C   889B0E00     CMP.W   R11, 0xe(R8)
   \   000180   0428         JNC     ??f_lseek_19
   \   000182   0720         JNE     ??f_lseek_20
   \   000184   889A0C00     CMP.W   R10, 0xc(R8)
   \   000188   042C         JC      ??f_lseek_20
   2941          				ofs = fp->fsize;
   \                     ??f_lseek_19:
   \   00018A   1A480C00     MOV.W   0xc(R8), R10
   \   00018E   1B480E00     MOV.W   0xe(R8), R11
   2942          			fp->fptr = ofs;				/* Set file pointer */
   \                     ??f_lseek_20:
   \   000192   884A0800     MOV.W   R10, 0x8(R8)
   \   000196   884B0A00     MOV.W   R11, 0xa(R8)
   2943          			if (ofs) {
   \   00019A   0F4A         MOV.W   R10, R15
   \   00019C   0FDB         BIS.W   R11, R15
   \   00019E   0F93         CMP.W   #0x0, R15
   \   0001A0   EF25         JEQ     ??f_lseek_18
   2944          				fp->clust = clmt_clust(fp, ofs - 1);
   \   0001A2   0E4A         MOV.W   R10, R14
   \   0001A4   0F4B         MOV.W   R11, R15
   \   0001A6   3E53         ADD.W   #0xffff, R14
   \   0001A8   3F63         ADDC.W  #0xffff, R15
   \   0001AA   CC08         MOVA    R8, R12
   \   0001AC   ........     CALLA   #clmt_clust
   \   0001B0   884C1400     MOV.W   R12, 0x14(R8)
   \   0001B4   884D1600     MOV.W   R13, 0x16(R8)
   2945          				dsc = clust2sect(fp->fs, fp->clust);
   \   0001B8   1E481400     MOV.W   0x14(R8), R14
   \   0001BC   1F481600     MOV.W   0x16(R8), R15
   \   0001C0   0C08         MOVA    @R8, R12
   \   0001C2   ........     CALLA   #clust2sect
   \   0001C6   814C0000     MOV.W   R12, 0(SP)
   \   0001CA   814D0200     MOV.W   R13, 0x2(SP)
   2946          				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
   \   0001CE   2F41         MOV.W   @SP, R15
   \   0001D0   1FD10200     BIS.W   0x2(SP), R15
   \   0001D4   0F93         CMP.W   #0x0, R15
   \   0001D6   0620         JNE     ??f_lseek_21
   \   0001D8   CF08         MOVA    R8, R15
   \   0001DA   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   0001E0   6C43         MOV.B   #0x2, R12
   \   0001E2   CF3D         JMP     ??f_lseek_6
   2947          				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
   \                     ??f_lseek_21:
   \   0001E4   0C4A         MOV.W   R10, R12
   \   0001E6   0D4B         MOV.W   R11, R13
   \   0001E8   3C53         ADD.W   #0xffff, R12
   \   0001EA   3D63         ADDC.W  #0xffff, R13
   \   0001EC   ........     CALLA   #?ShiftRight32u_9
   \   0001F0   0F08         MOVA    @R8, R15
   \   0001F2   5E4F0200     MOV.B   0x2(R15), R14
   \   0001F6   4E4E         MOV.B   R14, R14
   \   0001F8   3E53         ADD.W   #0xffff, R14
   \   0001FA   0F4E         MOV.W   R14, R15
   \   0001FC   3FE3         XOR.W   #0xffff, R15
   \   0001FE   0F5F         RLA.W   R15
   \   000200   0F7F         SUBC.W  R15, R15
   \   000202   0CFE         AND.W   R14, R12
   \   000204   0DFF         AND.W   R15, R13
   \   000206   2C51         ADD.W   @SP, R12
   \   000208   1D610200     ADDC.W  0x2(SP), R13
   \   00020C   814C0000     MOV.W   R12, 0(SP)
   \   000210   814D0200     MOV.W   R13, 0x2(SP)
   2948          				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
   \   000214   1C480800     MOV.W   0x8(R8), R12
   \   000218   1D480A00     MOV.W   0xa(R8), R13
   \   00021C   3E400002     MOV.W   #0x200, R14
   \   000220   0F43         MOV.W   #0x0, R15
   \   000222   ........     CALLA   #?DivMod32u
   \   000226   0D4E         MOV.W   R14, R13
   \   000228   0DDF         BIS.W   R15, R13
   \   00022A   0D93         CMP.W   #0x0, R13
   \   00022C   A925         JEQ     ??f_lseek_18
   \   00022E   919818000000 CMP.W   0x18(R8), 0(SP)
   \   000234   0420         JNE     ??f_lseek_22
   \   000236   91981A000200 CMP.W   0x1a(R8), 0x2(SP)
   \   00023C   A125         JEQ     ??f_lseek_18
   2949          #if !_FS_TINY
   2950          #if !_FS_READONLY
   2951          					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   \                     ??f_lseek_22:
   \   00023E   F8B040000600 BIT.B   #0x40, 0x6(R8)
   \   000244   1A28         JNC     ??f_lseek_23
   2952          						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   000246   5312         PUSH.B  #0x1
   \   000248   1E481800     MOV.W   0x18(R8), R14
   \   00024C   1F481A00     MOV.W   0x1a(R8), R15
   \   000250   CD08         MOVA    R8, R13
   \   000252   AD002800     ADDA    #0x28, R13
   \   000256   0508         MOVA    @R8, R5
   \   000258   5C450100     MOV.B   0x1(R5), R12
   \   00025C   ........     CALLA   #disk_write
   \   000260   2153         ADD.W   #0x2, SP
   \   000262   4C93         CMP.B   #0x0, R12
   \   000264   0624         JEQ     ??f_lseek_24
   2953          							ABORT(fp->fs, FR_DISK_ERR);
   \   000266   CF08         MOVA    R8, R15
   \   000268   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   00026E   5C43         MOV.B   #0x1, R12
   \   000270   883D         JMP     ??f_lseek_6
   2954          						fp->flag &= ~FA__DIRTY;
   \                     ??f_lseek_24:
   \   000272   CF08         MOVA    R8, R15
   \   000274   FFC040000600 BIC.B   #0x40, 0x6(R15)
   2955          					}
   2956          #endif
   2957          					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
   \                     ??f_lseek_23:
   \   00027A   5312         PUSH.B  #0x1
   \   00027C   1E410200     MOV.W   0x2(SP), R14
   \   000280   1F410400     MOV.W   0x4(SP), R15
   \   000284   CD08         MOVA    R8, R13
   \   000286   AD002800     ADDA    #0x28, R13
   \   00028A   0508         MOVA    @R8, R5
   \   00028C   5C450100     MOV.B   0x1(R5), R12
   \   000290   ........     CALLA   #disk_read
   \   000294   2153         ADD.W   #0x2, SP
   \   000296   4C93         CMP.B   #0x0, R12
   \   000298   0624         JEQ     ??f_lseek_25
   2958          						ABORT(fp->fs, FR_DISK_ERR);
   \   00029A   CF08         MOVA    R8, R15
   \   00029C   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   0002A2   5C43         MOV.B   #0x1, R12
   \   0002A4   6E3D         JMP     ??f_lseek_6
   2959          #endif
   2960          					fp->dsect = dsc;
   \                     ??f_lseek_25:
   \   0002A6   A8411800     MOV.W   @SP, 0x18(R8)
   \   0002AA   984102001A00 MOV.W   0x2(SP), 0x1a(R8)
   \   0002B0   673D         JMP     ??f_lseek_18
   2961          				}
   2962          			}
   2963          		}
   2964          	} else
   2965          #endif
   2966          
   2967          	/* Normal Seek */
   2968          	{
   2969          		DWORD clst, bcs, nsect, ifptr;
   2970          
   2971          		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
   2972          #if !_FS_READONLY
   2973          			 && !(fp->flag & FA_WRITE)
   2974          #endif
   2975          			) ofs = fp->fsize;
   \                     ??f_lseek_8:
   \   0002B2   889B0E00     CMP.W   R11, 0xe(R8)
   \   0002B6   0428         JNC     ??f_lseek_26
   \   0002B8   0A20         JNE     ??f_lseek_27
   \   0002BA   889A0C00     CMP.W   R10, 0xc(R8)
   \   0002BE   072C         JC      ??f_lseek_27
   \                     ??f_lseek_26:
   \   0002C0   E8B30600     BIT.B   #0x2, 0x6(R8)
   \   0002C4   042C         JC      ??f_lseek_27
   \   0002C6   1A480C00     MOV.W   0xc(R8), R10
   \   0002CA   1B480E00     MOV.W   0xe(R8), R11
   2976          
   2977          		ifptr = fp->fptr;
   \                     ??f_lseek_27:
   \   0002CE   914808000400 MOV.W   0x8(R8), 0x4(SP)
   \   0002D4   91480A000600 MOV.W   0xa(R8), 0x6(SP)
   2978          		fp->fptr = nsect = 0;
   \   0002DA   0E43         MOV.W   #0x0, R14
   \   0002DC   0F43         MOV.W   #0x0, R15
   \   0002DE   044E         MOV.W   R14, R4
   \   0002E0   054F         MOV.W   R15, R5
   \   0002E2   884E0800     MOV.W   R14, 0x8(R8)
   \   0002E6   884F0A00     MOV.W   R15, 0xa(R8)
   2979          		if (ofs) {
   \   0002EA   0F4A         MOV.W   R10, R15
   \   0002EC   0FDB         BIS.W   R11, R15
   \   0002EE   0F93         CMP.W   #0x0, R15
   \   0002F0   EB24         JEQ     ??f_lseek_28
   2980          			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
   \   0002F2   0F08         MOVA    @R8, R15
   \   0002F4   5C4F0200     MOV.B   0x2(R15), R12
   \   0002F8   4C4C         MOV.B   R12, R12
   \   0002FA   0D43         MOV.W   #0x0, R13
   \   0002FC   3E400002     MOV.W   #0x200, R14
   \   000300   0F43         MOV.W   #0x0, R15
   \   000302   ........     CALLA   #?Mul32
   \   000306   814C0000     MOV.W   R12, 0(SP)
   \   00030A   814D0200     MOV.W   R13, 0x2(SP)
   2981          			if (ifptr > 0 &&
   2982          				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
   \   00030E   1F410400     MOV.W   0x4(SP), R15
   \   000312   1FD10600     BIS.W   0x6(SP), R15
   \   000316   0F93         CMP.W   #0x0, R15
   \   000318   3824         JEQ     ??f_lseek_29
   \   00031A   0C4A         MOV.W   R10, R12
   \   00031C   0D4B         MOV.W   R11, R13
   \   00031E   3C53         ADD.W   #0xffff, R12
   \   000320   3D63         ADDC.W  #0xffff, R13
   \   000322   2E41         MOV.W   @SP, R14
   \   000324   1F410200     MOV.W   0x2(SP), R15
   \   000328   ........     CALLA   #?DivMod32u
   \   00032C   0D12         PUSH.W  R13
   \   00032E   0C12         PUSH.W  R12
   \   000330   1C410800     MOV.W   0x8(SP), R12
   \   000334   1D410A00     MOV.W   0xa(SP), R13
   \   000338   3C53         ADD.W   #0xffff, R12
   \   00033A   3D63         ADDC.W  #0xffff, R13
   \   00033C   1E410400     MOV.W   0x4(SP), R14
   \   000340   1F410600     MOV.W   0x6(SP), R15
   \   000344   ........     CALLA   #?DivMod32u
   \   000348   3E41         POP.W   R14
   \   00034A   3F41         POP.W   R15
   \   00034C   0F9D         CMP.W   R13, R15
   \   00034E   1D28         JNC     ??f_lseek_29
   \   000350   0220         JNE     ??f_lseek_30
   \   000352   0E9C         CMP.W   R12, R14
   \   000354   1A28         JNC     ??f_lseek_29
   2983          				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
   \                     ??f_lseek_30:
   \   000356   1C410400     MOV.W   0x4(SP), R12
   \   00035A   1D410600     MOV.W   0x6(SP), R13
   \   00035E   3C53         ADD.W   #0xffff, R12
   \   000360   3D63         ADDC.W  #0xffff, R13
   \   000362   2E41         MOV.W   @SP, R14
   \   000364   1F410200     MOV.W   0x2(SP), R15
   \   000368   3E53         ADD.W   #0xffff, R14
   \   00036A   3F63         ADDC.W  #0xffff, R15
   \   00036C   0CCE         BIC.W   R14, R12
   \   00036E   0DCF         BIC.W   R15, R13
   \   000370   884C0800     MOV.W   R12, 0x8(R8)
   \   000374   884D0A00     MOV.W   R13, 0xa(R8)
   2984          				ofs -= fp->fptr;
   \   000378   1A880800     SUB.W   0x8(R8), R10
   \   00037C   1B780A00     SUBC.W  0xa(R8), R11
   2985          				clst = fp->clust;
   \   000380   16481400     MOV.W   0x14(R8), R6
   \   000384   17481600     MOV.W   0x16(R8), R7
   \   000388   2B3C         JMP     ??f_lseek_31
   2986          			} else {									/* When seek to back cluster, */
   2987          				clst = fp->sclust;						/* start from the first cluster */
   \                     ??f_lseek_29:
   \   00038A   16481000     MOV.W   0x10(R8), R6
   \   00038E   17481200     MOV.W   0x12(R8), R7
   2988          #if !_FS_READONLY
   2989          				if (clst == 0) {						/* If no cluster chain, create a new chain */
   \   000392   0F46         MOV.W   R6, R15
   \   000394   0FD7         BIS.W   R7, R15
   \   000396   0F93         CMP.W   #0x0, R15
   \   000398   1F20         JNE     ??f_lseek_32
   2990          					clst = create_chain(fp->fs, 0);
   \   00039A   0E43         MOV.W   #0x0, R14
   \   00039C   0F43         MOV.W   #0x0, R15
   \   00039E   0C08         MOVA    @R8, R12
   \   0003A0   ........     CALLA   #create_chain
   \   0003A4   064C         MOV.W   R12, R6
   \   0003A6   074D         MOV.W   R13, R7
   2991          					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   \   0003A8   1693         CMP.W   #0x1, R6
   \   0003AA   0820         JNE     ??f_lseek_33
   \   0003AC   0793         CMP.W   #0x0, R7
   \   0003AE   0620         JNE     ??f_lseek_33
   \   0003B0   CF08         MOVA    R8, R15
   \   0003B2   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   0003B8   6C43         MOV.B   #0x2, R12
   \   0003BA   E33C         JMP     ??f_lseek_6
   2992          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_33:
   \   0003BC   3693         CMP.W   #0xffff, R6
   \   0003BE   0820         JNE     ??f_lseek_34
   \   0003C0   3793         CMP.W   #0xffff, R7
   \   0003C2   0620         JNE     ??f_lseek_34
   \   0003C4   CF08         MOVA    R8, R15
   \   0003C6   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   0003CC   5C43         MOV.B   #0x1, R12
   \   0003CE   D93C         JMP     ??f_lseek_6
   2993          					fp->sclust = clst;
   \                     ??f_lseek_34:
   \   0003D0   88461000     MOV.W   R6, 0x10(R8)
   \   0003D4   88471200     MOV.W   R7, 0x12(R8)
   2994          				}
   2995          #endif
   2996          				fp->clust = clst;
   \                     ??f_lseek_32:
   \   0003D8   88461400     MOV.W   R6, 0x14(R8)
   \   0003DC   88471600     MOV.W   R7, 0x16(R8)
   2997          			}
   2998          			if (clst != 0) {
   \                     ??f_lseek_31:
   \   0003E0   0F46         MOV.W   R6, R15
   \   0003E2   0FD7         BIS.W   R7, R15
   \   0003E4   0F93         CMP.W   #0x0, R15
   \   0003E6   7024         JEQ     ??f_lseek_28
   2999          				while (ofs > bcs) {						/* Cluster following loop */
   \                     ??f_lseek_2:
   \   0003E8   819B0200     CMP.W   R11, 0x2(SP)
   \   0003EC   0428         JNC     ??f_lseek_35
   \   0003EE   4620         JNE     ??f_lseek_36
   \   0003F0   819A0000     CMP.W   R10, 0(SP)
   \   0003F4   432C         JC      ??f_lseek_36
   3000          #if !_FS_READONLY
   3001          					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
   \                     ??f_lseek_35:
   \   0003F6   E8B30600     BIT.B   #0x2, 0x6(R8)
   \   0003FA   0F28         JNC     ??f_lseek_37
   3002          						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
   \   0003FC   0E46         MOV.W   R6, R14
   \   0003FE   0F47         MOV.W   R7, R15
   \   000400   0C08         MOVA    @R8, R12
   \   000402   ........     CALLA   #create_chain
   \   000406   064C         MOV.W   R12, R6
   \   000408   074D         MOV.W   R13, R7
   3003          						if (clst == 0) {				/* When disk gets full, clip file size */
   \   00040A   0F46         MOV.W   R6, R15
   \   00040C   0FD7         BIS.W   R7, R15
   \   00040E   0F93         CMP.W   #0x0, R15
   \   000410   0B20         JNE     ??f_lseek_38
   3004          							ofs = bcs; break;
   \   000412   2A41         MOV.W   @SP, R10
   \   000414   1B410200     MOV.W   0x2(SP), R11
   \   000418   313C         JMP     ??f_lseek_36
   3005          						}
   3006          					} else
   3007          #endif
   3008          						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
   \                     ??f_lseek_37:
   \   00041A   0E46         MOV.W   R6, R14
   \   00041C   0F47         MOV.W   R7, R15
   \   00041E   0C08         MOVA    @R8, R12
   \   000420   ........     CALLA   #get_fat
   \   000424   064C         MOV.W   R12, R6
   \   000426   074D         MOV.W   R13, R7
   3009          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_38:
   \   000428   3693         CMP.W   #0xffff, R6
   \   00042A   0820         JNE     ??f_lseek_39
   \   00042C   3793         CMP.W   #0xffff, R7
   \   00042E   0620         JNE     ??f_lseek_39
   \   000430   CF08         MOVA    R8, R15
   \   000432   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   000438   5C43         MOV.B   #0x1, R12
   \   00043A   A33C         JMP     ??f_lseek_6
   3010          					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
   \                     ??f_lseek_39:
   \   00043C   0793         CMP.W   #0x0, R7
   \   00043E   0B28         JNC     ??f_lseek_4
   \   000440   0220         JNE     ??f_lseek_40
   \   000442   2693         CMP.W   #0x2, R6
   \   000444   0828         JNC     ??f_lseek_4
   \                     ??f_lseek_40:
   \   000446   0F08         MOVA    @R8, R15
   \   000448   179F1C00     CMP.W   0x1c(R15), R7
   \   00044C   0A28         JNC     ??f_lseek_41
   \   00044E   0320         JNE     ??f_lseek_4
   \   000450   169F1A00     CMP.W   0x1a(R15), R6
   \   000454   0628         JNC     ??f_lseek_41
   \                     ??f_lseek_4:
   \   000456   CF08         MOVA    R8, R15
   \   000458   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   00045E   6C43         MOV.B   #0x2, R12
   \   000460   903C         JMP     ??f_lseek_6
   3011          					fp->clust = clst;
   \                     ??f_lseek_41:
   \   000462   88461400     MOV.W   R6, 0x14(R8)
   \   000466   88471600     MOV.W   R7, 0x16(R8)
   3012          					fp->fptr += bcs;
   \   00046A   A8510800     ADD.W   @SP, 0x8(R8)
   \   00046E   986102000A00 ADDC.W  0x2(SP), 0xa(R8)
   3013          					ofs -= bcs;
   \   000474   2A81         SUB.W   @SP, R10
   \   000476   1B710200     SUBC.W  0x2(SP), R11
   \   00047A   B63F         JMP     ??f_lseek_2
   3014          				}
   3015          				fp->fptr += ofs;
   \                     ??f_lseek_36:
   \   00047C   885A0800     ADD.W   R10, 0x8(R8)
   \   000480   886B0A00     ADDC.W  R11, 0xa(R8)
   3016          				if (ofs % SS(fp->fs)) {
   \   000484   0C4A         MOV.W   R10, R12
   \   000486   0D4B         MOV.W   R11, R13
   \   000488   3E400002     MOV.W   #0x200, R14
   \   00048C   0F43         MOV.W   #0x0, R15
   \   00048E   ........     CALLA   #?DivMod32u
   \   000492   0D4E         MOV.W   R14, R13
   \   000494   0DDF         BIS.W   R15, R13
   \   000496   0D93         CMP.W   #0x0, R13
   \   000498   1724         JEQ     ??f_lseek_28
   3017          					nsect = clust2sect(fp->fs, clst);	/* Current sector */
   \   00049A   0E46         MOV.W   R6, R14
   \   00049C   0F47         MOV.W   R7, R15
   \   00049E   0C08         MOVA    @R8, R12
   \   0004A0   ........     CALLA   #clust2sect
   \   0004A4   044C         MOV.W   R12, R4
   \   0004A6   054D         MOV.W   R13, R5
   3018          					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
   \   0004A8   0F44         MOV.W   R4, R15
   \   0004AA   0FD5         BIS.W   R5, R15
   \   0004AC   0F93         CMP.W   #0x0, R15
   \   0004AE   0620         JNE     ??f_lseek_42
   \   0004B0   CF08         MOVA    R8, R15
   \   0004B2   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   0004B8   6C43         MOV.B   #0x2, R12
   \   0004BA   633C         JMP     ??f_lseek_6
   3019          					nsect += ofs / SS(fp->fs);
   \                     ??f_lseek_42:
   \   0004BC   0C4A         MOV.W   R10, R12
   \   0004BE   0D4B         MOV.W   R11, R13
   \   0004C0   ........     CALLA   #?ShiftRight32u_9
   \   0004C4   045C         ADD.W   R12, R4
   \   0004C6   056D         ADDC.W  R13, R5
   3020          				}
   3021          			}
   3022          		}
   3023          		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
   \                     ??f_lseek_28:
   \   0004C8   1C480800     MOV.W   0x8(R8), R12
   \   0004CC   1D480A00     MOV.W   0xa(R8), R13
   \   0004D0   3E400002     MOV.W   #0x200, R14
   \   0004D4   0F43         MOV.W   #0x0, R15
   \   0004D6   ........     CALLA   #?DivMod32u
   \   0004DA   0D4E         MOV.W   R14, R13
   \   0004DC   0DDF         BIS.W   R15, R13
   \   0004DE   0D93         CMP.W   #0x0, R13
   \   0004E0   3C24         JEQ     ??f_lseek_43
   \   0004E2   14981800     CMP.W   0x18(R8), R4
   \   0004E6   0320         JNE     ??f_lseek_44
   \   0004E8   15981A00     CMP.W   0x1a(R8), R5
   \   0004EC   3624         JEQ     ??f_lseek_43
   3024          #if !_FS_TINY
   3025          #if !_FS_READONLY
   3026          			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
   \                     ??f_lseek_44:
   \   0004EE   F8B040000600 BIT.B   #0x40, 0x6(R8)
   \   0004F4   1A28         JNC     ??f_lseek_45
   3027          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   0004F6   5312         PUSH.B  #0x1
   \   0004F8   1E481800     MOV.W   0x18(R8), R14
   \   0004FC   1F481A00     MOV.W   0x1a(R8), R15
   \   000500   CD08         MOVA    R8, R13
   \   000502   AD002800     ADDA    #0x28, R13
   \   000506   0C08         MOVA    @R8, R12
   \   000508   5C4C0100     MOV.B   0x1(R12), R12
   \   00050C   ........     CALLA   #disk_write
   \   000510   2153         ADD.W   #0x2, SP
   \   000512   4C93         CMP.B   #0x0, R12
   \   000514   0624         JEQ     ??f_lseek_46
   3028          					ABORT(fp->fs, FR_DISK_ERR);
   \   000516   CF08         MOVA    R8, R15
   \   000518   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   00051E   5C43         MOV.B   #0x1, R12
   \   000520   303C         JMP     ??f_lseek_6
   3029          				fp->flag &= ~FA__DIRTY;
   \                     ??f_lseek_46:
   \   000522   CF08         MOVA    R8, R15
   \   000524   FFC040000600 BIC.B   #0x40, 0x6(R15)
   3030          			}
   3031          #endif
   3032          			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
   \                     ??f_lseek_45:
   \   00052A   5312         PUSH.B  #0x1
   \   00052C   0E44         MOV.W   R4, R14
   \   00052E   0F45         MOV.W   R5, R15
   \   000530   CD08         MOVA    R8, R13
   \   000532   AD002800     ADDA    #0x28, R13
   \   000536   0C08         MOVA    @R8, R12
   \   000538   5C4C0100     MOV.B   0x1(R12), R12
   \   00053C   ........     CALLA   #disk_read
   \   000540   2153         ADD.W   #0x2, SP
   \   000542   4C93         CMP.B   #0x0, R12
   \   000544   0624         JEQ     ??f_lseek_47
   3033          				ABORT(fp->fs, FR_DISK_ERR);
   \   000546   CF08         MOVA    R8, R15
   \   000548   FFD080000600 BIS.B   #0x80, 0x6(R15)
   \   00054E   5C43         MOV.B   #0x1, R12
   \   000550   183C         JMP     ??f_lseek_6
   3034          #endif
   3035          			fp->dsect = nsect;
   \                     ??f_lseek_47:
   \   000552   88441800     MOV.W   R4, 0x18(R8)
   \   000556   88451A00     MOV.W   R5, 0x1a(R8)
   3036          		}
   3037          #if !_FS_READONLY
   3038          		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
   \                     ??f_lseek_43:
   \   00055A   98980A000E00 CMP.W   0xa(R8), 0xe(R8)
   \   000560   0528         JNC     ??f_lseek_48
   \   000562   0E20         JNE     ??f_lseek_18
   \   000564   989808000C00 CMP.W   0x8(R8), 0xc(R8)
   \   00056A   0A2C         JC      ??f_lseek_18
   3039          			fp->fsize = fp->fptr;
   \                     ??f_lseek_48:
   \   00056C   984808000C00 MOV.W   0x8(R8), 0xc(R8)
   \   000572   98480A000E00 MOV.W   0xa(R8), 0xe(R8)
   3040          			fp->flag |= FA__WRITTEN;
   \   000578   CF08         MOVA    R8, R15
   \   00057A   FFD020000600 BIS.B   #0x20, 0x6(R15)
   3041          		}
   3042          #endif
   3043          	}
   3044          
   3045          	LEAVE_FF(fp->fs, res);
   \                     ??f_lseek_18:
   \   000580   4C49         MOV.B   R9, R12
   \                     ??f_lseek_6:
   \   000582   31501800     ADD.W   #0x18, SP
   \   000586   7416         POPM.A  #0x8, R11
   \   000588   1001         RETA
   3046          }
   3047          
   3048          
   3049          
   3050          #if _FS_MINIMIZE <= 1
   3051          /*-----------------------------------------------------------------------*/
   3052          /* Create a Directory Object                                             */
   3053          /*-----------------------------------------------------------------------*/
   3054          

   \                                 In  segment CODE, align 2
   3055          FRESULT f_opendir (
   \                     f_opendir:
   3056          	DIR *dj,			/* Pointer to directory object to create */
   3057          	const TCHAR *path	/* Pointer to the directory path */
   3058          )
   3059          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   0D14         PUSHM.A #0x1, R13
   \   000004   3180D600     SUB.W   #0xd6, SP
   \   000008   CA0C         MOVA    R12, R10
   3060          	FRESULT res;
   3061          	FATFS *fs;
   3062          	DEF_NAMEBUF;
   3063          
   3064          
   3065          	if (!dj) return FR_INVALID_OBJECT;
   \   00000A   DA03         CMPA    #0x0, R10
   \   00000C   0320         JNE     ??f_opendir_0
   \   00000E   7C400900     MOV.B   #0x9, R12
   \   000012   4A3C         JMP     ??f_opendir_1
   3066          
   3067          	res = chk_mounted(&path, &dj->fs, 0);
   \                     ??f_opendir_0:
   \   000014   4E43         MOV.B   #0x0, R14
   \   000016   CD0A         MOVA    R10, R13
   \   000018   0C41         MOV.W   SP, R12
   \   00001A   3C50D600     ADD.W   #0xd6, R12
   \   00001E   ........     CALLA   #chk_mounted
   \   000022   4B4C         MOV.B   R12, R11
   3068          	fs = dj->fs;
   \   000024   080A         MOVA    @R10, R8
   3069          	if (res == FR_OK) {
   \   000026   4B93         CMP.B   #0x0, R11
   \   000028   3B20         JNE     ??f_opendir_2
   3070          		INIT_BUF(*dj);
   \   00002A   0F41         MOV.W   SP, R15
   \   00002C   0F53         ADD.W   #0x0, R15
   \   00002E   7A0F1800     MOVA    R15, 0x18(R10)
   \   000032   0F41         MOV.W   SP, R15
   \   000034   3F500C00     ADD.W   #0xc, R15
   \   000038   7A0F1C00     MOVA    R15, 0x1c(R10)
   3071          		res = follow_path(dj, path);			/* Follow the path to the directory */
   \   00003C   3D01D600     MOVA    0xd6(SP), R13
   \   000040   CC0A         MOVA    R10, R12
   \   000042   ........     CALLA   #follow_path
   \   000046   4B4C         MOV.B   R12, R11
   3072          		FREE_BUF();
   3073          		if (res == FR_OK) {						/* Follow completed */
   \   000048   4B93         CMP.B   #0x0, R11
   \   00004A   2020         JNE     ??f_opendir_3
   3074          			if (dj->dir) {						/* It is not the root dir */
   \   00004C   3F0A1400     MOVA    0x14(R10), R15
   \   000050   DF03         CMPA    #0x0, R15
   \   000052   1224         JEQ     ??f_opendir_4
   3075          				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
   \   000054   3F0A1400     MOVA    0x14(R10), R15
   \   000058   FFB010000B00 BIT.B   #0x10, 0xb(R15)
   \   00005E   0A28         JNC     ??f_opendir_5
   3076          					dj->sclust = ld_clust(fs, dj->dir);
   \   000060   3D0A1400     MOVA    0x14(R10), R13
   \   000064   CC08         MOVA    R8, R12
   \   000066   ........     CALLA   #ld_clust
   \   00006A   8A4C0800     MOV.W   R12, 0x8(R10)
   \   00006E   8A4D0A00     MOV.W   R13, 0xa(R10)
   \   000072   023C         JMP     ??f_opendir_4
   3077          				} else {						/* The object is not a directory */
   3078          					res = FR_NO_PATH;
   \                     ??f_opendir_5:
   \   000074   7B400500     MOV.B   #0x5, R11
   3079          				}
   3080          			}
   3081          			if (res == FR_OK) {
   \                     ??f_opendir_4:
   \   000078   4B93         CMP.B   #0x0, R11
   \   00007A   0820         JNE     ??f_opendir_3
   3082          				dj->id = fs->id;
   \   00007C   9A4806000400 MOV.W   0x6(R8), 0x4(R10)
   3083          				res = dir_sdi(dj, 0);			/* Rewind dir */
   \   000082   0D43         MOV.W   #0x0, R13
   \   000084   CC0A         MOVA    R10, R12
   \   000086   ........     CALLA   #dir_sdi
   \   00008A   4B4C         MOV.B   R12, R11
   3084          			}
   3085          		}
   3086          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_opendir_3:
   \   00008C   6B92         CMP.B   #0x4, R11
   \   00008E   0220         JNE     ??f_opendir_6
   \   000090   7B400500     MOV.B   #0x5, R11
   3087          		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
   \                     ??f_opendir_6:
   \   000094   4B93         CMP.B   #0x0, R11
   \   000096   0724         JEQ     ??f_opendir_7
   \   000098   0018CA430000 MOVX.A  #0x0, 0(R10)
   \   00009E   033C         JMP     ??f_opendir_7
   3088          	} else {
   3089          		dj->fs = 0;
   \                     ??f_opendir_2:
   \   0000A0   0018CA430000 MOVX.A  #0x0, 0(R10)
   3090          	}
   3091          
   3092          	LEAVE_FF(fs, res);
   \                     ??f_opendir_7:
   \   0000A6   4C4B         MOV.B   R11, R12
   \                     ??f_opendir_1:
   \   0000A8   3150DA00     ADD.W   #0xda, SP
   \   0000AC   3816         POPM.A  #0x4, R11
   \   0000AE   1001         RETA
   3093          }
   3094          
   3095          
   3096          
   3097          
   3098          /*-----------------------------------------------------------------------*/
   3099          /* Read Directory Entry in Sequence                                      */
   3100          /*-----------------------------------------------------------------------*/
   3101          

   \                                 In  segment CODE, align 2
   3102          FRESULT f_readdir (
   \                     f_readdir:
   3103          	DIR *dj,			/* Pointer to the open directory object */
   3104          	FILINFO *fno		/* Pointer to file information to return */
   3105          )
   3106          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   3180D600     SUB.W   #0xd6, SP
   \   000006   CA0C         MOVA    R12, R10
   \   000008   CB0D         MOVA    R13, R11
   3107          	FRESULT res;
   3108          	DEF_NAMEBUF;
   3109          
   3110          
   3111          	res = validate(dj);						/* Check validity of the object */
   \   00000A   CC0A         MOVA    R10, R12
   \   00000C   ........     CALLA   #validate
   \   000010   484C         MOV.B   R12, R8
   3112          	if (res == FR_OK) {
   \   000012   4893         CMP.B   #0x0, R8
   \   000014   2E20         JNE     ??f_readdir_0
   3113          		if (!fno) {
   \   000016   DB03         CMPA    #0x0, R11
   \   000018   0620         JNE     ??f_readdir_1
   3114          			res = dir_sdi(dj, 0);			/* Rewind the directory object */
   \   00001A   0D43         MOV.W   #0x0, R13
   \   00001C   CC0A         MOVA    R10, R12
   \   00001E   ........     CALLA   #dir_sdi
   \   000022   484C         MOV.B   R12, R8
   \   000024   263C         JMP     ??f_readdir_0
   3115          		} else {
   3116          			INIT_BUF(*dj);
   \                     ??f_readdir_1:
   \   000026   0F41         MOV.W   SP, R15
   \   000028   0F53         ADD.W   #0x0, R15
   \   00002A   7A0F1800     MOVA    R15, 0x18(R10)
   \   00002E   0F41         MOV.W   SP, R15
   \   000030   3F500C00     ADD.W   #0xc, R15
   \   000034   7A0F1C00     MOVA    R15, 0x1c(R10)
   3117          			res = dir_read(dj);				/* Read an directory item */
   \   000038   CC0A         MOVA    R10, R12
   \   00003A   ........     CALLA   #dir_read
   \   00003E   484C         MOV.B   R12, R8
   3118          			if (res == FR_NO_FILE) {		/* Reached end of dir */
   \   000040   6892         CMP.B   #0x4, R8
   \   000042   0520         JNE     ??f_readdir_2
   3119          				dj->sect = 0;
   \   000044   8A431000     MOV.W   #0x0, 0x10(R10)
   \   000048   8A431200     MOV.W   #0x0, 0x12(R10)
   3120          				res = FR_OK;
   \   00004C   4843         MOV.B   #0x0, R8
   3121          			}
   3122          			if (res == FR_OK) {				/* A valid entry is found */
   \                     ??f_readdir_2:
   \   00004E   4893         CMP.B   #0x0, R8
   \   000050   1020         JNE     ??f_readdir_0
   3123          				get_fileinfo(dj, fno);		/* Get the object information */
   \   000052   CD0B         MOVA    R11, R13
   \   000054   CC0A         MOVA    R10, R12
   \   000056   ........     CALLA   #get_fileinfo
   3124          				res = dir_next(dj, 0);		/* Increment index for next */
   \   00005A   0D43         MOV.W   #0x0, R13
   \   00005C   CC0A         MOVA    R10, R12
   \   00005E   ........     CALLA   #dir_next
   \   000062   484C         MOV.B   R12, R8
   3125          				if (res == FR_NO_FILE) {
   \   000064   6892         CMP.B   #0x4, R8
   \   000066   0520         JNE     ??f_readdir_0
   3126          					dj->sect = 0;
   \   000068   8A431000     MOV.W   #0x0, 0x10(R10)
   \   00006C   8A431200     MOV.W   #0x0, 0x12(R10)
   3127          					res = FR_OK;
   \   000070   4843         MOV.B   #0x0, R8
   3128          				}
   3129          			}
   3130          			FREE_BUF();
   3131          		}
   3132          	}
   3133          
   3134          	LEAVE_FF(dj->fs, res);
   \                     ??f_readdir_0:
   \   000072   4C48         MOV.B   R8, R12
   \   000074   3150D600     ADD.W   #0xd6, SP
   \   000078   3816         POPM.A  #0x4, R11
   \   00007A   1001         RETA
   3135          }
   3136          
   3137          
   3138          
   3139          #if _FS_MINIMIZE == 0
   3140          /*-----------------------------------------------------------------------*/
   3141          /* Get File Status                                                       */
   3142          /*-----------------------------------------------------------------------*/
   3143          

   \                                 In  segment CODE, align 2
   3144          FRESULT f_stat (
   \                     f_stat:
   3145          	const TCHAR *path,	/* Pointer to the file path */
   3146          	FILINFO *fno		/* Pointer to file information to return */
   3147          )
   3148          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   0C14         PUSHM.A #0x1, R12
   \   000004   3180F800     SUB.W   #0xf8, SP
   \   000008   CA0D         MOVA    R13, R10
   3149          	FRESULT res;
   3150          	DIR dj;
   3151          	DEF_NAMEBUF;
   3152          
   3153          
   3154          	res = chk_mounted(&path, &dj.fs, 0);
   \   00000A   4E43         MOV.B   #0x0, R14
   \   00000C   0D41         MOV.W   SP, R13
   \   00000E   3D500C00     ADD.W   #0xc, R13
   \   000012   0C41         MOV.W   SP, R12
   \   000014   3C50F800     ADD.W   #0xf8, R12
   \   000018   ........     CALLA   #chk_mounted
   \   00001C   4B4C         MOV.B   R12, R11
   3155          	if (res == FR_OK) {
   \   00001E   4B93         CMP.B   #0x0, R11
   \   000020   2020         JNE     ??f_stat_0
   3156          		INIT_BUF(dj);
   \   000022   0F41         MOV.W   SP, R15
   \   000024   0F53         ADD.W   #0x0, R15
   \   000026   710F2400     MOVA    R15, 0x24(SP)
   \   00002A   0F41         MOV.W   SP, R15
   \   00002C   3F502E00     ADD.W   #0x2e, R15
   \   000030   710F2800     MOVA    R15, 0x28(SP)
   3157          		res = follow_path(&dj, path);	/* Follow the file path */
   \   000034   3D01F800     MOVA    0xf8(SP), R13
   \   000038   0C41         MOV.W   SP, R12
   \   00003A   3C500C00     ADD.W   #0xc, R12
   \   00003E   ........     CALLA   #follow_path
   \   000042   4B4C         MOV.B   R12, R11
   3158          		if (res == FR_OK) {				/* Follow completed */
   \   000044   4B93         CMP.B   #0x0, R11
   \   000046   0D20         JNE     ??f_stat_0
   3159          			if (dj.dir)		/* Found an object */
   \   000048   3F012000     MOVA    0x20(SP), R15
   \   00004C   DF03         CMPA    #0x0, R15
   \   00004E   0724         JEQ     ??f_stat_1
   3160          				get_fileinfo(&dj, fno);
   \   000050   CD0A         MOVA    R10, R13
   \   000052   0C41         MOV.W   SP, R12
   \   000054   3C500C00     ADD.W   #0xc, R12
   \   000058   ........     CALLA   #get_fileinfo
   \   00005C   023C         JMP     ??f_stat_0
   3161          			else			/* It is root dir */
   3162          				res = FR_INVALID_NAME;
   \                     ??f_stat_1:
   \   00005E   7B400600     MOV.B   #0x6, R11
   3163          		}
   3164          		FREE_BUF();
   3165          	}
   3166          
   3167          	LEAVE_FF(dj.fs, res);
   \                     ??f_stat_0:
   \   000062   4C4B         MOV.B   R11, R12
   \   000064   3150FC00     ADD.W   #0xfc, SP
   \   000068   1A16         POPM.A  #0x2, R11
   \   00006A   1001         RETA
   3168          }
   3169          
   3170          
   3171          
   3172          #if !_FS_READONLY
   3173          /*-----------------------------------------------------------------------*/
   3174          /* Get Number of Free Clusters                                           */
   3175          /*-----------------------------------------------------------------------*/
   3176          

   \                                 In  segment CODE, align 2
   3177          FRESULT f_getfree (
   \                     f_getfree:
   3178          	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
   3179          	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
   3180          	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
   3181          )
   3182          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   0C14         PUSHM.A #0x1, R12
   \   000004   0D14         PUSHM.A #0x1, R13
   \   000006   0E14         PUSHM.A #0x1, R14
   \   000008   31800A00     SUB.W   #0xa, SP
   3183          	FRESULT res;
   3184          	FATFS *fs;
   3185          	DWORD n, clst, sect, stat;
   3186          	UINT i;
   3187          	BYTE fat, *p;
   3188          
   3189          
   3190          	/* Get drive number */
   3191          	res = chk_mounted(&path, fatfs, 0);
   \   00000C   4E43         MOV.B   #0x0, R14
   \   00000E   3D010A00     MOVA    0xa(SP), R13
   \   000012   0C41         MOV.W   SP, R12
   \   000014   3C501200     ADD.W   #0x12, R12
   \   000018   ........     CALLA   #chk_mounted
   \   00001C   454C         MOV.B   R12, R5
   3192          	fs = *fatfs;
   \   00001E   3F010A00     MOVA    0xa(SP), R15
   \   000022   080F         MOVA    @R15, R8
   3193          	if (res == FR_OK) {
   \   000024   4593         CMP.B   #0x0, R5
   \   000026   CA20         JNE     ??f_getfree_5
   3194          		/* If free_clust is valid, return it without full cluster scan */
   3195          		if (fs->free_clust <= fs->n_fatent - 2) {
   \   000028   1E481A00     MOV.W   0x1a(R8), R14
   \   00002C   1F481C00     MOV.W   0x1c(R8), R15
   \   000030   3E50FEFF     ADD.W   #0xfffe, R14
   \   000034   3F63         ADDC.W  #0xffff, R15
   \   000036   1F981000     CMP.W   0x10(R8), R15
   \   00003A   0D28         JNC     ??f_getfree_6
   \   00003C   0320         JNE     ??f_getfree_7
   \   00003E   1E980E00     CMP.W   0xe(R8), R14
   \   000042   0928         JNC     ??f_getfree_6
   3196          			*nclst = fs->free_clust;
   \                     ??f_getfree_7:
   \   000044   3F010E00     MOVA    0xe(SP), R15
   \   000048   9F480E000000 MOV.W   0xe(R8), 0(R15)
   \   00004E   9F4810000200 MOV.W   0x10(R8), 0x2(R15)
   \   000054   B33C         JMP     ??f_getfree_5
   3197          		} else {
   3198          			/* Get number of free clusters */
   3199          			fat = fs->fs_type;
   \                     ??f_getfree_6:
   \   000056   4018E1480000 MOVX.B  @R8, 0(SP)
   3200          			n = 0;
   \   00005C   0A43         MOV.W   #0x0, R10
   \   00005E   0B43         MOV.W   #0x0, R11
   3201          			if (fat == FS_FAT12) {
   \   000060   D1930000     CMP.B   #0x1, 0(SP)
   \   000064   2D20         JNE     ??f_getfree_8
   3202          				clst = 2;
   \   000066   2643         MOV.W   #0x2, R6
   \   000068   0743         MOV.W   #0x0, R7
   3203          				do {
   3204          					stat = get_fat(fs, clst);
   \                     ??f_getfree_0:
   \   00006A   0E46         MOV.W   R6, R14
   \   00006C   0F47         MOV.W   R7, R15
   \   00006E   CC08         MOVA    R8, R12
   \   000070   ........     CALLA   #get_fat
   \   000074   814C0200     MOV.W   R12, 0x2(SP)
   \   000078   814D0400     MOV.W   R13, 0x4(SP)
   3205          					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   \   00007C   B1930200     CMP.W   #0xffff, 0x2(SP)
   \   000080   0520         JNE     ??f_getfree_9
   \   000082   B1930400     CMP.W   #0xffff, 0x4(SP)
   \   000086   0220         JNE     ??f_getfree_9
   \   000088   5543         MOV.B   #0x1, R5
   \   00008A   883C         JMP     ??f_getfree_3
   3206          					if (stat == 1) { res = FR_INT_ERR; break; }
   \                     ??f_getfree_9:
   \   00008C   91930200     CMP.W   #0x1, 0x2(SP)
   \   000090   0520         JNE     ??f_getfree_10
   \   000092   81930400     CMP.W   #0x0, 0x4(SP)
   \   000096   0220         JNE     ??f_getfree_10
   \   000098   6543         MOV.B   #0x2, R5
   \   00009A   803C         JMP     ??f_getfree_3
   3207          					if (stat == 0) n++;
   \                     ??f_getfree_10:
   \   00009C   1F410200     MOV.W   0x2(SP), R15
   \   0000A0   1FD10400     BIS.W   0x4(SP), R15
   \   0000A4   0F93         CMP.W   #0x0, R15
   \   0000A6   0220         JNE     ??f_getfree_11
   \   0000A8   1A53         ADD.W   #0x1, R10
   \   0000AA   0B63         ADDC.W  #0x0, R11
   3208          				} while (++clst < fs->n_fatent);
   \                     ??f_getfree_11:
   \   0000AC   1653         ADD.W   #0x1, R6
   \   0000AE   0763         ADDC.W  #0x0, R7
   \   0000B0   17981C00     CMP.W   0x1c(R8), R7
   \   0000B4   DA2B         JNC     ??f_getfree_0
   \   0000B6   7220         JNE     ??f_getfree_3
   \   0000B8   16981A00     CMP.W   0x1a(R8), R6
   \   0000BC   D62B         JNC     ??f_getfree_0
   \   0000BE   6E3C         JMP     ??f_getfree_3
   3209          			} else {
   3210          				clst = fs->n_fatent;
   \                     ??f_getfree_8:
   \   0000C0   16481A00     MOV.W   0x1a(R8), R6
   \   0000C4   17481C00     MOV.W   0x1c(R8), R7
   3211          				sect = fs->fatbase;
   \   0000C8   914822000600 MOV.W   0x22(R8), 0x6(SP)
   \   0000CE   914824000800 MOV.W   0x24(R8), 0x8(SP)
   3212          				i = 0; p = 0;
   \   0000D4   0443         MOV.W   #0x0, R4
   \   0000D6   4943         MOVA    #0x0, R9
   3213          				do {
   3214          					if (!i) {
   \                     ??f_getfree_1:
   \   0000D8   0493         CMP.W   #0x0, R4
   \   0000DA   1A20         JNE     ??f_getfree_12
   3215          						res = move_window(fs, sect++);
   \   0000DC   1E410600     MOV.W   0x6(SP), R14
   \   0000E0   1F410800     MOV.W   0x8(SP), R15
   \   0000E4   CC08         MOVA    R8, R12
   \   0000E6   ........     CALLA   #move_window
   \   0000EA   454C         MOV.B   R12, R5
   \   0000EC   1E410600     MOV.W   0x6(SP), R14
   \   0000F0   1F410800     MOV.W   0x8(SP), R15
   \   0000F4   1E53         ADD.W   #0x1, R14
   \   0000F6   0F63         ADDC.W  #0x0, R15
   \   0000F8   814E0600     MOV.W   R14, 0x6(SP)
   \   0000FC   814F0800     MOV.W   R15, 0x8(SP)
   3216          						if (res != FR_OK) break;
   \   000100   4593         CMP.B   #0x0, R5
   \   000102   4C20         JNE     ??f_getfree_3
   3217          						p = fs->win;
   \   000104   CF08         MOVA    R8, R15
   \   000106   AF003200     ADDA    #0x32, R15
   \   00010A   C90F         MOVA    R15, R9
   3218          						i = SS(fs);
   \   00010C   34400002     MOV.W   #0x200, R4
   3219          					}
   3220          					if (fat == FS_FAT16) {
   \                     ??f_getfree_12:
   \   000110   E1930000     CMP.B   #0x2, 0(SP)
   \   000114   1120         JNE     ??f_getfree_13
   3221          						if (LD_WORD(p) == 0) n++;
   \   000116   6E49         MOV.B   @R9, R14
   \   000118   4E4E         MOV.B   R14, R14
   \   00011A   5F490100     MOV.B   0x1(R9), R15
   \   00011E   4F4F         MOV.B   R15, R15
   \   000120   3FF0FF00     AND.W   #0xff, R15
   \   000124   8F10         SWPB    R15
   \   000126   0FDE         BIS.W   R14, R15
   \   000128   0F93         CMP.W   #0x0, R15
   \   00012A   0220         JNE     ??f_getfree_14
   \   00012C   1A53         ADD.W   #0x1, R10
   \   00012E   0B63         ADDC.W  #0x0, R11
   3222          						p += 2; i -= 2;
   \                     ??f_getfree_14:
   \   000130   E903         ADDA    #0x2, R9
   \   000132   3450FEFF     ADD.W   #0xfffe, R4
   \   000136   2C3C         JMP     ??f_getfree_15
   3223          					} else {
   3224          						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
   \                     ??f_getfree_13:
   \   000138   6F49         MOV.B   @R9, R15
   \   00013A   4F4F         MOV.B   R15, R15
   \   00013C   0F12         PUSH.W  R15
   \   00013E   5F490100     MOV.B   0x1(R9), R15
   \   000142   4F4F         MOV.B   R15, R15
   \   000144   3FF0FF00     AND.W   #0xff, R15
   \   000148   8F10         SWPB    R15
   \   00014A   0F12         PUSH.W  R15
   \   00014C   5E490200     MOV.B   0x2(R9), R14
   \   000150   4E4E         MOV.B   R14, R14
   \   000152   0F43         MOV.W   #0x0, R15
   \   000154   0F4E         MOV.W   R14, R15
   \   000156   0E43         MOV.W   #0x0, R14
   \   000158   0C4E         MOV.W   R14, R12
   \   00015A   0D4F         MOV.W   R15, R13
   \   00015C   5E490300     MOV.B   0x3(R9), R14
   \   000160   4E4E         MOV.B   R14, R14
   \   000162   0F43         MOV.W   #0x0, R15
   \   000164   3EF0FF00     AND.W   #0xff, R14
   \   000168   8E10         SWPB    R14
   \   00016A   0F4E         MOV.W   R14, R15
   \   00016C   0E43         MOV.W   #0x0, R14
   \   00016E   0EDC         BIS.W   R12, R14
   \   000170   0FDD         BIS.W   R13, R15
   \   000172   3D41         POP.W   R13
   \   000174   0EDD         BIS.W   R13, R14
   \   000176   3D41         POP.W   R13
   \   000178   0EDD         BIS.W   R13, R14
   \   00017A   3EB3         BIT.W   #0xffff, R14
   \   00017C   0520         JNE     ??f_getfree_16
   \   00017E   3FB0FF0F     BIT.W   #0xfff, R15
   \   000182   0220         JNE     ??f_getfree_16
   \   000184   1A53         ADD.W   #0x1, R10
   \   000186   0B63         ADDC.W  #0x0, R11
   3225          						p += 4; i -= 4;
   \                     ??f_getfree_16:
   \   000188   A9000400     ADDA    #0x4, R9
   \   00018C   3450FCFF     ADD.W   #0xfffc, R4
   3226          					}
   3227          				} while (--clst);
   \                     ??f_getfree_15:
   \   000190   3653         ADD.W   #0xffff, R6
   \   000192   3763         ADDC.W  #0xffff, R7
   \   000194   0F46         MOV.W   R6, R15
   \   000196   0FD7         BIS.W   R7, R15
   \   000198   0F93         CMP.W   #0x0, R15
   \   00019A   9E23         JNE     ??f_getfree_1
   3228          			}
   3229          			fs->free_clust = n;
   \                     ??f_getfree_3:
   \   00019C   884A0E00     MOV.W   R10, 0xe(R8)
   \   0001A0   884B1000     MOV.W   R11, 0x10(R8)
   3230          			if (fat == FS_FAT32) fs->fsi_flag = 1;
   \   0001A4   F19003000000 CMP.B   #0x3, 0(SP)
   \   0001AA   0220         JNE     ??f_getfree_17
   \   0001AC   D8430500     MOV.B   #0x1, 0x5(R8)
   3231          			*nclst = n;
   \                     ??f_getfree_17:
   \   0001B0   3F010E00     MOVA    0xe(SP), R15
   \   0001B4   8F4A0000     MOV.W   R10, 0(R15)
   \   0001B8   8F4B0200     MOV.W   R11, 0x2(R15)
   3232          		}
   3233          	}
   3234          	LEAVE_FF(fs, res);
   \                     ??f_getfree_5:
   \   0001BC   4C45         MOV.B   R5, R12
   \   0001BE   31501600     ADD.W   #0x16, SP
   \   0001C2   7416         POPM.A  #0x8, R11
   \   0001C4   1001         RETA
   3235          }
   3236          
   3237          
   3238          
   3239          
   3240          /*-----------------------------------------------------------------------*/
   3241          /* Truncate File                                                         */
   3242          /*-----------------------------------------------------------------------*/
   3243          

   \                                 In  segment CODE, align 2
   3244          FRESULT f_truncate (
   \                     f_truncate:
   3245          	FIL *fp		/* Pointer to the file object */
   3246          )
   3247          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   CA0C         MOVA    R12, R10
   3248          	FRESULT res;
   3249          	DWORD ncl;
   3250          
   3251          
   3252          	if (!fp) return FR_INVALID_OBJECT;
   \   000004   DA03         CMPA    #0x0, R10
   \   000006   0320         JNE     ??f_truncate_0
   \   000008   7C400900     MOV.B   #0x9, R12
   \   00000C   713C         JMP     ??f_truncate_1
   3253          
   3254          	res = validate(fp);						/* Check validity of the object */
   \                     ??f_truncate_0:
   \   00000E   CC0A         MOVA    R10, R12
   \   000010   ........     CALLA   #validate
   \   000014   4B4C         MOV.B   R12, R11
   3255          	if (res == FR_OK) {
   \   000016   4B93         CMP.B   #0x0, R11
   \   000018   0A20         JNE     ??f_truncate_2
   3256          		if (fp->flag & FA__ERROR) {			/* Check abort flag */
   \   00001A   CA930600     CMP.B   #0x0, 0x6(R10)
   \   00001E   0234         JGE     ??f_truncate_3
   3257          			res = FR_INT_ERR;
   \   000020   6B43         MOV.B   #0x2, R11
   \   000022   053C         JMP     ??f_truncate_2
   3258          		} else {
   3259          			if (!(fp->flag & FA_WRITE))		/* Check access mode */
   \                     ??f_truncate_3:
   \   000024   EAB30600     BIT.B   #0x2, 0x6(R10)
   \   000028   022C         JC      ??f_truncate_2
   3260          				res = FR_DENIED;
   \   00002A   7B400700     MOV.B   #0x7, R11
   3261          		}
   3262          	}
   3263          	if (res == FR_OK) {
   \                     ??f_truncate_2:
   \   00002E   4B93         CMP.B   #0x0, R11
   \   000030   5E20         JNE     ??f_truncate_4
   3264          		if (fp->fsize > fp->fptr) {
   \   000032   9A9A0E000A00 CMP.W   0xe(R10), 0xa(R10)
   \   000038   0528         JNC     ??f_truncate_5
   \   00003A   5320         JNE     ??f_truncate_6
   \   00003C   9A9A0C000800 CMP.W   0xc(R10), 0x8(R10)
   \   000042   4F2C         JC      ??f_truncate_6
   3265          			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
   \                     ??f_truncate_5:
   \   000044   9A4A08000C00 MOV.W   0x8(R10), 0xc(R10)
   \   00004A   9A4A0A000E00 MOV.W   0xa(R10), 0xe(R10)
   3266          			fp->flag |= FA__WRITTEN;
   \   000050   CF0A         MOVA    R10, R15
   \   000052   FFD020000600 BIS.B   #0x20, 0x6(R15)
   3267          			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
   \   000058   1F4A0800     MOV.W   0x8(R10), R15
   \   00005C   1FDA0A00     BIS.W   0xa(R10), R15
   \   000060   0F93         CMP.W   #0x0, R15
   \   000062   0D20         JNE     ??f_truncate_7
   3268          				res = remove_chain(fp->fs, fp->sclust);
   \   000064   1E4A1000     MOV.W   0x10(R10), R14
   \   000068   1F4A1200     MOV.W   0x12(R10), R15
   \   00006C   0C0A         MOVA    @R10, R12
   \   00006E   ........     CALLA   #remove_chain
   \   000072   4B4C         MOV.B   R12, R11
   3269          				fp->sclust = 0;
   \   000074   8A431000     MOV.W   #0x0, 0x10(R10)
   \   000078   8A431200     MOV.W   #0x0, 0x12(R10)
   \   00007C   323C         JMP     ??f_truncate_6
   3270          			} else {				/* When truncate a part of the file, remove remaining clusters */
   3271          				ncl = get_fat(fp->fs, fp->clust);
   \                     ??f_truncate_7:
   \   00007E   1E4A1400     MOV.W   0x14(R10), R14
   \   000082   1F4A1600     MOV.W   0x16(R10), R15
   \   000086   0C0A         MOVA    @R10, R12
   \   000088   ........     CALLA   #get_fat
   \   00008C   084C         MOV.W   R12, R8
   \   00008E   094D         MOV.W   R13, R9
   3272          				res = FR_OK;
   \   000090   4B43         MOV.B   #0x0, R11
   3273          				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \   000092   3893         CMP.W   #0xffff, R8
   \   000094   0320         JNE     ??f_truncate_8
   \   000096   3993         CMP.W   #0xffff, R9
   \   000098   0120         JNE     ??f_truncate_8
   \   00009A   5B43         MOV.B   #0x1, R11
   3274          				if (ncl == 1) res = FR_INT_ERR;
   \                     ??f_truncate_8:
   \   00009C   1893         CMP.W   #0x1, R8
   \   00009E   0320         JNE     ??f_truncate_9
   \   0000A0   0993         CMP.W   #0x0, R9
   \   0000A2   0120         JNE     ??f_truncate_9
   \   0000A4   6B43         MOV.B   #0x2, R11
   3275          				if (res == FR_OK && ncl < fp->fs->n_fatent) {
   \                     ??f_truncate_9:
   \   0000A6   4B93         CMP.B   #0x0, R11
   \   0000A8   1C20         JNE     ??f_truncate_6
   \   0000AA   0F0A         MOVA    @R10, R15
   \   0000AC   199F1C00     CMP.W   0x1c(R15), R9
   \   0000B0   0428         JNC     ??f_truncate_10
   \   0000B2   1720         JNE     ??f_truncate_6
   \   0000B4   189F1A00     CMP.W   0x1a(R15), R8
   \   0000B8   142C         JC      ??f_truncate_6
   3276          					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
   \                     ??f_truncate_10:
   \   0000BA   3012FF0F     PUSH.W  #0xfff
   \   0000BE   3312         PUSH.W  #0xffff
   \   0000C0   1E4A1400     MOV.W   0x14(R10), R14
   \   0000C4   1F4A1600     MOV.W   0x16(R10), R15
   \   0000C8   0C0A         MOVA    @R10, R12
   \   0000CA   ........     CALLA   #put_fat
   \   0000CE   4B4C         MOV.B   R12, R11
   3277          					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
   \   0000D0   2152         ADD.W   #0x4, SP
   \   0000D2   4B93         CMP.B   #0x0, R11
   \   0000D4   0620         JNE     ??f_truncate_6
   \   0000D6   0E48         MOV.W   R8, R14
   \   0000D8   0F49         MOV.W   R9, R15
   \   0000DA   0C0A         MOVA    @R10, R12
   \   0000DC   ........     CALLA   #remove_chain
   \   0000E0   4B4C         MOV.B   R12, R11
   3278          				}
   3279          			}
   3280          		}
   3281          		if (res != FR_OK) fp->flag |= FA__ERROR;
   \                     ??f_truncate_6:
   \   0000E2   4B93         CMP.B   #0x0, R11
   \   0000E4   0424         JEQ     ??f_truncate_4
   \   0000E6   CF0A         MOVA    R10, R15
   \   0000E8   FFD080000600 BIS.B   #0x80, 0x6(R15)
   3282          	}
   3283          
   3284          	LEAVE_FF(fp->fs, res);
   \                     ??f_truncate_4:
   \   0000EE   4C4B         MOV.B   R11, R12
   \                     ??f_truncate_1:
   \   0000F0   3816         POPM.A  #0x4, R11
   \   0000F2   1001         RETA
   3285          }
   3286          
   3287          
   3288          
   3289          
   3290          /*-----------------------------------------------------------------------*/
   3291          /* Delete a File or Directory                                            */
   3292          /*-----------------------------------------------------------------------*/
   3293          

   \                                 In  segment CODE, align 2
   3294          FRESULT f_unlink (
   \                     f_unlink:
   3295          	const TCHAR *path		/* Pointer to the file or directory path */
   3296          )
   3297          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   0C14         PUSHM.A #0x1, R12
   \   000004   31801A01     SUB.W   #0x11a, SP
   3298          	FRESULT res;
   3299          	DIR dj, sdj;
   3300          	BYTE *dir;
   3301          	DWORD dclst;
   3302          	DEF_NAMEBUF;
   3303          
   3304          
   3305          	res = chk_mounted(&path, &dj.fs, 1);
   \   000008   5E43         MOV.B   #0x1, R14
   \   00000A   0D41         MOV.W   SP, R13
   \   00000C   0D53         ADD.W   #0x0, R13
   \   00000E   0C41         MOV.W   SP, R12
   \   000010   3C501A01     ADD.W   #0x11a, R12
   \   000014   ........     CALLA   #chk_mounted
   \   000018   4A4C         MOV.B   R12, R10
   3306          	if (res == FR_OK) {
   \   00001A   4A93         CMP.B   #0x0, R10
   \   00001C   7F20         JNE     ??f_unlink_1
   3307          		INIT_BUF(dj);
   \   00001E   0F41         MOV.W   SP, R15
   \   000020   3F502200     ADD.W   #0x22, R15
   \   000024   710F1800     MOVA    R15, 0x18(SP)
   \   000028   0F41         MOV.W   SP, R15
   \   00002A   3F505000     ADD.W   #0x50, R15
   \   00002E   710F1C00     MOVA    R15, 0x1c(SP)
   3308          		res = follow_path(&dj, path);		/* Follow the file path */
   \   000032   3D011A01     MOVA    0x11a(SP), R13
   \   000036   0C41         MOV.W   SP, R12
   \   000038   0C53         ADD.W   #0x0, R12
   \   00003A   ........     CALLA   #follow_path
   \   00003E   4A4C         MOV.B   R12, R10
   3309          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \   000040   4A93         CMP.B   #0x0, R10
   \   000042   0820         JNE     ??f_unlink_2
   \   000044   3F011800     MOVA    0x18(SP), R15
   \   000048   FFB020000B00 BIT.B   #0x20, 0xb(R15)
   \   00004E   0228         JNC     ??f_unlink_2
   3310          			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
   \   000050   7A400600     MOV.B   #0x6, R10
   3311          #if _FS_LOCK
   3312          		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
   3313          #endif
   3314          		if (res == FR_OK) {					/* The object is accessible */
   \                     ??f_unlink_2:
   \   000054   4A93         CMP.B   #0x0, R10
   \   000056   6220         JNE     ??f_unlink_1
   3315          			dir = dj.dir;
   \   000058   3B011400     MOVA    0x14(SP), R11
   3316          			if (!dir) {
   \   00005C   DB03         CMPA    #0x0, R11
   \   00005E   0320         JNE     ??f_unlink_3
   3317          				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
   \   000060   7A400600     MOV.B   #0x6, R10
   \   000064   053C         JMP     ??f_unlink_4
   3318          			} else {
   3319          				if (dir[DIR_Attr] & AM_RDO)
   \                     ??f_unlink_3:
   \   000066   DBB30B00     BIT.B   #0x1, 0xb(R11)
   \   00006A   0228         JNC     ??f_unlink_4
   3320          					res = FR_DENIED;		/* Cannot remove R/O object */
   \   00006C   7A400700     MOV.B   #0x7, R10
   3321          			}
   3322          			dclst = ld_clust(dj.fs, dir);
   \                     ??f_unlink_4:
   \   000070   CD0B         MOVA    R11, R13
   \   000072   0C01         MOVA    @SP, R12
   \   000074   ........     CALLA   #ld_clust
   \   000078   084C         MOV.W   R12, R8
   \   00007A   094D         MOV.W   R13, R9
   3323          			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
   \   00007C   4A93         CMP.B   #0x0, R10
   \   00007E   3520         JNE     ??f_unlink_5
   \   000080   FBB010000B00 BIT.B   #0x10, 0xb(R11)
   \   000086   3128         JNC     ??f_unlink_5
   3324          				if (dclst < 2) {
   \   000088   0993         CMP.W   #0x0, R9
   \   00008A   0328         JNC     ??f_unlink_6
   \   00008C   0420         JNE     ??f_unlink_7
   \   00008E   2893         CMP.W   #0x2, R8
   \   000090   022C         JC      ??f_unlink_7
   3325          					res = FR_INT_ERR;
   \                     ??f_unlink_6:
   \   000092   6A43         MOV.B   #0x2, R10
   \   000094   2A3C         JMP     ??f_unlink_5
   3326          				} else {
   3327          					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
   \                     ??f_unlink_7:
   \   000096   3E402200     MOV.W   #0x22, R14
   \   00009A   0D41         MOV.W   SP, R13
   \   00009C   0D53         ADD.W   #0x0, R13
   \   00009E   0C41         MOV.W   SP, R12
   \   0000A0   3C502E00     ADD.W   #0x2e, R12
   \   0000A4   ........     CALLA   #mem_cpy
   3328          					sdj.sclust = dclst;
   \   0000A8   81483600     MOV.W   R8, 0x36(SP)
   \   0000AC   81493800     MOV.W   R9, 0x38(SP)
   3329          					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
   \   0000B0   2D43         MOV.W   #0x2, R13
   \   0000B2   0C41         MOV.W   SP, R12
   \   0000B4   3C502E00     ADD.W   #0x2e, R12
   \   0000B8   ........     CALLA   #dir_sdi
   \   0000BC   4A4C         MOV.B   R12, R10
   3330          					if (res == FR_OK) {
   \   0000BE   4A93         CMP.B   #0x0, R10
   \   0000C0   1420         JNE     ??f_unlink_5
   3331          						res = dir_read(&sdj);
   \   0000C2   0C41         MOV.W   SP, R12
   \   0000C4   3C502E00     ADD.W   #0x2e, R12
   \   0000C8   ........     CALLA   #dir_read
   \   0000CC   4A4C         MOV.B   R12, R10
   3332          						if (res == FR_OK		/* Not empty dir */
   3333          #if _FS_RPATH
   3334          						|| dclst == dj.fs->cdir	/* Current dir */
   3335          #endif
   3336          						) res = FR_DENIED;
   \   0000CE   4A93         CMP.B   #0x0, R10
   \   0000D0   0724         JEQ     ??f_unlink_0
   \   0000D2   0F01         MOVA    @SP, R15
   \   0000D4   189F1600     CMP.W   0x16(R15), R8
   \   0000D8   0520         JNE     ??f_unlink_8
   \   0000DA   199F1800     CMP.W   0x18(R15), R9
   \   0000DE   0220         JNE     ??f_unlink_8
   \                     ??f_unlink_0:
   \   0000E0   7A400700     MOV.B   #0x7, R10
   3337          						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
   \                     ??f_unlink_8:
   \   0000E4   6A92         CMP.B   #0x4, R10
   \   0000E6   0120         JNE     ??f_unlink_5
   \   0000E8   4A43         MOV.B   #0x0, R10
   3338          					}
   3339          				}
   3340          			}
   3341          			if (res == FR_OK) {
   \                     ??f_unlink_5:
   \   0000EA   4A93         CMP.B   #0x0, R10
   \   0000EC   1720         JNE     ??f_unlink_1
   3342          				res = dir_remove(&dj);		/* Remove the directory entry */
   \   0000EE   0C41         MOV.W   SP, R12
   \   0000F0   0C53         ADD.W   #0x0, R12
   \   0000F2   ........     CALLA   #dir_remove
   \   0000F6   4A4C         MOV.B   R12, R10
   3343          				if (res == FR_OK) {
   \   0000F8   4A93         CMP.B   #0x0, R10
   \   0000FA   1020         JNE     ??f_unlink_1
   3344          					if (dclst)				/* Remove the cluster chain if exist */
   \   0000FC   0F48         MOV.W   R8, R15
   \   0000FE   0FD9         BIS.W   R9, R15
   \   000100   0F93         CMP.W   #0x0, R15
   \   000102   0624         JEQ     ??f_unlink_9
   3345          						res = remove_chain(dj.fs, dclst);
   \   000104   0E48         MOV.W   R8, R14
   \   000106   0F49         MOV.W   R9, R15
   \   000108   0C01         MOVA    @SP, R12
   \   00010A   ........     CALLA   #remove_chain
   \   00010E   4A4C         MOV.B   R12, R10
   3346          					if (res == FR_OK) res = sync(dj.fs);
   \                     ??f_unlink_9:
   \   000110   4A93         CMP.B   #0x0, R10
   \   000112   0420         JNE     ??f_unlink_1
   \   000114   0C01         MOVA    @SP, R12
   \   000116   ........     CALLA   #sync
   \   00011A   4A4C         MOV.B   R12, R10
   3347          				}
   3348          			}
   3349          		}
   3350          		FREE_BUF();
   3351          	}
   3352          	LEAVE_FF(dj.fs, res);
   \                     ??f_unlink_1:
   \   00011C   4C4A         MOV.B   R10, R12
   \   00011E   31501E01     ADD.W   #0x11e, SP
   \   000122   3816         POPM.A  #0x4, R11
   \   000124   1001         RETA
   3353          }
   3354          
   3355          
   3356          
   3357          
   3358          /*-----------------------------------------------------------------------*/
   3359          /* Create a Directory                                                    */
   3360          /*-----------------------------------------------------------------------*/
   3361          

   \                                 In  segment CODE, align 2
   3362          FRESULT f_mkdir (
   \                     f_mkdir:
   3363          	const TCHAR *path		/* Pointer to the directory path */
   3364          )
   3365          {
   \   000000   7B14         PUSHM.A #0x8, R11
   \   000002   0C14         PUSHM.A #0x1, R12
   \   000004   3180FE00     SUB.W   #0xfe, SP
   3366          	FRESULT res;
   3367          	DIR dj;
   3368          	BYTE *dir, n;
   3369          	DWORD dsc, dcl, pcl, tim = get_fattime();
   \   000008   ........     CALLA   #get_fattime
   \   00000C   084C         MOV.W   R12, R8
   \   00000E   094D         MOV.W   R13, R9
   3370          	DEF_NAMEBUF;
   3371          
   3372          
   3373          	res = chk_mounted(&path, &dj.fs, 1);
   \   000010   5E43         MOV.B   #0x1, R14
   \   000012   0D41         MOV.W   SP, R13
   \   000014   3D500600     ADD.W   #0x6, R13
   \   000018   0C41         MOV.W   SP, R12
   \   00001A   3C50FE00     ADD.W   #0xfe, R12
   \   00001E   ........     CALLA   #chk_mounted
   \   000022   4B4C         MOV.B   R12, R11
   3374          	if (res == FR_OK) {
   \   000024   4B93         CMP.B   #0x0, R11
   \   000026   0621         JNE     ??f_mkdir_3
   3375          		INIT_BUF(dj);
   \   000028   0F41         MOV.W   SP, R15
   \   00002A   3F502800     ADD.W   #0x28, R15
   \   00002E   710F1E00     MOVA    R15, 0x1e(SP)
   \   000032   0F41         MOV.W   SP, R15
   \   000034   3F503400     ADD.W   #0x34, R15
   \   000038   710F2200     MOVA    R15, 0x22(SP)
   3376          		res = follow_path(&dj, path);			/* Follow the file path */
   \   00003C   3D01FE00     MOVA    0xfe(SP), R13
   \   000040   0C41         MOV.W   SP, R12
   \   000042   3C500600     ADD.W   #0x6, R12
   \   000046   ........     CALLA   #follow_path
   \   00004A   4B4C         MOV.B   R12, R11
   3377          		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
   \   00004C   4B93         CMP.B   #0x0, R11
   \   00004E   0120         JNE     ??f_mkdir_4
   \   000050   7B42         MOV.B   #0x8, R11
   3378          		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
   \                     ??f_mkdir_4:
   \   000052   6B92         CMP.B   #0x4, R11
   \   000054   0820         JNE     ??f_mkdir_5
   \   000056   3F011E00     MOVA    0x1e(SP), R15
   \   00005A   FFB020000B00 BIT.B   #0x20, 0xb(R15)
   \   000060   0228         JNC     ??f_mkdir_5
   3379          			res = FR_INVALID_NAME;
   \   000062   7B400600     MOV.B   #0x6, R11
   3380          		if (res == FR_NO_FILE) {				/* Can create a new directory */
   \                     ??f_mkdir_5:
   \   000066   6B92         CMP.B   #0x4, R11
   \   000068   E520         JNE     ??f_mkdir_3
   3381          			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
   \   00006A   0E43         MOV.W   #0x0, R14
   \   00006C   0F43         MOV.W   #0x0, R15
   \   00006E   3C010600     MOVA    0x6(SP), R12
   \   000072   ........     CALLA   #create_chain
   \   000076   064C         MOV.W   R12, R6
   \   000078   074D         MOV.W   R13, R7
   3382          			res = FR_OK;
   \   00007A   4B43         MOV.B   #0x0, R11
   3383          			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
   \   00007C   0F46         MOV.W   R6, R15
   \   00007E   0FD7         BIS.W   R7, R15
   \   000080   0F93         CMP.W   #0x0, R15
   \   000082   0220         JNE     ??f_mkdir_6
   \   000084   7B400700     MOV.B   #0x7, R11
   3384          			if (dcl == 1) res = FR_INT_ERR;
   \                     ??f_mkdir_6:
   \   000088   1693         CMP.W   #0x1, R6
   \   00008A   0320         JNE     ??f_mkdir_7
   \   00008C   0793         CMP.W   #0x0, R7
   \   00008E   0120         JNE     ??f_mkdir_7
   \   000090   6B43         MOV.B   #0x2, R11
   3385          			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \                     ??f_mkdir_7:
   \   000092   3693         CMP.W   #0xffff, R6
   \   000094   0320         JNE     ??f_mkdir_8
   \   000096   3793         CMP.W   #0xffff, R7
   \   000098   0120         JNE     ??f_mkdir_8
   \   00009A   5B43         MOV.B   #0x1, R11
   3386          			if (res == FR_OK)					/* Flush FAT */
   \                     ??f_mkdir_8:
   \   00009C   4B93         CMP.B   #0x0, R11
   \   00009E   0720         JNE     ??f_mkdir_9
   3387          				res = move_window(dj.fs, 0);
   \   0000A0   0E43         MOV.W   #0x0, R14
   \   0000A2   0F43         MOV.W   #0x0, R15
   \   0000A4   3C010600     MOVA    0x6(SP), R12
   \   0000A8   ........     CALLA   #move_window
   \   0000AC   4B4C         MOV.B   R12, R11
   3388          			if (res == FR_OK) {					/* Initialize the new directory table */
   \                     ??f_mkdir_9:
   \   0000AE   4B93         CMP.B   #0x0, R11
   \   0000B0   8C20         JNE     ??f_mkdir_2
   3389          				dsc = clust2sect(dj.fs, dcl);
   \   0000B2   0E46         MOV.W   R6, R14
   \   0000B4   0F47         MOV.W   R7, R15
   \   0000B6   3C010600     MOVA    0x6(SP), R12
   \   0000BA   ........     CALLA   #clust2sect
   \   0000BE   044C         MOV.W   R12, R4
   \   0000C0   054D         MOV.W   R13, R5
   3390          				dir = dj.fs->win;
   \   0000C2   3F010600     MOVA    0x6(SP), R15
   \   0000C6   AF003200     ADDA    #0x32, R15
   \   0000CA   CA0F         MOVA    R15, R10
   3391          				mem_set(dir, 0, SS(dj.fs));
   \   0000CC   3E400002     MOV.W   #0x200, R14
   \   0000D0   0D43         MOV.W   #0x0, R13
   \   0000D2   CC0A         MOVA    R10, R12
   \   0000D4   ........     CALLA   #mem_set
   3392          				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
   \   0000D8   3E400B00     MOV.W   #0xb, R14
   \   0000DC   3D402000     MOV.W   #0x20, R13
   \   0000E0   CC0A         MOVA    R10, R12
   \   0000E2   ........     CALLA   #mem_set
   3393          				dir[DIR_Name] = '.';
   \   0000E6   FA402E000000 MOV.B   #0x2e, 0(R10)
   3394          				dir[DIR_Attr] = AM_DIR;
   \   0000EC   FA4010000B00 MOV.B   #0x10, 0xb(R10)
   3395          				ST_DWORD(dir+DIR_WrtTime, tim);
   \   0000F2   CA481600     MOV.B   R8, 0x16(R10)
   \   0000F6   0F48         MOV.W   R8, R15
   \   0000F8   8F10         SWPB    R15
   \   0000FA   3FF0FF00     AND.W   #0xff, R15
   \   0000FE   CA4F1700     MOV.B   R15, 0x17(R10)
   \   000102   CA491800     MOV.B   R9, 0x18(R10)
   \   000106   0E48         MOV.W   R8, R14
   \   000108   0F49         MOV.W   R9, R15
   \   00010A   8F10         SWPB    R15
   \   00010C   4E4F         MOV.B   R15, R14
   \   00010E   0F43         MOV.W   #0x0, R15
   \   000110   CA4E1900     MOV.B   R14, 0x19(R10)
   3396          				st_clust(dir, dcl);
   \   000114   0E46         MOV.W   R6, R14
   \   000116   0F47         MOV.W   R7, R15
   \   000118   CC0A         MOVA    R10, R12
   \   00011A   ........     CALLA   #st_clust
   3397          				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
   \   00011E   3E402000     MOV.W   #0x20, R14
   \   000122   CD0A         MOVA    R10, R13
   \   000124   CC0A         MOVA    R10, R12
   \   000126   AC002000     ADDA    #0x20, R12
   \   00012A   ........     CALLA   #mem_cpy
   3398          				dir[33] = '.'; pcl = dj.sclust;
   \   00012E   FA402E002100 MOV.B   #0x2e, 0x21(R10)
   \   000134   91410E000200 MOV.W   0xe(SP), 0x2(SP)
   \   00013A   914110000400 MOV.W   0x10(SP), 0x4(SP)
   3399          				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
   \   000140   3F010600     MOVA    0x6(SP), R15
   \   000144   FF9003000000 CMP.B   #0x3, 0(R15)
   \   00014A   0E20         JNE     ??f_mkdir_10
   \   00014C   3F010600     MOVA    0x6(SP), R15
   \   000150   919F26000200 CMP.W   0x26(R15), 0x2(SP)
   \   000156   0820         JNE     ??f_mkdir_10
   \   000158   919F28000400 CMP.W   0x28(R15), 0x4(SP)
   \   00015E   0420         JNE     ??f_mkdir_10
   3400          					pcl = 0;
   \   000160   81430200     MOV.W   #0x0, 0x2(SP)
   \   000164   81430400     MOV.W   #0x0, 0x4(SP)
   3401          				st_clust(dir+SZ_DIR, pcl);
   \                     ??f_mkdir_10:
   \   000168   1E410200     MOV.W   0x2(SP), R14
   \   00016C   1F410400     MOV.W   0x4(SP), R15
   \   000170   CC0A         MOVA    R10, R12
   \   000172   AC002000     ADDA    #0x20, R12
   \   000176   ........     CALLA   #st_clust
   3402          				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
   \   00017A   3F010600     MOVA    0x6(SP), R15
   \   00017E   D14F02000000 MOV.B   0x2(R15), 0(SP)
   \                     ??f_mkdir_0:
   \   000184   C1930000     CMP.B   #0x0, 0(SP)
   \   000188   2024         JEQ     ??f_mkdir_2
   3403          					dj.fs->winsect = dsc++;
   \   00018A   3F010600     MOVA    0x6(SP), R15
   \   00018E   8F442E00     MOV.W   R4, 0x2e(R15)
   \   000192   8F453000     MOV.W   R5, 0x30(R15)
   \   000196   1453         ADD.W   #0x1, R4
   \   000198   0563         ADDC.W  #0x0, R5
   3404          					dj.fs->wflag = 1;
   \   00019A   3F010600     MOVA    0x6(SP), R15
   \   00019E   DF430400     MOV.B   #0x1, 0x4(R15)
   3405          					res = move_window(dj.fs, 0);
   \   0001A2   0E43         MOV.W   #0x0, R14
   \   0001A4   0F43         MOV.W   #0x0, R15
   \   0001A6   3C010600     MOVA    0x6(SP), R12
   \   0001AA   ........     CALLA   #move_window
   \   0001AE   4B4C         MOV.B   R12, R11
   3406          					if (res != FR_OK) break;
   \   0001B0   4B93         CMP.B   #0x0, R11
   \   0001B2   0B20         JNE     ??f_mkdir_2
   3407          					mem_set(dir, 0, SS(dj.fs));
   \   0001B4   3E400002     MOV.W   #0x200, R14
   \   0001B8   0D43         MOV.W   #0x0, R13
   \   0001BA   CC0A         MOVA    R10, R12
   \   0001BC   ........     CALLA   #mem_set
   3408          				}
   \   0001C0   6E41         MOV.B   @SP, R14
   \   0001C2   7E53         ADD.B   #0xff, R14
   \   0001C4   C14E0000     MOV.B   R14, 0(SP)
   \   0001C8   DD3F         JMP     ??f_mkdir_0
   3409          			}
   3410          			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
   \                     ??f_mkdir_2:
   \   0001CA   4B93         CMP.B   #0x0, R11
   \   0001CC   0620         JNE     ??f_mkdir_11
   \   0001CE   0C41         MOV.W   SP, R12
   \   0001D0   3C500600     ADD.W   #0x6, R12
   \   0001D4   ........     CALLA   #dir_register
   \   0001D8   4B4C         MOV.B   R12, R11
   3411          			if (res != FR_OK) {
   \                     ??f_mkdir_11:
   \   0001DA   4B93         CMP.B   #0x0, R11
   \   0001DC   0724         JEQ     ??f_mkdir_12
   3412          				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
   \   0001DE   0E46         MOV.W   R6, R14
   \   0001E0   0F47         MOV.W   R7, R15
   \   0001E2   3C010600     MOVA    0x6(SP), R12
   \   0001E6   ........     CALLA   #remove_chain
   \   0001EA   243C         JMP     ??f_mkdir_3
   3413          			} else {
   3414          				dir = dj.dir;
   \                     ??f_mkdir_12:
   \   0001EC   3A011A00     MOVA    0x1a(SP), R10
   3415          				dir[DIR_Attr] = AM_DIR;				/* Attribute */
   \   0001F0   FA4010000B00 MOV.B   #0x10, 0xb(R10)
   3416          				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
   \   0001F6   CA481600     MOV.B   R8, 0x16(R10)
   \   0001FA   0F48         MOV.W   R8, R15
   \   0001FC   8F10         SWPB    R15
   \   0001FE   3FF0FF00     AND.W   #0xff, R15
   \   000202   CA4F1700     MOV.B   R15, 0x17(R10)
   \   000206   CA491800     MOV.B   R9, 0x18(R10)
   \   00020A   0E48         MOV.W   R8, R14
   \   00020C   0F49         MOV.W   R9, R15
   \   00020E   8F10         SWPB    R15
   \   000210   4E4F         MOV.B   R15, R14
   \   000212   0F43         MOV.W   #0x0, R15
   \   000214   CA4E1900     MOV.B   R14, 0x19(R10)
   3417          				st_clust(dir, dcl);					/* Table start cluster */
   \   000218   0E46         MOV.W   R6, R14
   \   00021A   0F47         MOV.W   R7, R15
   \   00021C   CC0A         MOVA    R10, R12
   \   00021E   ........     CALLA   #st_clust
   3418          				dj.fs->wflag = 1;
   \   000222   3F010600     MOVA    0x6(SP), R15
   \   000226   DF430400     MOV.B   #0x1, 0x4(R15)
   3419          				res = sync(dj.fs);
   \   00022A   3C010600     MOVA    0x6(SP), R12
   \   00022E   ........     CALLA   #sync
   \   000232   4B4C         MOV.B   R12, R11
   3420          			}
   3421          		}
   3422          		FREE_BUF();
   3423          	}
   3424          
   3425          	LEAVE_FF(dj.fs, res);
   \                     ??f_mkdir_3:
   \   000234   4C4B         MOV.B   R11, R12
   \   000236   31500201     ADD.W   #0x102, SP
   \   00023A   7416         POPM.A  #0x8, R11
   \   00023C   1001         RETA
   3426          }
   3427          
   3428          
   3429          
   3430          
   3431          /*-----------------------------------------------------------------------*/
   3432          /* Change Attribute                                                      */
   3433          /*-----------------------------------------------------------------------*/
   3434          

   \                                 In  segment CODE, align 2
   3435          FRESULT f_chmod (
   \                     f_chmod:
   3436          	const TCHAR *path,	/* Pointer to the file path */
   3437          	BYTE value,			/* Attribute bits */
   3438          	BYTE mask			/* Attribute mask to change */
   3439          )
   3440          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   0C14         PUSHM.A #0x1, R12
   \   000004   3180F800     SUB.W   #0xf8, SP
   \   000008   4A4D         MOV.B   R13, R10
   \   00000A   4B4E         MOV.B   R14, R11
   3441          	FRESULT res;
   3442          	DIR dj;
   3443          	BYTE *dir;
   3444          	DEF_NAMEBUF;
   3445          
   3446          
   3447          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000C   5E43         MOV.B   #0x1, R14
   \   00000E   0D41         MOV.W   SP, R13
   \   000010   0D53         ADD.W   #0x0, R13
   \   000012   0C41         MOV.W   SP, R12
   \   000014   3C50F800     ADD.W   #0xf8, R12
   \   000018   ........     CALLA   #chk_mounted
   \   00001C   484C         MOV.B   R12, R8
   3448          	if (res == FR_OK) {
   \   00001E   4893         CMP.B   #0x0, R8
   \   000020   3520         JNE     ??f_chmod_0
   3449          		INIT_BUF(dj);
   \   000022   0F41         MOV.W   SP, R15
   \   000024   3F502200     ADD.W   #0x22, R15
   \   000028   710F1800     MOVA    R15, 0x18(SP)
   \   00002C   0F41         MOV.W   SP, R15
   \   00002E   3F502E00     ADD.W   #0x2e, R15
   \   000032   710F1C00     MOVA    R15, 0x1c(SP)
   3450          		res = follow_path(&dj, path);		/* Follow the file path */
   \   000036   3D01F800     MOVA    0xf8(SP), R13
   \   00003A   0C41         MOV.W   SP, R12
   \   00003C   0C53         ADD.W   #0x0, R12
   \   00003E   ........     CALLA   #follow_path
   \   000042   484C         MOV.B   R12, R8
   3451          		FREE_BUF();
   3452          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \   000044   4893         CMP.B   #0x0, R8
   \   000046   0820         JNE     ??f_chmod_1
   \   000048   3F011800     MOVA    0x18(SP), R15
   \   00004C   FFB020000B00 BIT.B   #0x20, 0xb(R15)
   \   000052   0228         JNC     ??f_chmod_1
   3453          			res = FR_INVALID_NAME;
   \   000054   78400600     MOV.B   #0x6, R8
   3454          		if (res == FR_OK) {
   \                     ??f_chmod_1:
   \   000058   4893         CMP.B   #0x0, R8
   \   00005A   1820         JNE     ??f_chmod_0
   3455          			dir = dj.dir;
   \   00005C   39011400     MOVA    0x14(SP), R9
   3456          			if (!dir) {						/* Is it a root directory? */
   \   000060   D903         CMPA    #0x0, R9
   \   000062   0320         JNE     ??f_chmod_2
   3457          				res = FR_INVALID_NAME;
   \   000064   78400600     MOV.B   #0x6, R8
   \   000068   113C         JMP     ??f_chmod_0
   3458          			} else {						/* File or sub directory */
   3459          				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
   \                     ??f_chmod_2:
   \   00006A   7BF02700     AND.B   #0x27, R11
   3460          				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
   \   00006E   5E490B00     MOV.B   0xb(R9), R14
   \   000072   4ECB         BIC.B   R11, R14
   \   000074   4F4A         MOV.B   R10, R15
   \   000076   4FFB         AND.B   R11, R15
   \   000078   4FDE         BIS.B   R14, R15
   \   00007A   C94F0B00     MOV.B   R15, 0xb(R9)
   3461          				dj.fs->wflag = 1;
   \   00007E   0F01         MOVA    @SP, R15
   \   000080   DF430400     MOV.B   #0x1, 0x4(R15)
   3462          				res = sync(dj.fs);
   \   000084   0C01         MOVA    @SP, R12
   \   000086   ........     CALLA   #sync
   \   00008A   484C         MOV.B   R12, R8
   3463          			}
   3464          		}
   3465          	}
   3466          
   3467          	LEAVE_FF(dj.fs, res);
   \                     ??f_chmod_0:
   \   00008C   4C48         MOV.B   R8, R12
   \   00008E   3150FC00     ADD.W   #0xfc, SP
   \   000092   3816         POPM.A  #0x4, R11
   \   000094   1001         RETA
   3468          }
   3469          
   3470          
   3471          
   3472          
   3473          /*-----------------------------------------------------------------------*/
   3474          /* Change Timestamp                                                      */
   3475          /*-----------------------------------------------------------------------*/
   3476          

   \                                 In  segment CODE, align 2
   3477          FRESULT f_utime (
   \                     f_utime:
   3478          	const TCHAR *path,	/* Pointer to the file/directory name */
   3479          	const FILINFO *fno	/* Pointer to the time stamp to be set */
   3480          )
   3481          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   0C14         PUSHM.A #0x1, R12
   \   000004   3180F800     SUB.W   #0xf8, SP
   \   000008   CA0D         MOVA    R13, R10
   3482          	FRESULT res;
   3483          	DIR dj;
   3484          	BYTE *dir;
   3485          	DEF_NAMEBUF;
   3486          
   3487          
   3488          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000A   5E43         MOV.B   #0x1, R14
   \   00000C   0D41         MOV.W   SP, R13
   \   00000E   0D53         ADD.W   #0x0, R13
   \   000010   0C41         MOV.W   SP, R12
   \   000012   3C50F800     ADD.W   #0xf8, R12
   \   000016   ........     CALLA   #chk_mounted
   \   00001A   4B4C         MOV.B   R12, R11
   3489          	if (res == FR_OK) {
   \   00001C   4B93         CMP.B   #0x0, R11
   \   00001E   3720         JNE     ??f_utime_0
   3490          		INIT_BUF(dj);
   \   000020   0F41         MOV.W   SP, R15
   \   000022   3F502200     ADD.W   #0x22, R15
   \   000026   710F1800     MOVA    R15, 0x18(SP)
   \   00002A   0F41         MOV.W   SP, R15
   \   00002C   3F502E00     ADD.W   #0x2e, R15
   \   000030   710F1C00     MOVA    R15, 0x1c(SP)
   3491          		res = follow_path(&dj, path);	/* Follow the file path */
   \   000034   3D01F800     MOVA    0xf8(SP), R13
   \   000038   0C41         MOV.W   SP, R12
   \   00003A   0C53         ADD.W   #0x0, R12
   \   00003C   ........     CALLA   #follow_path
   \   000040   4B4C         MOV.B   R12, R11
   3492          		FREE_BUF();
   3493          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \   000042   4B93         CMP.B   #0x0, R11
   \   000044   0820         JNE     ??f_utime_1
   \   000046   3F011800     MOVA    0x18(SP), R15
   \   00004A   FFB020000B00 BIT.B   #0x20, 0xb(R15)
   \   000050   0228         JNC     ??f_utime_1
   3494          			res = FR_INVALID_NAME;
   \   000052   7B400600     MOV.B   #0x6, R11
   3495          		if (res == FR_OK) {
   \                     ??f_utime_1:
   \   000056   4B93         CMP.B   #0x0, R11
   \   000058   1A20         JNE     ??f_utime_0
   3496          			dir = dj.dir;
   \   00005A   38011400     MOVA    0x14(SP), R8
   3497          			if (!dir) {					/* Root directory */
   \   00005E   D803         CMPA    #0x0, R8
   \   000060   0320         JNE     ??f_utime_2
   3498          				res = FR_INVALID_NAME;
   \   000062   7B400600     MOV.B   #0x6, R11
   \   000066   133C         JMP     ??f_utime_0
   3499          			} else {					/* File or sub-directory */
   3500          				ST_WORD(dir+DIR_WrtTime, fno->ftime);
   \                     ??f_utime_2:
   \   000068   D84A06001600 MOV.B   0x6(R10), 0x16(R8)
   \   00006E   D84A07001700 MOV.B   0x7(R10), 0x17(R8)
   3501          				ST_WORD(dir+DIR_WrtDate, fno->fdate);
   \   000074   D84A04001800 MOV.B   0x4(R10), 0x18(R8)
   \   00007A   D84A05001900 MOV.B   0x5(R10), 0x19(R8)
   3502          				dj.fs->wflag = 1;
   \   000080   0F01         MOVA    @SP, R15
   \   000082   DF430400     MOV.B   #0x1, 0x4(R15)
   3503          				res = sync(dj.fs);
   \   000086   0C01         MOVA    @SP, R12
   \   000088   ........     CALLA   #sync
   \   00008C   4B4C         MOV.B   R12, R11
   3504          			}
   3505          		}
   3506          	}
   3507          
   3508          	LEAVE_FF(dj.fs, res);
   \                     ??f_utime_0:
   \   00008E   4C4B         MOV.B   R11, R12
   \   000090   3150FC00     ADD.W   #0xfc, SP
   \   000094   3816         POPM.A  #0x4, R11
   \   000096   1001         RETA
   3509          }
   3510          
   3511          
   3512          
   3513          
   3514          /*-----------------------------------------------------------------------*/
   3515          /* Rename File/Directory                                                 */
   3516          /*-----------------------------------------------------------------------*/
   3517          

   \                                 In  segment CODE, align 2
   3518          FRESULT f_rename (
   \                     f_rename:
   3519          	const TCHAR *path_old,	/* Pointer to the old name */
   3520          	const TCHAR *path_new	/* Pointer to the new name */
   3521          )
   3522          {
   \   000000   5B14         PUSHM.A #0x6, R11
   \   000002   0C14         PUSHM.A #0x1, R12
   \   000004   31803001     SUB.W   #0x130, SP
   \   000008   C60D         MOVA    R13, R6
   3523          	FRESULT res;
   3524          	DIR djo, djn;
   3525          	BYTE buf[21], *dir;
   3526          	DWORD dw;
   3527          	DEF_NAMEBUF;
   3528          
   3529          
   3530          	res = chk_mounted(&path_old, &djo.fs, 1);
   \   00000A   5E43         MOV.B   #0x1, R14
   \   00000C   0D41         MOV.W   SP, R13
   \   00000E   0D53         ADD.W   #0x0, R13
   \   000010   0C41         MOV.W   SP, R12
   \   000012   3C503001     ADD.W   #0x130, R12
   \   000016   ........     CALLA   #chk_mounted
   \   00001A   4A4C         MOV.B   R12, R10
   3531          	if (res == FR_OK) {
   \   00001C   4A93         CMP.B   #0x0, R10
   \   00001E   BA20         JNE     ??f_rename_0
   3532          		djn.fs = djo.fs;
   \   000020   0018E1412200 MOVX.A  @SP, 0x22(SP)
   3533          		INIT_BUF(djo);
   \   000026   0F41         MOV.W   SP, R15
   \   000028   3F504400     ADD.W   #0x44, R15
   \   00002C   710F1800     MOVA    R15, 0x18(SP)
   \   000030   0F41         MOV.W   SP, R15
   \   000032   3F506600     ADD.W   #0x66, R15
   \   000036   710F1C00     MOVA    R15, 0x1c(SP)
   3534          		res = follow_path(&djo, path_old);		/* Check old object */
   \   00003A   3D013001     MOVA    0x130(SP), R13
   \   00003E   0C41         MOV.W   SP, R12
   \   000040   0C53         ADD.W   #0x0, R12
   \   000042   ........     CALLA   #follow_path
   \   000046   4A4C         MOV.B   R12, R10
   3535          		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
   \   000048   4A93         CMP.B   #0x0, R10
   \   00004A   0820         JNE     ??f_rename_1
   \   00004C   3F011800     MOVA    0x18(SP), R15
   \   000050   FFB020000B00 BIT.B   #0x20, 0xb(R15)
   \   000056   0228         JNC     ??f_rename_1
   3536          			res = FR_INVALID_NAME;
   \   000058   7A400600     MOV.B   #0x6, R10
   3537          #if _FS_LOCK
   3538          		if (res == FR_OK) res = chk_lock(&djo, 2);
   3539          #endif
   3540          		if (res == FR_OK) {						/* Old object is found */
   \                     ??f_rename_1:
   \   00005C   4A93         CMP.B   #0x0, R10
   \   00005E   9A20         JNE     ??f_rename_0
   3541          			if (!djo.dir) {						/* Is root dir? */
   \   000060   3F011400     MOVA    0x14(SP), R15
   \   000064   DF03         CMPA    #0x0, R15
   \   000066   0220         JNE     ??f_rename_2
   3542          				res = FR_NO_FILE;
   \   000068   6A42         MOV.B   #0x4, R10
   \   00006A   943C         JMP     ??f_rename_0
   3543          			} else {
   3544          				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
   \                     ??f_rename_2:
   \   00006C   3E401500     MOV.W   #0x15, R14
   \   000070   3D011400     MOVA    0x14(SP), R13
   \   000074   AD000B00     ADDA    #0xb, R13
   \   000078   0C41         MOV.W   SP, R12
   \   00007A   3C505000     ADD.W   #0x50, R12
   \   00007E   ........     CALLA   #mem_cpy
   3545          				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
   \   000082   3E402200     MOV.W   #0x22, R14
   \   000086   0D41         MOV.W   SP, R13
   \   000088   0D53         ADD.W   #0x0, R13
   \   00008A   0C41         MOV.W   SP, R12
   \   00008C   3C502200     ADD.W   #0x22, R12
   \   000090   ........     CALLA   #mem_cpy
   3546          				res = follow_path(&djn, path_new);
   \   000094   CD06         MOVA    R6, R13
   \   000096   0C41         MOV.W   SP, R12
   \   000098   3C502200     ADD.W   #0x22, R12
   \   00009C   ........     CALLA   #follow_path
   \   0000A0   4A4C         MOV.B   R12, R10
   3547          				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
   \   0000A2   4A93         CMP.B   #0x0, R10
   \   0000A4   0120         JNE     ??f_rename_3
   \   0000A6   7A42         MOV.B   #0x8, R10
   3548          				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
   \                     ??f_rename_3:
   \   0000A8   6A92         CMP.B   #0x4, R10
   \   0000AA   7420         JNE     ??f_rename_0
   3549          /* Start critical section that an interruption or error can cause cross-link */
   3550          					res = dir_register(&djn);			/* Register the new entry */
   \   0000AC   0C41         MOV.W   SP, R12
   \   0000AE   3C502200     ADD.W   #0x22, R12
   \   0000B2   ........     CALLA   #dir_register
   \   0000B6   4A4C         MOV.B   R12, R10
   3551          					if (res == FR_OK) {
   \   0000B8   4A93         CMP.B   #0x0, R10
   \   0000BA   6C20         JNE     ??f_rename_0
   3552          						dir = djn.dir;					/* Copy object information except for name */
   \   0000BC   3B013600     MOVA    0x36(SP), R11
   3553          						mem_cpy(dir+13, buf+2, 19);
   \   0000C0   3E401300     MOV.W   #0x13, R14
   \   0000C4   0D41         MOV.W   SP, R13
   \   0000C6   3D505200     ADD.W   #0x52, R13
   \   0000CA   CC0B         MOVA    R11, R12
   \   0000CC   AC000D00     ADDA    #0xd, R12
   \   0000D0   ........     CALLA   #mem_cpy
   3554          						dir[DIR_Attr] = buf[0] | AM_ARC;
   \   0000D4   5E415000     MOV.B   0x50(SP), R14
   \   0000D8   7ED02000     BIS.B   #0x20, R14
   \   0000DC   CB4E0B00     MOV.B   R14, 0xb(R11)
   3555          						djo.fs->wflag = 1;
   \   0000E0   0F01         MOVA    @SP, R15
   \   0000E2   DF430400     MOV.B   #0x1, 0x4(R15)
   3556          						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
   \   0000E6   91912A000800 CMP.W   0x2a(SP), 0x8(SP)
   \   0000EC   0420         JNE     ??f_rename_4
   \   0000EE   91912C000A00 CMP.W   0x2c(SP), 0xa(SP)
   \   0000F4   4224         JEQ     ??f_rename_5
   \                     ??f_rename_4:
   \   0000F6   FBB010000B00 BIT.B   #0x10, 0xb(R11)
   \   0000FC   3E28         JNC     ??f_rename_5
   3557          							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
   \   0000FE   CD0B         MOVA    R11, R13
   \   000100   0C01         MOVA    @SP, R12
   \   000102   ........     CALLA   #ld_clust
   \   000106   0E4C         MOV.W   R12, R14
   \   000108   0F4D         MOV.W   R13, R15
   \   00010A   0C01         MOVA    @SP, R12
   \   00010C   ........     CALLA   #clust2sect
   \   000110   084C         MOV.W   R12, R8
   \   000112   094D         MOV.W   R13, R9
   3558          							if (!dw) {
   \   000114   0F48         MOV.W   R8, R15
   \   000116   0FD9         BIS.W   R9, R15
   \   000118   0F93         CMP.W   #0x0, R15
   \   00011A   0220         JNE     ??f_rename_6
   3559          								res = FR_INT_ERR;
   \   00011C   6A43         MOV.B   #0x2, R10
   \   00011E   2D3C         JMP     ??f_rename_5
   3560          							} else {
   3561          								res = move_window(djo.fs, dw);
   \                     ??f_rename_6:
   \   000120   0E48         MOV.W   R8, R14
   \   000122   0F49         MOV.W   R9, R15
   \   000124   0C01         MOVA    @SP, R12
   \   000126   ........     CALLA   #move_window
   \   00012A   4A4C         MOV.B   R12, R10
   3562          								dir = djo.fs->win+SZ_DIR;	/* .. entry */
   \   00012C   0F01         MOVA    @SP, R15
   \   00012E   AF005200     ADDA    #0x52, R15
   \   000132   CB0F         MOVA    R15, R11
   3563          								if (res == FR_OK && dir[1] == '.') {
   \   000134   4A93         CMP.B   #0x0, R10
   \   000136   2120         JNE     ??f_rename_5
   \   000138   FB902E000100 CMP.B   #0x2e, 0x1(R11)
   \   00013E   1D20         JNE     ??f_rename_5
   3564          									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
   \   000140   0F01         MOVA    @SP, R15
   \   000142   FF9003000000 CMP.B   #0x3, 0(R15)
   \   000148   0C20         JNE     ??f_rename_7
   \   00014A   0F01         MOVA    @SP, R15
   \   00014C   919F26002A00 CMP.W   0x26(R15), 0x2a(SP)
   \   000152   0720         JNE     ??f_rename_7
   \   000154   919F28002C00 CMP.W   0x28(R15), 0x2c(SP)
   \   00015A   0320         JNE     ??f_rename_7
   \   00015C   0843         MOV.W   #0x0, R8
   \   00015E   0943         MOV.W   #0x0, R9
   \   000160   043C         JMP     ??f_rename_8
   \                     ??f_rename_7:
   \   000162   18412A00     MOV.W   0x2a(SP), R8
   \   000166   19412C00     MOV.W   0x2c(SP), R9
   3565          									st_clust(dir, dw);
   \                     ??f_rename_8:
   \   00016A   0E48         MOV.W   R8, R14
   \   00016C   0F49         MOV.W   R9, R15
   \   00016E   CC0B         MOVA    R11, R12
   \   000170   ........     CALLA   #st_clust
   3566          									djo.fs->wflag = 1;
   \   000174   0F01         MOVA    @SP, R15
   \   000176   DF430400     MOV.B   #0x1, 0x4(R15)
   3567          								}
   3568          							}
   3569          						}
   3570          						if (res == FR_OK) {
   \                     ??f_rename_5:
   \   00017A   4A93         CMP.B   #0x0, R10
   \   00017C   0B20         JNE     ??f_rename_0
   3571          							res = dir_remove(&djo);		/* Remove old entry */
   \   00017E   0C41         MOV.W   SP, R12
   \   000180   0C53         ADD.W   #0x0, R12
   \   000182   ........     CALLA   #dir_remove
   \   000186   4A4C         MOV.B   R12, R10
   3572          							if (res == FR_OK)
   \   000188   4A93         CMP.B   #0x0, R10
   \   00018A   0420         JNE     ??f_rename_0
   3573          								res = sync(djo.fs);
   \   00018C   0C01         MOVA    @SP, R12
   \   00018E   ........     CALLA   #sync
   \   000192   4A4C         MOV.B   R12, R10
   3574          						}
   3575          					}
   3576          /* End critical section */
   3577          				}
   3578          			}
   3579          		}
   3580          		FREE_BUF();
   3581          	}
   3582          	LEAVE_FF(djo.fs, res);
   \                     ??f_rename_0:
   \   000194   4C4A         MOV.B   R10, R12
   \   000196   31503401     ADD.W   #0x134, SP
   \   00019A   5616         POPM.A  #0x6, R11
   \   00019C   1001         RETA
   3583          }

   \                                 In  segment DATA20_C, align 1, align-sorted
   \                     `?<Constant "\\"*:<>?|\\177">`:
   \   000000   222A3A3C3E3F DC8 "\"*:<>?|\177"
   \            7C7F00      

   \                                 In  segment DATA20_C, align 1, align-sorted
   \                     `?<Constant "+,;=[]">`:
   \   000000   2B2C3B3D5B5D DC8 "+,;=[]"
   \            00          

   \                                 In  segment DATA20_C, align 1, align-sorted
   \                     `?<Constant "/%s">`:
   \   000000   2F257300     DC8 "/%s"

   \                                 In  segment DATA20_C, align 1, align-sorted
   \                     `?<Constant "%s/%s\\n">`:
   \   000000   25732F25730A DC8 "%s/%s\012"
   \            00          
   3584          
   3585          #endif /* !_FS_READONLY */
   3586          #endif /* _FS_MINIMIZE == 0 */
   3587          #endif /* _FS_MINIMIZE <= 1 */
   3588          #endif /* _FS_MINIMIZE <= 2 */
   3589          
   3590          
   3591          
   3592          /*-----------------------------------------------------------------------*/
   3593          /* Forward data to the stream directly (available on only tiny cfg)      */
   3594          /*-----------------------------------------------------------------------*/
   3595          #if _USE_FORWARD && _FS_TINY
   3596          
   3597          FRESULT f_forward (
   3598          	FIL *fp, 						/* Pointer to the file object */
   3599          	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
   3600          	UINT btr,						/* Number of bytes to forward */
   3601          	UINT *bf						/* Pointer to number of bytes forwarded */
   3602          )
   3603          {
   3604          	FRESULT res;
   3605          	DWORD remain, clst, sect;
   3606          	UINT rcnt;
   3607          	BYTE csect;
   3608          
   3609          
   3610          	*bf = 0;	/* Clear transfer byte counter */
   3611          
   3612          	if (!fp) return FR_INVALID_OBJECT;
   3613          
   3614          	res = validate(fp);								/* Check validity of the object */
   3615          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   3616          	if (fp->flag & FA__ERROR)						/* Check error flag */
   3617          		LEAVE_FF(fp->fs, FR_INT_ERR);
   3618          	if (!(fp->flag & FA_READ))						/* Check access mode */
   3619          		LEAVE_FF(fp->fs, FR_DENIED);
   3620          
   3621          	remain = fp->fsize - fp->fptr;
   3622          	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
   3623          
   3624          	for ( ;  btr && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
   3625          		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
   3626          		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   3627          		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
   3628          			if (!csect) {							/* On the cluster boundary? */
   3629          				clst = (fp->fptr == 0) ?			/* On the top of the file? */
   3630          					fp->sclust : get_fat(fp->fs, fp->clust);
   3631          				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
   3632          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   3633          				fp->clust = clst;					/* Update current cluster */
   3634          			}
   3635          		}
   3636          		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
   3637          		if (!sect) ABORT(fp->fs, FR_INT_ERR);
   3638          		sect += csect;
   3639          		if (move_window(fp->fs, sect))				/* Move sector window */
   3640          			ABORT(fp->fs, FR_DISK_ERR);
   3641          		fp->dsect = sect;
   3642          		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
   3643          		if (rcnt > btr) rcnt = btr;
   3644          		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
   3645          		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
   3646          	}
   3647          
   3648          	LEAVE_FF(fp->fs, FR_OK);
   3649          }
   3650          #endif /* _USE_FORWARD */
   3651          
   3652          
   3653          
   3654          #if _USE_MKFS && !_FS_READONLY
   3655          /*-----------------------------------------------------------------------*/
   3656          /* Create File System on the Drive                                       */
   3657          /*-----------------------------------------------------------------------*/
   3658          #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
   3659          #define N_FATS		1		/* Number of FAT copies (1 or 2) */
   3660          
   3661          
   3662          FRESULT f_mkfs (
   3663          	BYTE drv,		/* Logical drive number */
   3664          	BYTE sfd,		/* Partitioning rule 0:FDISK, 1:SFD */
   3665          	UINT au			/* Allocation unit size [bytes] */
   3666          )
   3667          {
   3668          	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
   3669          	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
   3670          	BYTE fmt, md, sys, *tbl, pdrv, part;
   3671          	DWORD n_clst, vs, n, wsect;
   3672          	UINT i;
   3673          	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
   3674          	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
   3675          	FATFS *fs;
   3676          	DSTATUS stat;
   3677          
   3678          
   3679          	/* Check mounted drive and clear work area */
   3680          	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
   3681          	if (sfd > 1) return FR_INVALID_PARAMETER;
   3682          	if (au & (au - 1)) return FR_INVALID_PARAMETER;
   3683          	fs = FatFs[drv];
   3684          	if (!fs) return FR_NOT_ENABLED;
   3685          	fs->fs_type = 0;
   3686          	pdrv = LD2PD(drv);	/* Physical drive */
   3687          	part = LD2PT(drv);	/* Partition (0:auto detect, 1-4:get from partition table)*/
   3688          
   3689          	/* Get disk statics */
   3690          	stat = disk_initialize(pdrv);
   3691          	if (stat & STA_NOINIT) return FR_NOT_READY;
   3692          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   3693          #if _MAX_SS != 512					/* Get disk sector size */
   3694          	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
   3695          		return FR_DISK_ERR;
   3696          #endif
   3697          	if (_MULTI_PARTITION && part) {
   3698          		/* Get partition information from partition table in the MBR */
   3699          		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
   3700          		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
   3701          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   3702          		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
   3703          		b_vol = LD_DWORD(tbl+8);	/* Volume start sector */
   3704          		n_vol = LD_DWORD(tbl+12);	/* Volume size */
   3705          	} else {
   3706          		/* Create a partition in this function */
   3707          		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
   3708          			return FR_DISK_ERR;
   3709          		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
   3710          		n_vol -= b_vol;				/* Volume size */
   3711          	}
   3712          
   3713          	if (!au) {				/* AU auto selection */
   3714          		vs = n_vol / (2000 / (SS(fs) / 512));
   3715          		for (i = 0; vs < vst[i]; i++) ;
   3716          		au = cst[i];
   3717          	}
   3718          	au /= SS(fs);		/* Number of sectors per cluster */
   3719          	if (au == 0) au = 1;
   3720          	if (au > 128) au = 128;
   3721          
   3722          	/* Pre-compute number of clusters and FAT sub-type */
   3723          	n_clst = n_vol / au;
   3724          	fmt = FS_FAT12;
   3725          	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
   3726          	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
   3727          
   3728          	/* Determine offset and size of FAT structure */
   3729          	if (fmt == FS_FAT32) {
   3730          		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
   3731          		n_rsv = 32;
   3732          		n_dir = 0;
   3733          	} else {
   3734          		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
   3735          		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
   3736          		n_rsv = 1;
   3737          		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
   3738          	}
   3739          	b_fat = b_vol + n_rsv;				/* FAT area start sector */
   3740          	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
   3741          	b_data = b_dir + n_dir;				/* Data area start sector */
   3742          	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
   3743          
   3744          	/* Align data start sector to erase block boundary (for flash memory media) */
   3745          	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
   3746          	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
   3747          	n = (n - b_data) / N_FATS;
   3748          	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
   3749          		n_rsv += n;
   3750          		b_fat += n;
   3751          	} else {					/* FAT12/16: Expand FAT size */
   3752          		n_fat += n;
   3753          	}
   3754          
   3755          	/* Determine number of clusters and final check of validity of the FAT sub-type */
   3756          	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
   3757          	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
   3758          		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
   3759          		return FR_MKFS_ABORTED;
   3760          
   3761          	switch (fmt) {	/* Determine system ID for partition table */
   3762          	case FS_FAT12:	sys = 0x01; break;
   3763          	case FS_FAT16:	sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
   3764          	default: 		sys = 0x0C;
   3765          	}
   3766          
   3767          	if (_MULTI_PARTITION && part) {
   3768          		/* Update system ID in the partition table */
   3769          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   3770          		tbl[4] = sys;
   3771          		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
   3772          		md = 0xF8;
   3773          	} else {
   3774          		if (sfd) {	/* No partition table (SFD) */
   3775          			md = 0xF0;
   3776          		} else {	/* Create partition table (FDISK) */
   3777          			mem_set(fs->win, 0, SS(fs));
   3778          			tbl = fs->win+MBR_Table;	/* Create partition table for single partition in the drive */
   3779          			tbl[1] = 1;						/* Partition start head */
   3780          			tbl[2] = 1;						/* Partition start sector */
   3781          			tbl[3] = 0;						/* Partition start cylinder */
   3782          			tbl[4] = sys;					/* System type */
   3783          			tbl[5] = 254;					/* Partition end head */
   3784          			n = (b_vol + n_vol) / 63 / 255;
   3785          			tbl[6] = (BYTE)((n >> 2) | 63);	/* Partition end sector */
   3786          			tbl[7] = (BYTE)n;				/* End cylinder */
   3787          			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
   3788          			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
   3789          			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
   3790          			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR sector */
   3791          				return FR_DISK_ERR;
   3792          			md = 0xF8;
   3793          		}
   3794          	}
   3795          
   3796          	/* Create BPB in the VBR */
   3797          	tbl = fs->win;							/* Clear sector */
   3798          	mem_set(tbl, 0, SS(fs));
   3799          	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
   3800          	i = SS(fs);								/* Sector size */
   3801          	ST_WORD(tbl+BPB_BytsPerSec, i);
   3802          	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
   3803          	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
   3804          	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
   3805          	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
   3806          	ST_WORD(tbl+BPB_RootEntCnt, i);
   3807          	if (n_vol < 0x10000) {					/* Number of total sectors */
   3808          		ST_WORD(tbl+BPB_TotSec16, n_vol);
   3809          	} else {
   3810          		ST_DWORD(tbl+BPB_TotSec32, n_vol);
   3811          	}
   3812          	tbl[BPB_Media] = md;					/* Media descriptor */
   3813          	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
   3814          	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
   3815          	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
   3816          	n = get_fattime();						/* Use current time as VSN */
   3817          	if (fmt == FS_FAT32) {
   3818          		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
   3819          		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
   3820          		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
   3821          		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
   3822          		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
   3823          		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
   3824          		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
   3825          		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
   3826          	} else {
   3827          		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
   3828          		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
   3829          		tbl[BS_DrvNum] = 0x80;				/* Drive number */
   3830          		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
   3831          		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
   3832          	}
   3833          	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
   3834          	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
   3835          		return FR_DISK_ERR;
   3836          	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
   3837          		disk_write(pdrv, tbl, b_vol + 6, 1);
   3838          
   3839          	/* Initialize FAT area */
   3840          	wsect = b_fat;
   3841          	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
   3842          		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
   3843          		n = md;								/* Media descriptor byte */
   3844          		if (fmt != FS_FAT32) {
   3845          			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
   3846          			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
   3847          		} else {
   3848          			n |= 0xFFFFFF00;
   3849          			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
   3850          			ST_DWORD(tbl+4, 0xFFFFFFFF);
   3851          			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
   3852          		}
   3853          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   3854          			return FR_DISK_ERR;
   3855          		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
   3856          		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
   3857          			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   3858          				return FR_DISK_ERR;
   3859          		}
   3860          	}
   3861          
   3862          	/* Initialize root directory */
   3863          	i = (fmt == FS_FAT32) ? au : n_dir;
   3864          	do {
   3865          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   3866          			return FR_DISK_ERR;
   3867          	} while (--i);
   3868          
   3869          #if _USE_ERASE	/* Erase data area if needed */
   3870          	{
   3871          		DWORD eb[2];
   3872          
   3873          		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
   3874          		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
   3875          	}
   3876          #endif
   3877          
   3878          	/* Create FSInfo if needed */
   3879          	if (fmt == FS_FAT32) {
   3880          		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
   3881          		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
   3882          		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
   3883          		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
   3884          		ST_WORD(tbl+BS_55AA, 0xAA55);
   3885          		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
   3886          		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
   3887          	}
   3888          
   3889          	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
   3890          }
   3891          
   3892          
   3893          #if _MULTI_PARTITION == 2
   3894          /*-----------------------------------------------------------------------*/
   3895          /* Divide Physical Drive                                                 */
   3896          /*-----------------------------------------------------------------------*/
   3897          
   3898          FRESULT f_fdisk (
   3899          	BYTE pdrv,			/* Physical drive number */
   3900          	const DWORD szt[],	/* Pointer to the size table for each partitions */
   3901          	void* work			/* Pointer to the working buffer */
   3902          )
   3903          {
   3904          	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
   3905          	BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
   3906          	DSTATUS stat;
   3907          	DWORD sz_disk, sz_part, s_part;
   3908          
   3909          
   3910          	stat = disk_initialize(pdrv);
   3911          	if (stat & STA_NOINIT) return FR_NOT_READY;
   3912          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   3913          	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
   3914          
   3915          	/* Determine CHS in the table regardless of the drive geometry */
   3916          	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
   3917          	if (n == 256) n--;
   3918          	e_hd = n - 1;
   3919          	sz_cyl = 63 * n;
   3920          	tot_cyl = sz_disk / sz_cyl;
   3921          
   3922          	/* Create partition table */
   3923          	mem_set(buf, 0, _MAX_SS);
   3924          	p = buf + MBR_Table; b_cyl = 0;
   3925          	for (i = 0; i < 4; i++, p += SZ_PTE) {
   3926          		p_cyl = (szt[i] <= 100) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
   3927          		if (!p_cyl) continue;
   3928          		s_part = (DWORD)sz_cyl * b_cyl;
   3929          		sz_part = (DWORD)sz_cyl * p_cyl;
   3930          		if (i == 0) {	/* Exclude first track of cylinder 0 */
   3931          			s_hd = 1;
   3932          			s_part += 63; sz_part -= 63;
   3933          		} else {
   3934          			s_hd = 0;
   3935          		}
   3936          		e_cyl = b_cyl + p_cyl - 1;
   3937          		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
   3938          
   3939          		/* Set partition table */
   3940          		p[1] = s_hd;						/* Start head */
   3941          		p[2] = (BYTE)((b_cyl >> 2) + 1);	/* Start sector */
   3942          		p[3] = (BYTE)b_cyl;					/* Start cylinder */
   3943          		p[4] = 0x06;						/* System type (temporary setting) */
   3944          		p[5] = e_hd;						/* End head */
   3945          		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
   3946          		p[7] = (BYTE)e_cyl;					/* End cylinder */
   3947          		ST_DWORD(p + 8, s_part);			/* Start sector in LBA */
   3948          		ST_DWORD(p + 12, sz_part);			/* Partition size */
   3949          
   3950          		/* Next partition */
   3951          		b_cyl += p_cyl;
   3952          	}
   3953          	ST_WORD(p, 0xAA55);
   3954          
   3955          	/* Write it to the MBR */
   3956          	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
   3957          }
   3958          
   3959          
   3960          #endif /* _MULTI_PARTITION == 2 */
   3961          #endif /* _USE_MKFS && !_FS_READONLY */
   3962          
   3963          
   3964          
   3965          
   3966          #if _USE_STRFUNC
   3967          /*-----------------------------------------------------------------------*/
   3968          /* Get a string from the file                                            */
   3969          /*-----------------------------------------------------------------------*/
   3970          TCHAR* f_gets (
   3971          	TCHAR* buff,	/* Pointer to the string buffer to read */
   3972          	int len,		/* Size of string buffer (characters) */
   3973          	FIL* fil		/* Pointer to the file object */
   3974          )
   3975          {
   3976          	int n = 0;
   3977          	TCHAR c, *p = buff;
   3978          	BYTE s[2];
   3979          	UINT rc;
   3980          
   3981          
   3982          	while (n < len - 1) {			/* Read bytes until buffer gets filled */
   3983          		f_read(fil, s, 1, &rc);
   3984          		if (rc != 1) break;			/* Break on EOF or error */
   3985          		c = s[0];
   3986          #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
   3987          		if (c >= 0x80) {
   3988          			if (c < 0xC0) continue;	/* Skip stray trailer */
   3989          			if (c < 0xE0) {			/* Two-byte sequence */
   3990          				f_read(fil, s, 1, &rc);
   3991          				if (rc != 1) break;
   3992          				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
   3993          				if (c < 0x80) c = '?';
   3994          			} else {
   3995          				if (c < 0xF0) {		/* Three-byte sequence */
   3996          					f_read(fil, s, 2, &rc);
   3997          					if (rc != 2) break;
   3998          					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
   3999          					if (c < 0x800) c = '?';
   4000          				} else {			/* Reject four-byte sequence */
   4001          					c = '?';
   4002          				}
   4003          			}
   4004          		}
   4005          #endif
   4006          #if _USE_STRFUNC >= 2
   4007          		if (c == '\r') continue;	/* Strip '\r' */
   4008          #endif
   4009          		*p++ = c;
   4010          		n++;
   4011          		if (c == '\n') break;		/* Break on EOL */
   4012          	}
   4013          	*p = 0;
   4014          	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
   4015          }
   4016          
   4017          
   4018          
   4019          #if !_FS_READONLY
   4020          #include <stdarg.h>
   4021          /*-----------------------------------------------------------------------*/
   4022          /* Put a character to the file                                           */
   4023          /*-----------------------------------------------------------------------*/
   4024          int f_putc (
   4025          	TCHAR c,	/* A character to be output */
   4026          	FIL* fil	/* Pointer to the file object */
   4027          )
   4028          {
   4029          	UINT bw, btw;
   4030          	BYTE s[3];
   4031          
   4032          
   4033          #if _USE_STRFUNC >= 2
   4034          	if (c == '\n') f_putc ('\r', fil);	/* LF -> CRLF conversion */
   4035          #endif
   4036          
   4037          #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
   4038          	if (c < 0x80) {			/* 7-bit */
   4039          		s[0] = (BYTE)c;
   4040          		btw = 1;
   4041          	} else {
   4042          		if (c < 0x800) {	/* 11-bit */
   4043          			s[0] = (BYTE)(0xC0 | (c >> 6));
   4044          			s[1] = (BYTE)(0x80 | (c & 0x3F));
   4045          			btw = 2;
   4046          		} else {			/* 16-bit */
   4047          			s[0] = (BYTE)(0xE0 | (c >> 12));
   4048          			s[1] = (BYTE)(0x80 | ((c >> 6) & 0x3F));
   4049          			s[2] = (BYTE)(0x80 | (c & 0x3F));
   4050          			btw = 3;
   4051          		}
   4052          	}
   4053          #else				/* Write the character without conversion */
   4054          	s[0] = (BYTE)c;
   4055          	btw = 1;
   4056          #endif
   4057          	f_write(fil, s, btw, &bw);		/* Write the char to the file */
   4058          	return (bw == btw) ? 1 : EOF;	/* Return the result */
   4059          }
   4060          
   4061          
   4062          
   4063          
   4064          /*-----------------------------------------------------------------------*/
   4065          /* Put a string to the file                                              */
   4066          /*-----------------------------------------------------------------------*/
   4067          int f_puts (
   4068          	const TCHAR* str,	/* Pointer to the string to be output */
   4069          	FIL* fil			/* Pointer to the file object */
   4070          )
   4071          {
   4072          	int n;
   4073          
   4074          
   4075          	for (n = 0; *str; str++, n++) {
   4076          		if (f_putc(*str, fil) == EOF) return EOF;
   4077          	}
   4078          	return n;
   4079          }
   4080          
   4081          
   4082          
   4083          
   4084          /*-----------------------------------------------------------------------*/
   4085          /* Put a formatted string to the file                                    */
   4086          /*-----------------------------------------------------------------------*/
   4087          int f_printf (
   4088          	FIL* fil,			/* Pointer to the file object */
   4089          	const TCHAR* str,	/* Pointer to the format string */
   4090          	...					/* Optional arguments... */
   4091          )
   4092          {
   4093          	va_list arp;
   4094          	BYTE f, r;
   4095          	UINT i, j, w;
   4096          	ULONG v;
   4097          	TCHAR c, d, s[16], *p;
   4098          	int res, chc, cc;
   4099          
   4100          
   4101          	va_start(arp, str);
   4102          
   4103          	for (cc = res = 0; cc != EOF; res += cc) {
   4104          		c = *str++;
   4105          		if (c == 0) break;			/* End of string */
   4106          		if (c != '%') {				/* Non escape character */
   4107          			cc = f_putc(c, fil);
   4108          			if (cc != EOF) cc = 1;
   4109          			continue;
   4110          		}
   4111          		w = f = 0;
   4112          		c = *str++;
   4113          		if (c == '0') {				/* Flag: '0' padding */
   4114          			f = 1; c = *str++;
   4115          		} else {
   4116          			if (c == '-') {			/* Flag: left justified */
   4117          				f = 2; c = *str++;
   4118          			}
   4119          		}
   4120          		while (IsDigit(c)) {		/* Precision */
   4121          			w = w * 10 + c - '0';
   4122          			c = *str++;
   4123          		}
   4124          		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
   4125          			f |= 4; c = *str++;
   4126          		}
   4127          		if (!c) break;
   4128          		d = c;
   4129          		if (IsLower(d)) d -= 0x20;
   4130          		switch (d) {				/* Type is... */
   4131          		case 'S' :					/* String */
   4132          			p = va_arg(arp, TCHAR*);
   4133          			for (j = 0; p[j]; j++) ;
   4134          			chc = 0;
   4135          			if (!(f & 2)) {
   4136          				while (j++ < w) chc += (cc = f_putc(' ', fil));
   4137          			}
   4138          			chc += (cc = f_puts(p, fil));
   4139          			while (j++ < w) chc += (cc = f_putc(' ', fil));
   4140          			if (cc != EOF) cc = chc;
   4141          			continue;
   4142          		case 'C' :					/* Character */
   4143          			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
   4144          		case 'B' :					/* Binary */
   4145          			r = 2; break;
   4146          		case 'O' :					/* Octal */
   4147          			r = 8; break;
   4148          		case 'D' :					/* Signed decimal */
   4149          		case 'U' :					/* Unsigned decimal */
   4150          			r = 10; break;
   4151          		case 'X' :					/* Hexdecimal */
   4152          			r = 16; break;
   4153          		default:					/* Unknown type (pass-through) */
   4154          			cc = f_putc(c, fil); continue;
   4155          		}
   4156          
   4157          		/* Get an argument and put it in numeral */
   4158          		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
   4159          		if (d == 'D' && (v & 0x80000000)) {
   4160          			v = 0 - v;
   4161          			f |= 8;
   4162          		}
   4163          		i = 0;
   4164          		do {
   4165          			d = (TCHAR)(v % r); v /= r;
   4166          			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
   4167          			s[i++] = d + '0';
   4168          		} while (v && i < sizeof s / sizeof s[0]);
   4169          		if (f & 8) s[i++] = '-';
   4170          		j = i; d = (f & 1) ? '0' : ' ';
   4171          		res = 0;
   4172          		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
   4173          		do res += (cc = f_putc(s[--i], fil)); while(i);
   4174          		while (j++ < w) res += (cc = f_putc(' ', fil));
   4175          		if (cc != EOF) cc = res;
   4176          	}
   4177          
   4178          	va_end(arp);
   4179          	return (cc == EOF) ? cc : res;
   4180          }
   4181          
   4182          
   4183          #endif /* !_FS_READONLY */
   4184          #endif /* _USE_STRFUNC */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     22   check_fs
       22   -> disk_read
      4   chk_chr
     76   chk_mounted
       72   -> check_fs
       72   -> disk_initialize
       74   -> disk_read
       72   -> disk_status
     36   clmt_clust
      8   clust2sect
     28   cmp_lfn
       28   -> ff_wtoupper
     44   create_chain
       40   -> get_fat
       44   -> put_fat
     46   create_name
       46   -> chk_chr
       46   -> ff_convert
       46   -> mem_set
     36   dir_find
       36   -> cmp_lfn
       36   -> dir_next
       36   -> dir_sdi
       36   -> mem_cmp
       36   -> move_window
       36   -> sum_sfn
     28   dir_next
       28   -> clust2sect
       28   -> create_chain
       28   -> get_fat
       28   -> mem_set
       28   -> move_window
     36   dir_read
       36   -> dir_next
       36   -> move_window
       36   -> pick_lfn
       36   -> sum_sfn
     50   dir_register
       50   -> dir_find
       50   -> dir_next
       50   -> dir_sdi
       50   -> fit_lfn
       50   -> gen_numname
       50   -> mem_cpy
       50   -> mem_set
       50   -> move_window
       50   -> sum_sfn
     20   dir_remove
       20   -> dir_next
       20   -> dir_sdi
       20   -> move_window
     28   dir_sdi
       28   -> clust2sect
       28   -> get_fat
    260   f_chdir
      260   -> chk_mounted
      260   -> follow_path
      260   -> ld_clust
      4   f_chdrive
    272   f_chmod
      272   -> chk_mounted
      272   -> follow_path
      272   -> sync
     12   f_close
       12   -> f_sync
    316   f_getcwd
      316   -> chk_mounted
      316   -> dir_next
      316   -> dir_read
      316   -> dir_sdi
      316   -> get_fileinfo
      316   -> ld_clust
     62   f_getfree
       58   -> chk_mounted
       58   -> get_fat
       58   -> move_window
     64   f_lseek
       60   -> clmt_clust
       60   -> clust2sect
       60   -> create_chain
       62   -> disk_read
       62   -> disk_write
       60   -> get_fat
       60   -> validate
    294   f_mkdir
      294   -> chk_mounted
      294   -> clust2sect
      294   -> create_chain
      294   -> dir_register
      294   -> follow_path
      294   -> get_fattime
      294   -> mem_cpy
      294   -> mem_set
      294   -> move_window
      294   -> remove_chain
      294   -> st_clust
      294   -> sync
      8   f_mount
    288   f_open
      288   -> chk_mounted
      288   -> dir_register
      288   -> follow_path
      288   -> get_fattime
      288   -> ld_clust
      288   -> move_window
      288   -> remove_chain
      288   -> st_clust
    238   f_opendir
      238   -> chk_mounted
      238   -> dir_sdi
      238   -> follow_path
      238   -> ld_clust
     64   f_read
       54   -> clmt_clust
       54   -> clust2sect
       56   -> disk_read
       56   -> disk_write
       54   -> get_fat
       54   -> mem_cpy
       54   -> validate
    234   f_readdir
      234   -> dir_next
      234   -> dir_read
      234   -> dir_sdi
      234   -> get_fileinfo
      234   -> validate
    336   f_rename
      336   -> chk_mounted
      336   -> clust2sect
      336   -> dir_register
      336   -> dir_remove
      336   -> follow_path
      336   -> ld_clust
      336   -> mem_cpy
      336   -> move_window
      336   -> st_clust
      336   -> sync
    264   f_stat
      264   -> chk_mounted
      264   -> follow_path
      264   -> get_fileinfo
     30   f_sync
       30   -> disk_write
       28   -> get_fattime
       28   -> move_window
       28   -> st_clust
       28   -> sync
       28   -> validate
     24   f_truncate
       20   -> get_fat
       24   -> put_fat
       20   -> remove_chain
       20   -> validate
    306   f_unlink
      306   -> chk_mounted
      306   -> dir_read
      306   -> dir_remove
      306   -> dir_sdi
      306   -> follow_path
      306   -> ld_clust
      306   -> mem_cpy
      306   -> remove_chain
      306   -> sync
    272   f_utime
      272   -> chk_mounted
      272   -> follow_path
      272   -> sync
     56   f_write
       50   -> clmt_clust
       50   -> clust2sect
       50   -> create_chain
       52   -> disk_read
       52   -> disk_write
       50   -> mem_cpy
       50   -> validate
     28   fit_lfn
     24   follow_path
       24   -> create_name
       24   -> dir_find
       24   -> dir_sdi
       24   -> ld_clust
     44   gen_numname
       44   -> mem_cpy
     36   get_fat
       36   -> move_window
     42   get_fileinfo
       42   -> ff_convert
     12   ld_clust
     20   mem_cmp
     12   mem_cpy
      8   mem_set
     30   move_window
       30   -> disk_read
       30   -> disk_write
     28   pick_lfn
     36   put_fat
       36   -> move_window
     32   remove_chain
       28   -> get_fat
       32   -> put_fat
     90   scan_files
       82   -> f_opendir
       82   -> f_readdir
       90   -> printf
       86   -> scan_files
       86   -> sprintf
       82   -> strlen
      4   st_clust
      4   sum_sfn
     14   sync
       12   -> disk_ioctl
       14   -> disk_write
       12   -> mem_set
       12   -> move_window
     12   validate
       12   -> disk_status


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       7  ?<Constant "%s/%s\n">
       7  ?<Constant "+,;=[]">
       4  ?<Constant "/%s">
       9  ?<Constant "\"*:<>?|\177">
       1  CurrVol
       4  FatFs
       2  Fsid
      13  LfnOfs
     160  check_fs
      26  chk_chr
    1828  chk_mounted
     102  clmt_clust
      68  clust2sect
     164  cmp_lfn
     332  create_chain
     772  create_name
     228  dir_find
     402  dir_next
     198  dir_read
     464  dir_register
     102  dir_remove
     272  dir_sdi
     128  excvt
     148  f_chdir
      22  f_chdrive
     150  f_chmod
      28  f_close
     424  f_getcwd
     454  f_getfree
    1418  f_lseek
     574  f_mkdir
      56  f_mount
     518  f_open
     176  f_opendir
     782  f_read
     124  f_readdir
     414  f_rename
     108  f_stat
     238  f_sync
     244  f_truncate
     294  f_unlink
     152  f_utime
     864  f_write
     156  fit_lfn
     214  follow_path
     174  gen_numname
     420  get_fat
     422  get_fileinfo
      74  ld_clust
     101  lfn
      46  mem_cmp
      34  mem_cpy
      28  mem_set
     184  move_window
     152  pick_lfn
     494  put_fat
     156  remove_chain
     192  scan_files
      34  st_clust
      38  sum_sfn
     248  sync
      62  validate

 
 15 434 bytes in segment CODE
    168 bytes in segment DATA20_C
    108 bytes in segment DATA20_Z
 
 15 434 bytes of CODE  memory
    168 bytes of CONST memory
    108 bytes of DATA  memory

Errors: none
Warnings: none
